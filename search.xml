<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[29. Divide Two Integers]]></title>
    <url>%2F2019%2F11%2F15%2F29-Divide-Two-Integers%2F</url>
    <content type="text"><![CDATA[29. Divide Two IntegersGiven two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1: Input: dividend = 10, divisor = 3Output: 3 Example 2: Input: dividend = 7, divisor = -3Output: -2 Note: Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows. 题意：给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 注意：1. 被除数和除数均为 32 位有符号整数。 2. 除数不为 0。 3. 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。 思路：12345678910111213141516171819202122232425/** * 解题思路：这题是除法，所以先普及下除法术语 * 商，公式是：(被除数-余数)÷除数=商，记作：被除数÷除数=商...余数，是一种数学术语。 * 在一个除法算式里，被除数、余数、除数和商的关系为：(被除数-余数)÷除数=商，记作：被除数÷除数=商...余数， * 进而推导得出：商×除数+余数=被除数。 * * 要求商，我们首先想到的是减法，能被减多少次，那么商就为多少，但是明显减法的效率太低 * * 那么我们可以用位移法，因为计算机在做位移时效率特别高，向左移1相当于乘以2，向右位移1相当于除以2 * * 我们可以把一个dividend（被除数）先除以2^n，n最初为31，不断减小n去试探,当某个n满足dividend/2^n&gt;=divisor时， * * 表示我们找到了一个足够大的数，这个数*divisor是不大于dividend的，所以我们就可以减去2^n个divisor，以此类推 * * 我们可以以100/3为例 * * 2^n是1，2，4，8...2^31这种数，当n为31时，这个数特别大，100/2^n是一个很小的数，肯定是小于3的，所以循环下来， * * 当n=5时，100/32=3, 刚好是大于等于3的，这时我们将100-32*3=4，也就是减去了32个3，接下来我们再处理4，同样手法可以再减去一个3 * * 所以一共是减去了33个3，所以商就是33 * * 这其中得处理一些特殊的数，比如divisor是不能为0的，Integer.MIN_VALUE和Integer.MAX_VALUE * */ Java Code：12345678910111213141516171819202122232425262728class Solution &#123; public int divide(int dividend, int divisor) &#123; if (divisor == 0) &#123; return 0; &#125; if (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) &#123; return Integer.MAX_VALUE; &#125; boolean negative = (dividend ^ divisor) &lt; 0;//用异或来计算是否符号相异 long up = Math.abs((long)dividend); //注意转换为long类型 long down = Math.abs((long)divisor); int result = 0; for (int i = 31;i &gt;= 0;i--) &#123; long divValue = (up &gt;&gt; i); if (divValue &gt;= down) &#123; //找出足够大的数2^n*divisor up -= (down &lt;&lt; i); //将结果加上2^n result += (1 &lt;&lt; i); //将被除数减去2^n*divisor &#125; &#125; return negative ? -result : result; //符号相异取反 &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8. String to Integer (atoi)]]></title>
    <url>%2F2019%2F10%2F16%2F8-String-to-Integer-(atoi)%2F</url>
    <content type="text"><![CDATA[8. String to Integer (atoi)Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character &apos; &apos; is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned. Example 1: Input: “42”Output: 42 Example 2: Input: “ -42”Output: -42Explanation: The first non-whitespace character is ‘-‘, which is the minus sign. Then take as many numerical digits as possible, which gets 42. Example 3: Input: “4193 with words”Output: 4193Explanation: Conversion stops at digit ‘3’ as the next character is not a numerical digit. Example 4: Input: “words and 987”Output: 0Explanation: The first non-whitespace character is ‘w’, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: Input: “-91283472332”Output: -2147483648Explanation: The number “-91283472332” is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned. 题意：请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public int myAtoi(String str) &#123; if (null == str) &#123; return 0; &#125; str = str.trim(); int len = str.length(); if (len == 0) &#123; return 0; &#125; int i = 0; int res = 0; boolean positive = true; char first = str.charAt(0); if (first == '+') &#123; i++; &#125; else if (first == '-') &#123; positive = false; i++; &#125; for (;i &lt; len;i++) &#123; char c = str.charAt(i); int num = c - '0'; if (num &lt; 0 || num &gt; 9) &#123; break; &#125; if (positive) &#123; if (res &gt; Integer.MAX_VALUE / 10 || (res == Integer.MAX_VALUE / 10 &amp;&amp; num &gt; Integer.MAX_VALUE % 10)) &#123; return Integer.MAX_VALUE; &#125; res = res * 10 + num; &#125; else &#123; if (res &lt; Integer.MIN_VALUE / 10 || (res == Integer.MIN_VALUE / 10 &amp;&amp; -num &lt; Integer.MIN_VALUE % 10)) &#123; return Integer.MIN_VALUE; &#125; res = res * 10 - num; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9.Palindrome Number]]></title>
    <url>%2F2019%2F10%2F13%2F9-Palindrome-Number%2F</url>
    <content type="text"><![CDATA[9.Palindrome NumberDetermine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: Input: 121 Output: true Example 2: Input: -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: Input: 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up: Coud you solve it without converting the integer to a string? 题意： 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 1234567891011121314151617181920212223242526class Solution &#123; public boolean isPalindrome(int x) &#123; // Special cases: // As discussed above, when x &lt; 0, x is not a palindrome. // Also if the last digit of the number is 0, in order to be a palindrome, // the first digit of the number also needs to be 0. // Only 0 satisfy this property. if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123; return false; &#125; int rightNum = 0; while (x &gt; rightNum) &#123; int digit = x % 10; x /= 10; rightNum = rightNum * 10 + digit; &#125; // When the length is an odd number, we can get rid of the middle digit by revertedNumber/10 // For example when the input is 12321, at the end of the while loop we get x = 12, revertedNumber = 123, // since the middle digit doesn't matter in palidrome(it will always equal to itself), we can simply get rid of it. return x == rightNum || x == rightNum / 10; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7.Reverse Integer]]></title>
    <url>%2F2019%2F10%2F11%2F7-reverse-integer%2F</url>
    <content type="text"><![CDATA[7. Reverse IntegerGiven a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123 Output: 321 Example 2: Input: -123 Output: -321 Example 3: Input: 120 Output: 21 Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 题意： 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 注意： 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int reverse(int x) &#123; if (x &lt;= Integer.MIN_VALUE || x &gt;= Integer.MAX_VALUE) &#123; return 0; &#125; //Integer.MAX_VALUE = 2147483647 //Integer.MIN_VALUE = -2147483648 int maxCeiling = Integer.MAX_VALUE / 10; int minFloor = Integer.MIN_VALUE / 10; int res = 0; while (x != 0) &#123; if (res &gt; maxCeiling) &#123; return 0; &#125; if (res &lt; minFloor) &#123; return 0; &#125; int digit = x % 10; if (res == maxCeiling &amp;&amp; digit &gt; 7) &#123; return 0; &#125; if (res == minFloor &amp;&amp; digit &lt; -8) &#123; return 0; &#125; x /= 10; res = res * 10 + digit; &#125; return res; &#125;&#125; 12345678910111213141516171819202122232425class Solution &#123; public int reverse(int x) &#123; if (x &lt;= Integer.MIN_VALUE || x &gt;= Integer.MAX_VALUE) &#123; return 0; &#125; //Integer.MAX_VALUE = 2147483647 //Integer.MIN_VALUE = -2147483648 int maxCeiling = Integer.MAX_VALUE / 10; int minFloor = Integer.MIN_VALUE / 10; long res = 0; while (x != 0) &#123; int digit = x % 10; x /= 10; res = res * 10 + digit; if (res &lt;= Integer.MIN_VALUE || res &gt;= Integer.MAX_VALUE) &#123; return 0; &#125; &#125; return (int)res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CPU占用分析]]></title>
    <url>%2F2018%2F09%2F16%2FJava%2F2018-09-16-cpu-analysis%2F</url>
    <content type="text"><![CDATA[一、概述&ensp;&ensp;&ensp;当程序中出现死循环，或者计算量很大的线程的时候，就会导致Java程序进程占用大量CPU资源，从而可能导致程序挂掉，此文从实例进行概述具体的查询占用CPU资源高的程序代码。 二、排查步骤 查看占用CPU高的进程 top命令 查看进程中占用CPU最多的线程。 top -Hp ${pid} 命令（PID表示进程ID，排列靠前的几个基本都是此进程下最占用CPU资源的线程） 将进程信息转出到文件。 jstack -l ${pid} &gt; ${file.log} 将线程ID转成16进制。 printf ‘%x\n’ ${TID} 命令（TID表示线程ID） 根据16进制线程ID在3中输出的file.log中找到对应线程的息更具体代码信息。 三、具体实例1、实例代码&ensp;&ensp;&ensp;很简单的一个死循环例子，来模仿占用CPU资源，然后进行问题排查。12345678public class CPUTestDemo &#123; public static void main(String[] args) &#123; int i = 0; while (true) &#123; i++; &#125; &#125;&#125; 2、问题排查&ensp;&ensp;&ensp;1)、启动程序，top命令查看当前占用CPU资源最高的进程，如下图：&ensp;&ensp;&ensp;从图中可以看出进程5278所占用的CPU资源99.5%，并且从COMMAND能看出确实是启动的Java进程，说明Java程序中存在问题，导致狂占CPU资源。 &ensp;&ensp;&ensp;2)、对1)中得到的占用CPU资源高的进程执行top -Hp 5278，得到此Java进程内最占用CPU资源的线程，如下图：&ensp;&ensp;&ensp;从图中可以看出线程5279所占用的CPU资源99.6%，这就可以明确的定位到Java程序中占用CPU资源的线程号5279。 &ensp;&ensp;&ensp;3)、对2)中得到的占用CPU资源高的线程号执行printf ‘%x\n’ 5279，得到线程号的十六进制值149f，如下图： &ensp;&ensp;&ensp;4)、通过jstack -l 5278 &gt; file.log 重定向输出Java进程的jstack日志。 &ensp;&ensp;&ensp;5)、通过对3)中得到的线程十六进制值，在4)的file.log中查找线程中具体的占用CPU资源的代码信息，如下图：&ensp;&ensp;&ensp;从图中可以看出线程0x149f主线程中具体的占用CPU资源的代码行，定位到文字开始的实例代码，可以看到正常程序中的while死循环造成的CPU资源占用过高，从而定位代码问题。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[G1垃圾收集器]]></title>
    <url>%2F2018%2F09%2F09%2FJava%2Fjvm%2F2018-09-09-g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、概述&ensp;&ensp;&ensp;本文主要通过对比G1(Garbage-Firs Collector)和CMS(Concurrent Mark-Sweep Collector)垃圾收集器的堆内存结构，以及具体垃圾收集过程，每个过程中是怎么扫描虚拟机堆，来阐述G1垃圾收集器的原理和具体优势。 &ensp;&ensp;&ensp;G1是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器。以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征. 在Oracle JDK 7 update 4 及以上版本中得到完全支持, 专为以下应用程序设计: 可以像CMS收集器一样,GC操作与应用的线程一起并发执行。 紧凑的空闲内存区间且没有很长的GC停顿时间。 需要可预测的GC暂停耗时。 不想牺牲太多吞吐量性能。 启动后不需要请求更大的Java堆。 &ensp;&ensp;&ensp;G1的长期目标是取代CMS(Concurrent Mark-Sweep Collector, 并发标记-清除)。因为特性的不同使G1成为比CMS更好的解决方案。一个区别是,G1是一款压缩型的收集器。G1通过有效的压缩完全避免了对细微空闲内存空间的分配,不用依赖于regions，这不仅大大简化了收集器，而且还消除了潜在的内存碎片问题。除压缩以外，G1的垃圾收集停顿也比CMS容易估计，也允许用户自定义所希望的停顿参数。 二、G1、CMS垃圾收集器内存结构&ensp;&ensp;&ensp;G1出现之前的上一代垃圾收集器(串行serial, 并行parallel, 以及CMS)都把堆内存划分为固定大小的三个部分: 年轻代(young generation), 年老代(old generation), 以及持久代(permanent generation)。Java堆内存的每个对象都存放在这三个区域中的一个。 &ensp;&ensp;&ensp;G1采用一种不同的方式来管理堆内存。堆内存被划分为多个大小相等的heap区,每个heap区都是逻辑上连续的一段内存(virtual memory)。其中一部分区域被当成老一代收集器相同的角色(eden, survivor, old), 但每个角色的区域个数都不是固定的。这在内存使用上提供了更多的灵活性。 &ensp;&ensp;&ensp;G1执行垃圾回收的处理方式与CMS相似。G1在全局标记阶段(global marking phase)并发执行, 以确定堆内存中哪些对象是存活的。标记阶段完成后,G1就可以知道哪些heap区的empty空间最大。它会首先回收这些区,通常会得到大量的自由空间。这也是为什么这种垃圾收集方法叫做Garbage-First(垃圾优先)的原因。顾名思义, G1将精力集中放在可能布满可收回对象的区域, 可回收对象(reclaimable objects)也就是所谓的垃圾。G1使用暂停预测模型(pause prediction model)来达到用户定义的目标暂停时间,并根据目标暂停时间来选择此次进行垃圾回收的heap区域数量。 &ensp;&ensp;&ensp;被G1标记为适合回收的heap区将使用转移(evacuation)的方式进行垃圾回收。G1将一个或多个heap区域中的对象拷贝到其他的单个区域中,并在此过程中压缩和释放内存. 在多核CPU上转移是并行执行的(parallel on multi-processors), 这样能减少停顿时间并增加吞吐量。因此,每次垃圾收集时, G1都会持续不断地减少碎片, 并且在用户给定的暂停时间内执行。这比以前的方法强大了很多。CMS垃圾收集器(Concurrent Mark Sweep,并发标记清理)不进行压缩。ParallelOld垃圾收集只对整个堆执行压缩,从而导致相当长的暂停时间。 &ensp;&ensp;&ensp;需要强调的是, G1并不是一款实时垃圾收集器(real-time collector)。能以极高的概率在设定的目标暂停时间内完成,但不保证绝对在这个时间内完成。基于以前收集的各种监控数据,G1会根据用户指定的目标时间来预估能回收多少个heap区。因此,收集器有一个相当精确的heap区耗时计算模型,并根据该模型来确定在给定时间内去回收哪些heap区。 &ensp;&ensp;&ensp;注意：G1分为两个阶段: 并发阶段(concurrent, 与应用线程一起运行, 如: 细化 refinement、标记 marking、清理 cleanup) 和并行阶段(parallel, 多线程执行, 如: 停止所有JVM线程, stop the world)。而FullGC(完整垃圾收集)仍然是单线程的, 但如果进行适当的调优,则应用程序应该能够避免 full GC。 1、G1内存占用(Footprint)&ensp;&ensp;&ensp;如果从 ParallelOldGC 或者 CMS收集器迁移到 G1, 您可能会看到JVM进程占用更多的内存(a larger JVM process size)。这在很大程度上与 “accounting” 数据结构有关, 如 Remembered Sets 和 Collection Sets。 &ensp;&ensp;&ensp;Remembered Sets 简称 RSets, 跟踪指向某个heap区内的对象引用. 堆内存中的每个区都有一个 RSet。 RSet 使heap区能并行独立地进行垃圾集合。 RSets的总体影响小于5%. &ensp;&ensp;&ensp;Collection Sets 简称 CSets, 收集集合, 在一次GC中将执行垃圾回收的heap区。GC时在CSet中的所有存活数据(live data)都会被转移(复制/移动)。集合中的heap区可以是 Eden, survivor, old generation。CSets所占用的JVM内存小于1%。 2、推荐使用G1的场景(Recommended Use Cases)&ensp;&ensp;&ensp;G1的首要目标是为需要大量内存的系统提供一个保证GC低延迟的解决方案。也就是说堆内存在6GB及以上,稳定和可预测的暂停时间小于0.5秒。 &ensp;&ensp;&ensp;如果应用程序具有如下的一个或多个特征,那么将垃圾收集器从CMS或ParallelOldGC切换到G1将会大大提升性能。 Full GC 次数太频繁或者消耗时间太长. 对象分配的频率或代数提升(promotion)显著变化. 受够了太长的垃圾回收或内存整理时间(超过0.5~1秒) &ensp;&ensp;&ensp;注意: 如果正在使用CMS或ParallelOldGC,而应用程序的垃圾收集停顿时间并不长,那么继续使用现在的垃圾收集器是个好主意。使用最新的JDK时并不要求切换到G1收集器。 三、CMS垃圾收集器概述&ensp;&ensp;&ensp;并发标记清理(CMS, Concurrent Mark Sweep)收集器(也称为多并发低暂停的收集器)回收老年代内存(tenured generation)。它将垃圾回收中的绝大部分工作与应用程序的线程一起并发执行,以期能最小化暂停时间。通常多并发低暂停收集器不复制或也不压缩存活的对象。垃圾回收不移动存活的对象, 如果产生内存碎片问题,就会分配/占用更大的堆内存空间。 1、CMS垃圾收集阶段划分(Collection Phases)&ensp;&ensp;&ensp;CMS收集器在老年代堆内存的回收中执行分为以下阶段: table th:first-of-type { width: 245px; } 操作阶段 主要操作 1、初始标记 (Initial Mark) (Stop the World Event,所有应用线程暂停) 在老年代(old generation)中的对象, 如果从年轻代(young generation)中能访问到, 则被 “标记,marked” 为可达的(reachable)。暂停时间一般持续时间较短,相对小的收集暂停时间. 2、并发标记 (Concurrent Marking) 在Java应用程序线程运行的同时遍历老年代(tenured generation)的可达对象图。扫描从被标记的对象开始,直到遍历完从root可达的所有对象。调整器(mutators)在并发阶段的2、3、5阶段执行,在这些阶段中新分配的所有对象(包括被提升的对象)都立刻标记为存活状态。 3、再次标记(Remark) (Stop the World Event, 所有应用线程暂停) 查找在并发标记阶段漏过的对象，这些对象是在并发收集器完成对象跟踪之后由应用线程更新的。 4、并发清理(Concurrent Sweep) 回收在标记阶段(marking phases)确定为不可及的对象. 死对象的回收将此对象占用的空间增加到一个空闲列表(free list),供以后的分配使用。死对象的合并可能在此时发生. 请注意,存活的对象并没有被移动. 5、重置(Resetting) 清理数据结构,为下一个并发收集做准备. 2、CMS的GC步骤&ensp;1). CMS的堆内存结构(Heap Structure)&ensp;&ensp;&ensp;堆内存被分为3个空间。年轻代(Young generation)分为 1个新生代空间(Eden)和2个存活区(survivor spaces)，这三个空间默认大小比例是8:1:1。老年代(Old generation)是一大块连续的空间, CMS垃圾回收(Object collection)就地解决(is done in place)垃圾对象, 除了进行Full GC, 否则这个区域不会进行压缩(compaction). &ensp;2). CMS年轻代(Young) GC的工作方式&ensp;&ensp;&ensp;年轻代(young generation)用高亮的绿色表示, 老年代(old generation)用蓝色表示。如果程序运行了一段时间,那么 CMS 看起来就像下图这个样子，对象散落在老年代中的各处地方。在使用 CMS 时, 老年代的对象回收就地进行(deallocated in place)。他们不会被移动到其他地方，除了 Full GC, 否则内存空间不会进行压缩。 &ensp;3). 年轻代垃圾回收(Young Generation Collection)&ensp;&ensp;&ensp;Eden区和survivor区中的存活对象被拷贝到另一个空的survivor 区。存活时间更长,达到阀值的对象会被提升到老年代(promoted to old generation)。 &ensp;4). 年轻代(Young) GC 之后&ensp;&ensp;&ensp;年轻代(Young)进行一次垃圾回收之后, Eden 区被清理干净(cleared),两个 survivor 区中的一个也被清理干净了,如下图。图中新提升到老年代的对象用深蓝色来标识。绿色的部分是年轻代中存活的对象,但还没被提升到老年代中。 &ensp;5). CMS的老年代回收-标记(Old Generation Collection)&ensp;&ensp;&ensp;两次stop the world事件发生在: 初始标记(initial mark)以及重新标记(remark)阶段。当老年代达到一定的占有率时,CMS垃圾回收器就开始工作。&ensp;&ensp;&ensp;&ensp;a). 初始标记(Initial mark)阶段的停顿时间很短,在此阶段存活的(live)、可及的(reachable), 对象被记下来.&ensp;&ensp;&ensp;&ensp;b). 并发标记(Concurrent marking)在程序继续运行的同时找出存活的对象。&ensp;&ensp;&ensp;&ensp;c). 在第3阶段(remark phase), 查找在第2阶段(concurrent marking)中错过的对象。 &ensp;6). 老年代回收-并发清理(Concurrent Sweep)&ensp;&ensp;&ensp;在前面阶段未被标记的对象(Unmarked),即已死对象(Dead Objects)将会就地释放(deallocated in place)。此处没有压缩(compaction)。 &ensp;7). 老年代回收 - 清理之后(After Sweeping)&ensp;&ensp;&ensp;在第4步(Sweeping phase)之后, 可以看到很多内存被释放了。还应该注意到,这里并没有执行内存压缩整理(no compaction)。 &ensp;&ensp;&ensp;最后, CMS 收集器进入第5阶段, 重置(resetting phase), 然后等候下一次的GC阀值到来(GC threshold)。 四、G1垃圾收集器概述1、G1的堆内存结构&ensp;&ensp;&ensp;堆内存被划分为固定大小的多个区域。每个heap区(Region)的大小在JVM启动时就确定了。 JVM 通常生成 2000 个左右的heap区, 根据堆内存的总大小,区的size范围允许为 1Mb 到 32Mb。 2、G1 堆空间分配&ensp;&ensp;&ensp;G1的堆内存上一个个区域(regions)被映射为逻辑上的 Eden, Survivor, 和 old generation(老年代)空间。 &ensp;&ensp;&ensp;图中的颜色标识了每一个区域属于哪个角色。存活的对象从一块区域转移(复制或移动)到另一块区域。设计成 heap 区的目的是为了并行地进行垃圾回收的同时停止/或不停止其他应用程序线程. &ensp;&ensp;&ensp;图中heap区可以分配为 Eden, Survivor, 或 old generation(老年代)区。此外,还有第四种类型的对象被称为巨无霸区域(Humongous regions),这种巨无霸区是设计了用来保存比标准块(standard region)大50%及以上的对象, 它们存储在一组连续的区中。最后一个类型是堆内存中的未使用区(unused areas)。 3、G1的年轻代收集&ensp;1). G1中的年轻代(Young Generation)&ensp;&ensp;&ensp;堆被分为大约2000个区，这些区大小相同。每个区最小size为1 Mb, 最大size为 32Mb。蓝色的区保存老年代对象,绿色区域保存年轻代对象。并且G1中各代的heap区不像老一代垃圾收集器一样要求各部分是连续的。 &ensp;2). G1中的一次年轻代GC&ensp;&ensp;&ensp;存活的对象被转移(copied or moved)到一个或多个存活区(survivor regions)。 如果存活时间达到阀值,这部分对象就会被提升到老年代(promoted to old generation regions)。 &ensp;&ensp;&ensp;此时会有一次 stop the world(STW)暂停。会计算出 Eden大小和 survivor 大小,给下一次年轻代GC使用。清单统计信息(Accounting)保存了用来辅助计算size。诸如暂停时间目标之类的东西也会纳入考虑。&ensp;&ensp;&ensp;这种方法使得调整各代区域的尺寸很容易, 让其更大或更小一些以满足需要。 &ensp;3). G1的一次年轻代GC完成后&ensp;&ensp;&ensp;存活对象被转移到存活区(survivor regions) 或 老年代(old generation regions)。刚刚被提升上来的对象用深绿色显示。Survivor 区用绿色表示。 &ensp;4). G1的年轻代收集归纳 堆一整块内存空间,被分为多个heap区(regions)。 年轻代内存由一组不连续的heap区组成. 这使得在需要时很容易进行容量调整。 年轻代的垃圾收集,或者叫 young GC, 会有 stop the world 事件。在操作时所有的应用程序线程都会被暂停(stopped)。 年轻代 GC 通过多线程并行进行。 存活的对象被拷贝到新的 survivor 区或者老年代。 G1在已经使用堆内存的大小(Eden,Survivor,old generation,Humongous整体使用内存大小)，大约超过整个堆内存大小的75%的时候会触发Young GC。 4、G1的老年代收集&ensp;&ensp;&ensp;与CMS收集器相似, G1收集器也被设计为用来对老年代的对象进行低延迟(low pause)的垃圾收集。 &ensp;1). G1垃圾收集阶段划分&ensp;&ensp;&ensp;G1收集器在老年代堆内存中执行下面的这些阶段。 注意有些阶段也是年轻代垃圾收集的一部分。 操作阶段 主要操作 1、初始标记 (Initial Mark) (Stop the World Event,所有应用线程暂停) 此时会有一次 stop the world(STW)暂停事件. 在G1中, 这附加在(piggybacked on)一次正常的年轻代GC. 标记可能有引用指向老年代对象的survivor区(根regions). 2、扫描根区域(Root Region Scanning) 扫描 survivor 区中引用到老年代的引用。这个阶段应用程序的线程会继续运行。在年轻代GC可能发生之前此阶段必须完成。 3、并发标记(Concurrent Marking) 在整个堆中查找活着的对象。此阶段应用程序的线程正在运行。此阶段可以被年轻代GC打断(interrupted). 4、再次标记(Remark) (Stop the World Event,所有应用线程暂停) 完成堆内存中存活对象的标记。使用一个叫做 snapshot-at-the-beginning(SATB, 起始快照)的算法, 该算法比CMS所使用的算法要快速的多。 5、清理(Cleanup) (Stop the World,所有应用线程暂停,清理线程并发执行)在存活对象和完全空闲的区域上执行统计(accounting)。(Stop the world)擦写 Remembered Sets。(Stop the world)重置空heap区并将他们返还给空闲列表(free list)。 6、拷贝(Copying) (Stop the World,所有应用线程暂停) 转移或拷贝存活的对象到新的未使用的heap区(new unused regions)。只在年轻代发生时日志会记录为 [GC pause (young)]。如果在年轻代和老年代一起执行则会被日志记录为 [GC Pause (mixed)]。 &ensp;2). G1老年代收集步骤&ensp;&ensp;a). 初始标记阶段(Initial Marking Phase)&ensp;&ensp;&ensp;存活对象的初始标记被固定在年轻代垃圾收集里面。 在日志中被记为 GC pause (young)(inital-mark)。 &ensp;&ensp;b). 并发标记阶段(Concurrent Marking Phase)&ensp;&ensp;&ensp;如果找到空的区域(如用红叉“X”标示的区域), 则会在 Remark 阶段立即移除。 当然,”清单(accounting)”信息决定了活跃度(liveness)的计算。 &ensp;&ensp;c). 再次标记阶段(Remark Phase)&ensp;&ensp;&ensp;空的区域被移除并回收。现在计算所有区域的活跃度(Region liveness)。 &ensp;&ensp;d). 拷贝/清理阶段(Copying/Cleanup)&ensp;&ensp;&ensp;G1选择“活跃度(liveness)”最低的区域, 这些区域可以最快的完成回收。然后这些区域和年轻代GC在同时被垃圾收集，在日志被标识为 [GC pause (mixed)]。 所以年轻代和老年代都在同一时间被垃圾收集。 &ensp;&ensp;e). 拷贝/清理之后(After Copying/Cleanup)&ensp;&ensp;&ensp;所选择的区域被收集和压缩到下图所示的深蓝色区域和深绿色区域。 &ensp;3). G1的老年代收集归纳 并发标记阶段(Concurrent Marking Phase) 活跃度信息在程序运行的时候被并行计算出来。 活跃度(liveness)信息标识出哪些区域在转移暂停期间最适合回收. 再次标记阶段(Remark Phase) 使用的 Snapshot-at-the-Beginning (SATB, 开始快照) 算法比起 CMS所用的算法要快得多。 完全空的区域直接被回收。 拷贝/清理阶段(Copying/Cleanup Phase) 年轻代与老年代同时进行回收。 老年代的选择基于其活跃度(liveness)。 五、G1命令行参数六、G1的GC日志分析相关参考资源：G1垃圾收集器入门Getting Started with the G1 Garbage Collector]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM—GC 相关参数总结]]></title>
    <url>%2F2018%2F09%2F02%2FJava%2Fjvm%2F2018-09-02-jvm%E2%80%94gc-%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1. 与串行回收器相关的参数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:+UseSerialGC :&nbsp;&nbsp;&nbsp;在新生代和老年代使用串行回收器。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:+SuivivorRatio :&nbsp;&nbsp;&nbsp;设置 eden 区大小和 survivor 区大小的比例。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;-XX:+PretenureSizeThreshold :&nbsp;&nbsp;&nbsp;设置大对象直接进入老年代的阈值。当对象的大小超过这个值时，将直接在老年代分配。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;-XX:MaxTenuringThreshold :&nbsp;&nbsp;&nbsp;设置对象进入老年代的年龄的最大值。每一次 Minor GC 后，对象年龄就加 1。任何大于这个年龄的对象，一定会进入老年代。 2. 与并行 GC 相关的参数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:+UseParNewGC : &nbsp;&nbsp;&nbsp;在新生代使用并行收集器。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:+UseParallelOldGC : &nbsp;&nbsp;&nbsp;老年代使用并行回收收集器。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:ParallelGCThreads ：设置用于垃圾回收的线程数。通常情况下可以和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:MaxGCPauseMills ：设置最大垃圾收集停顿时间。它的值是一个大于 0 的整数。收集器在工作时，会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:GCTimeRatio :&nbsp;&nbsp;&nbsp;设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:+UseAdaptiveSizePolicy :&nbsp;&nbsp;&nbsp;打开自适应 GC 策略。在这种模式下，新生代的大小，eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。 3. 与 CMS 回收器相关的参数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:+UseConcMarkSweepGC :&nbsp;&nbsp;&nbsp; 新生代使用并行收集器，老年代使用 CMS+串行收集器。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:+ParallelCMSThreads : &nbsp;&nbsp;&nbsp;设定 CMS 的线程数量。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:+CMSInitiatingOccupancyFraction :&nbsp;&nbsp;&nbsp;设置 CMS 收集器在老年代空间被使用多少后触发，默认为 68% (JDK 1.6中提升至92%)。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:+UseFullGCsBeforeCompaction :&nbsp;&nbsp;&nbsp;设定进行多少次 CMS 垃圾回收后，进行一次内存压缩。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:+CMSClassUnloadingEnabled :&nbsp;&nbsp;&nbsp;允许对类元数据进行回收。？？？？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:+CMSParallelRemarkEndable :&nbsp;&nbsp;&nbsp;启用并行重标记。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:CMSInitatingPermOccupancyFraction :当永久区占用率达到这一百分比后，启动 CMS 回收 (前提是-XX:+CMSClassUnloadingEnabled 激活了)。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:UseCMSInitatingOccupancyOnly :表示只在到达阈值的时候，才进行 CMS 回收。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:+CMSIncrementalMode :&nbsp;&nbsp;&nbsp;使用增量模式，比较适合单 CPU。 4. 与 G1 回收器相关的参数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:+UseG1GC ：&nbsp;&nbsp;&nbsp;使用 G1 回收器。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:+UnlockExperimentalVMOptions :允许使用实验性参数。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:+MaxGCPauseMills :&nbsp;&nbsp;&nbsp;设置最大垃圾收集停顿时间。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:+GCPauseIntervalMills :&nbsp;&nbsp;&nbsp;设置停顿间隔时间。 5. 其他参数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:+DisableExplicitGC : &nbsp;&nbsp;&nbsp;禁用显示 GC。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM—垃圾收集器]]></title>
    <url>%2F2018%2F09%2F02%2FJava%2Fjvm%2F2018-09-02-jvm%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;上图展示了7种作用于不同分代的收集器（包括JDK 1.7_Update14之后正式提供商用的G1收集器），如果两个收集器之间存在连线，就说明它们可以搭配使用。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;在介绍这些收集器各自的特性之前，我们先来明确一个观点：虽然我们是在对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。因为直到现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器。这点不需要多加解释就能证明：如果有一种放之四海皆准、任何场景下都适用的完美收集器存在，那HotSpot虚拟机就没必要实现那么多不同的收集器了。 新生代收集器：&nbsp; &nbsp;&nbsp;&nbsp;1. Serial 收集器&nbsp; &nbsp;&nbsp;&nbsp;2. ParNew 收集器&nbsp; &nbsp;&nbsp;&nbsp;3. Parallel Scavenge 收集器 &nbsp; &nbsp;&nbsp;1、Serial 收集器 &nbsp; &nbsp;&nbsp;&nbsp;最基本、发展历史最悠久的收集器。&nbsp; &nbsp;&nbsp;&nbsp;适用：&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;看上去没什么用，但实际上到现在为止，它依然是虚拟机运行在Client模式下的默认新生代收集器。 &nbsp; &nbsp;&nbsp;&nbsp;特点:&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;1).单线程的收集器，说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;2).在它进行垃圾收集时，必须暂停其他所有的工作线程（Sun将这件事情称之为“Stop The World”）,直到它收集结束。这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户的正常工作的线程全部停掉，这对很多应用来说都是难以接受的。 &nbsp; &nbsp;&nbsp;&nbsp;收集算法：&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;采用复制算法 &nbsp; &nbsp;&nbsp;&nbsp;优点:&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。 &nbsp; &nbsp;&nbsp;&nbsp;缺点:&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;GC时暂停线程带给用户不良体验 &nbsp; &nbsp;&nbsp;&nbsp;搭配使用的收集器：&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;CMS 或Serial Old(MSC) &nbsp; &nbsp;&nbsp;2、ParNew收集器 &nbsp; &nbsp;&nbsp;&nbsp;ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为都与Serial收集器完全一样，实现上这两种收集器也共用了相当多的代码。 &nbsp; &nbsp;&nbsp;&nbsp;适用：&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;运行在Server模式下的虚拟机中的新生代。 &nbsp; &nbsp;&nbsp;&nbsp;特点:&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;1.多线程GC(并行):ParNew是Serial的多线程版本，两者共用了许多代码。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;2.在GC时暂停所有用户线程。 &nbsp; &nbsp;&nbsp;&nbsp;算法：&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;采用复制算法。 &nbsp; &nbsp;&nbsp;&nbsp;优点:&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;高效。 &nbsp; &nbsp;&nbsp;&nbsp;缺点:&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;GC时暂停线程带给用户不良体验,单线程下效果不一定优于Serial。 &nbsp; &nbsp;&nbsp;&nbsp;搭配使用的收集器：&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;CMS 或Serial Old(MSC)。 &nbsp;&nbsp;&nbsp;&nbsp;ParNew收集器有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。在JDK 1.5以后使用CMS来收集老年代的时候，新生代只能选择ParNew或Serial收集器中的一个。 &nbsp; &nbsp;&nbsp;3、Parallel Scavenge收集器 &nbsp; &nbsp;&nbsp;&nbsp;适用：&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;新生代收集器，在后台运算而不需要太多交互的任务。 &nbsp; &nbsp;&nbsp;&nbsp;特点:&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;1.多线程GC(并行)。&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;2.在GC时暂停所有用户线程。 &nbsp; &nbsp;&nbsp;&nbsp;算法：&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;采用复制算法 &nbsp; &nbsp;&nbsp;&nbsp;优点:&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;高效 &nbsp; &nbsp;&nbsp;&nbsp;搭配使用的收集器：&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;Parallel Old或Serial Old(MSC) &nbsp; &nbsp;&nbsp;&nbsp;与其他收集器的不同:&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;1.ParNew,CMS等收集器的关注点在于尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。【吞吐量：运行代码时间/（运行用户代码时间+垃圾收集时间）】 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;2.停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;3.Parallel Scavenge可采用GC自适应的调节策略(这是与另外两一个重要的区别）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相关参数设置，用于精确控制吞吐量：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:MaxGCPauseMillis &nbsp;&nbsp;&nbsp;&nbsp;最大垃圾收集停顿时间&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:GCTimeRatio &nbsp;&nbsp;&nbsp;&nbsp;垃圾收集时间与运行用户代码时间的比例=垃圾收集时间/运行用户代码时间,相当于是吞吐量的倒数。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;降低GC停顿时间：牺牲吞吐量和新生代空间(减小新生代空间，GC频率变大，吞吐量降低) &nbsp; &nbsp;&nbsp;&nbsp;GC自适应的调节策略:&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;-XX:+UseAdaptiveSizePolicy&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 使用自适应的调节策略 即不需要指定新生代的大小，Eden与Surivior的比例，晋升老年代的年龄等细节参数，虚拟机自动根据根据当前系统的状态动态调整这些参数以提供最合适的停顿时间或最大的吞吐量。 老年代收集器：&nbsp; &nbsp;&nbsp;&nbsp;1. Serial Old 收集器&nbsp; &nbsp;&nbsp;&nbsp;2. Parallel Old 收集器&nbsp; &nbsp;&nbsp;&nbsp;3. CMS 收集器 &nbsp; &nbsp;&nbsp;1. Serial Old 收集器 &nbsp;&nbsp;&nbsp;&nbsp;适用：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;1.运行在Client模式下的虚拟机中的老年代。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.在Server模式下，它主要还有两大用途。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;1).与Parallel Scavenge搭配。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;2).作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。 &nbsp; &nbsp;&nbsp;&nbsp;特点:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;1.单线程GC，Serial收集器的老年代版本。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;2.在GC时暂停所有用户线程。 &nbsp; &nbsp;&nbsp;&nbsp;算法：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;采用标记-整理算法 &nbsp; &nbsp;&nbsp;&nbsp;优点：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;简单，高效 &nbsp; &nbsp;&nbsp;&nbsp;缺点：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;GC时暂停线程带给用户不良体验 &nbsp; &nbsp;&nbsp;&nbsp;搭配使用的收集器：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;Serial Old(MSC)或ParNew &nbsp; &nbsp;&nbsp;2. Parallel Old 收集器 &nbsp;&nbsp;&nbsp;&nbsp;适用：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行在Server模式下，注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。 &nbsp;&nbsp;&nbsp;&nbsp;特点：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1).多线程GC(并行):Parallel Scavenge的老年代版本。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2).在GC时暂停所有用户线程。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3).这个收集器是在JDK 1.6中才开始提供。 &nbsp;&nbsp;&nbsp;&nbsp;算法：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用标记-整理算法 &nbsp;&nbsp;&nbsp;&nbsp;优点：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;高效 &nbsp;&nbsp;&nbsp;&nbsp;缺点：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GC时暂停线程带给用户不良体验,单线程下效果不一定优于Serial。 &nbsp;&nbsp;&nbsp;&nbsp;搭配使用的收集器：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parallel Scavenge &nbsp; &nbsp;&nbsp;3. CMS(Concurrent Mark Sweep) 收集器 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。 &nbsp;&nbsp;&nbsp;&nbsp;适用：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行在Server模式下的虚拟机中的老年代，适合对响应时间要求高的应用。 &nbsp;&nbsp;&nbsp;&nbsp;算法：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用“标记-清除”算法 &nbsp;&nbsp;&nbsp;&nbsp;特点:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多线程、与用户工作线程并发 &nbsp;&nbsp;&nbsp;&nbsp;过程:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.初始标记：暂停用户线程，标记GC Roots能直接关联的对象,速度很快。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.并发标记：用户线程与标记线程并发，进行GC Roots Tracing的过程。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.重新标记：为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.并发清除：用户线程与清除线程并发。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。 &nbsp;&nbsp;&nbsp;&nbsp;下图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间。 &nbsp;&nbsp;&nbsp;&nbsp;优点: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并发收集、低停顿，由于耗时最长的并发标记和并发清除阶段都与用户线程并行工作，故系统停顿时间极短。 &nbsp;&nbsp;&nbsp;&nbsp;缺点:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 对CPU资源非常敏感。 原因：面向并发设计的程序都对CPU资源比较敏感。并发时，因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低，应用程序会变慢，当CPU数不足时，尤其明显。 解决：增量式并发收集器（i-CMS）：在并发标记、清除时让GC线程与用户线程交替运行，以降低GC线程独占CPU的时间。当GC时间将变长时，效果一般，被丢弃使用。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 无法处理浮动垃圾,可能出现“Concurrent Mode “Failure”失败而导致另一次Full GC的产生。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;浮动垃圾：在并发清除阶段，用户线程仍在运行，此时产生的垃圾无法在该次收集中处理。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时由于要保证并发，就必须预留内存给用户线程使用，因此CMS无法等到老年代几乎完全填满时再进行收集。JDK 1.5中CMS默认当老年代被使用68%时被激发。1.6中为92%。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode “Failure”失败，这时虚拟机将启动后备预案：临时使用Serial Old收集器来重新进行老年代垃圾收集，这样停顿时间就会很长。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 产生空间碎片，影响大对象的分配。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于该收集器是由“标记-清除”算法实现的所引起的。所以往往存在有很大空间剩余，当无法找到足够大的连续空间来分配当前对象，不得不提前出发一次Full GC。 &nbsp;&nbsp;&nbsp;&nbsp;解决：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.-XX:+UseCMSCompactFullCollection 开关参数（默认开启）用于当CMS要进行Full GC时开启内存碎片的合并整理过程,该过程不能并发，故停顿==时间变长==。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.-XX:CMSFullGCsBeforeCompaction 用于设置执行多少次不压缩的Full GC后跟着来一次带压缩的Full GC。默认为0，表示每次进入Full GC时都进行碎片整理。 &nbsp;&nbsp;&nbsp;&nbsp;搭配使用的收集器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Serial或ParNew 新生代和老年代均适用集器：&nbsp; &nbsp;&nbsp;&nbsp;1. G1 收集器 &nbsp; &nbsp;&nbsp;1. G1 收集器(未来垃圾收集器的趋势，需好好了解) &nbsp;&nbsp;&nbsp;&nbsp;适用： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;面向服务端应用，适用于新生代和老年代。当前收集器技术发展的最前沿成果 &nbsp;&nbsp;&nbsp;&nbsp;内存布局：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G1的堆内存布局与其他收集器不同，G1将整个堆内存空间划分为多个大小相等的Region(2-32M 大小，可以参数指定)，虽然仍然有新生代和老年代的概念，但是新生代和老年代不再是物理隔离的，他们都是一部分Region（不需要连续）的集合。 &nbsp;&nbsp;&nbsp;&nbsp;特点:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.并行与并发，可充分利用CPU资源。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.分代收集。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.空间整合， G1从整体看是”标记-整理“算法，从局部(两个Region之间)看，是”复制“算法。 不会产生空间碎片。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.可预测的停顿，建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间内，消耗在垃圾收集的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。 &nbsp;&nbsp;&nbsp;&nbsp;Garbage First名称的由来： G1收集器可以实现在基本不牺牲吞吐量的前提下完成低停顿的内存回收，这是由于它能够极力地避免全区域的垃圾收集。G1将内存划分为Region，跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。 &nbsp;&nbsp;&nbsp;&nbsp;难点:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然内存分为Region，但垃圾收集不能真的以Region为单位进行，因为Region不可能是孤立的，存在某个对象被多个Region的引用，那在做可达性判断确定对象是否存活时，是否需要扫描整个堆空间呢？注意：此问题在所有的收集器中都存在（如存在新生代与老年代之间的引用）。 &nbsp;&nbsp;&nbsp;&nbsp;解决：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用Remembered Set来避免全堆扫描。 &nbsp;&nbsp;&nbsp;&nbsp;优化的Region扫描过程：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断操作，检查Reference类型引用的对象是否处于不同的Region（在分代的例子中就是检查是否老年代的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。 &nbsp;&nbsp;&nbsp;&nbsp;垃圾收集过程(与CMS相似)：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.初始标记:暂停用户线程，标记GC Roots能直接关联的对象。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.并发标记:用户线程与标记线程并发，进行GC Roots的Trace。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.最终标记修正并发标记阶段，因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.筛选回收:最后筛选回收阶段，首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，进而进行垃圾回收。 &nbsp;&nbsp;&nbsp;&nbsp;算法：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;全局标记-整理+局部复制算法 &nbsp;&nbsp;&nbsp;&nbsp;优点:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;高效，停顿时间可控、可预测]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM—垃圾收集算法]]></title>
    <url>%2F2018%2F09%2F02%2FJava%2Fjvm%2FJVM%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp; &nbsp;&nbsp;1、标记-清除算法(Mark-Sweep) &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;最基础的收集算法，之所以这么说，是因为下面的其它算法都是基于这种思路并对其不足进行改进而得到的。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;原理：分为标记-清除两个阶段&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.标记阶段：首先标记出所有需要回收的对象。&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.清除阶段：标记完成后，统一回收被标记的对象&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;缺点：&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.效率问题：标记和清除过程效率都不高。&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.空间问题：标记清除之后会产生大量的不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续的内存空间而不得不提前触发另一次垃圾收集动作。 &nbsp; &nbsp;&nbsp;2、复制算法(Copying) &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;为了解决上面所提到的标记清楚算法的效率问题，而出现了复制算法。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;原理：&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.将现有的内存空间分为两快，每次只使用其中一块。&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.当其中一块内存用完的时候，就将还存活的对象复制到另外一块上去。&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.再把已使用过的内存空间一次清理掉。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;优点：&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.由于是每次都对整个半区进行内存回收，内存分配时不必考虑内存碎片问题。&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;缺点：&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.内存减少为原来的一半，太浪费了。&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.对象存活率较高的时候就要执行较多的复制操作，效率变低。&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.如果不使用50%的对分策略，老年代需要考虑的空间担保策略。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;内存划分优化：&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存的划分并不需要根据1:1划分内存空间，而是将内存划分为一块较大的EdenSpace和两块较小的SurvivorSpace。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaHeap内存回收模型（当前商业虚拟机大多使用此算法回收新生代） &nbsp; &nbsp;&nbsp;3、标记整理算法(Mark-Compact) &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;由于复制算法的缺点，以及老年代的特点（存活率高，没有额外内存对其进行空间担保），老年代一般不使用复制算法。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;原理：&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.标记阶段：首先标记出所有需要回收的对象，与“标记-清除”一样。&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.让存活的对象向内存的一端移动。而不像“标记-清除”算法那样直接对可回收对象进行清理。&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.再直接清理掉端边界以外的内存。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;由于老年代存活率高，没有额外内存对老年代进行空间担保，那么老年代只能采用标记-清理算法或者标记整理算法。 &nbsp; &nbsp;&nbsp;4、分代收集算法(Generational Collecting) &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当前的商业虚拟机的垃圾收集都采用分代收集算法，把Java堆分为新生代和老年代。根据各个年代的特点采用最适当的收集算法。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，选用：复制算法 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清除”或者“标记-整理”算法来进行回收。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM—对象存活判定算法]]></title>
    <url>%2F2018%2F09%2F02%2FJava%2Fjvm%2FJVM%E2%80%94%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&nbsp; &nbsp;&nbsp;1、引用计数算法 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;引用计数算法就是对于创建的每一个对象都有一个与之关联的计数器，这个计数器记录着该对象被使用的次数，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器减1；任何时刻计数器都为0的对象就是不可能再被使用的，垃圾收集器在进行垃圾回收时，对扫描到的每一个对象判断一下计数器是否等于0，若等于0，就会释放该对象占用的内存空间,同时将该对象引用的其他对象的计数器进行减一操作。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;引用计数算法的垃圾收集一般有侵入式与非侵入式两种，侵入式的实现就是将引用计数器直接根植在对象内部，用C++的思想进行解释就是，在对象的构造或者拷贝构造中进行加一操作，在对象的析构中进行减一操作，非侵入式思想就是有一块单独的内存区域，用作引用计数器。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;算法的优点：引用计数算法的实现简单，判断效率也很高，使用引用计数器,内存回收可以穿插在程序的运行中，在程序运行中，当发现某一对象的引用计数器为0时，可以立即对该对象所占用的内存空间进行回收，这种方式可以避免FULL GC时带来的程序暂停。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;算法的缺点：采用引用计数器进行垃圾回收，最大的缺点就是不能解决循环引用的问题，例如一个象(A Object)持有另外一个对象(B Object)的引用，t同时B对象也持有A对象的引用，这种情况下，两个对象实例将一直存在于JVM的堆中，无法进行回收,代码示例如下(引用计数器无法对a与b对象进行回收): 12345678910111213141516171819202122232425262728class A &#123; private B b; public B getB() &#123; return b; &#125; public void setB(B b) &#123; this.b = b; &#125;&#125;class B &#123; private A a; public A getA() &#123; return a; &#125; public void setA(A a) &#123; this.a = a; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; A a = new A(); B b = new B(); a.setB(b); b.setA(a); &#125;&#125; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;Java语言中没有选用引用计数算法来管理内存，其中最主要的一个原因也是它很难解决对象之间相互循环引用的问题。123456789101112131415161718192021222324252627282930313233/*** 在testGC()方法中，对象objA和objB都有字段instance，* 赋值令objA.instance=objB及objB.instance=objA，* 除此之外这两个对象再无任何引用，* 实际上这两个对象都已经不能再被访问，* 但是它们因为相互引用着对象方，* 导致它们的引用计数都不为0，* 于是引用计数算法无法通知GC收集器回收它们。*/ /** * 执行后，objA和objB会不会被GC呢？ */public class ReferenceCountingGC &#123; public Object instance = null; private static final int _1MB = 1024 * 1024; /** * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过 */ private byte[] bigSize = new byte[2 * _1MB]; public static void testGC() &#123; ReferenceCountingGC objA = new ReferenceCountingGC(); ReferenceCountingGC objB = new ReferenceCountingGC(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; //假设在这行发生了GC，objA和ojbB是否被回收 System.gc(); &#125;&#125; 运行结果： [Full GC (System) [Tenured: 0K-&gt;210K(10240K), 0.0149142 secs] 4603K-&gt;210K(19456K), [Perm : 2999K-&gt;2999(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs] &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;从运行结果中可以看到GC日志中包含”4603K-&gt;210K”，这意味着虚拟机并没有因为这两个对象相互引用就不回收它们，这也证明虚拟并不是通过引用计数算法来判断对象是否存活的。 &nbsp; &nbsp;&nbsp;2、可达性分析算法 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;在主流的商用程序语言中(Java和C#)，都是使用可达性分析(Reachability Analysis)算法判断对象是否存活的。这个算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，下图对象object5, object6, object7虽然有互相判断，但它们到GC Roots是不可达的，所以它们将会判定为是可回收对象。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;在Java语言里，可作为GC Roots对象的包括如下几种：&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;1. 虚拟机栈(栈桢中的本地变量表)中的引用的对象&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;2. 方法区中的类静态属性引用的对象&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;3. 方法区中的常量引用的对象&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;4. 本地方法栈中JNI的引用的对象 &nbsp; &nbsp;&nbsp;对象生存还是死亡&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;两次对对象进行标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。 &nbsp; &nbsp;&nbsp;&nbsp;1).第一次标记并进行一次筛选。&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;筛选的条件是此对象是否有必要执行finalize()方法。&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;当对象没有覆盖finalize方法，或者finzlize方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，对象被回收。 &nbsp; &nbsp;&nbsp;&nbsp;2).第二次标记&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象finalize()方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;finalize()方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己(this 关键字)赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。不过要尽量避免使用finalize这个方法。 流程图如下： 代码： 12345678910111213141516171819202122232425262728293031323334353637383940/** * 此代码演示了两点 * 1、对象可以在被GC时自我拯救 * 2、这种自救的机会只有一次，因为一个对象的finalize()方法最多只能被系统自动调用一次。 */public class FinalizeEscapeGC &#123; public static FinalizeEscapeGC SAVE_HOOK = null; public void isAlive() &#123; System.out.println(&quot;yes, I am still alive&quot;); &#125; protected void finalize() throws Throwable &#123; super.finalize(); System.out.println(&quot;finalize method executed!&quot;); FinalizeEscapeGC.SAVE_HOOK = this; &#125; public static void main(String[] args) throws InterruptedException &#123; SAVE_HOOK = new FinalizeEscapeGC(); //对象第一次成功拯救自己 SAVE_HOOK = null; System.gc(); //因为finalize方法优先级很低，所有暂停0.5秒以等待它 Thread.sleep(500); if (SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125; else &#123; System.out.println(&quot;no ,I am dead!&quot;); &#125; //----------------------- //以上代码与上面的完全相同,但这次自救却失败了！！！ SAVE_HOOK = null; System.gc(); //因为finalize方法优先级很低，所有暂停0.5秒以等待它 Thread.sleep(500); if (SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125; else &#123; System.out.println(&quot;no ,I am dead!&quot;); &#125; &#125;&#125; 运行结果：finalize method executed!yew, I am still aliveno ,I am dead! &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;从结果可以看出，SAVE_HOOK对象的finalize()方法确实被GC收集器触发过，并且在被收集前成功逃脱了。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;另外一个值得注意的地方是，代码中两段完全一样的代码，执行结果却是一次逃脱成功，一次失败，这是因为任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。不建议自己重写finalize()方法，尽量避免使用。 &nbsp; &nbsp;&nbsp;3、引用 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在JDK 1.2之前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，这四种引用强度依次逐渐减弱。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;强引用：就是指在程序代码之中普遍存在的，类似Object obj = new Object()这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;软引用：用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;弱引用：也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;虚引用：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Blog]]></title>
    <url>%2F2018%2F09%2F02%2FHexo%2Fhexo_blog%2F</url>
    <content type="text"><![CDATA[前言 备忘通过Hexo实现从md文件生成静态页面，然后发布到GitHub Pages的过程。 主要流程1、安装必须的软件 安装Git Git官方版本的安装 安装Node.js Node.js官方版本的安装 安装Hexo 常规安装命令$ npm install -g hexo-cli 常规命令有可能被“墙”，安装hexo为了避免出现类似情况，我使用淘宝NPM镜像,输入以下命令等待安装完成。$ npm install -g cnpm –registry=https://registry.npm.taobao.org 使用淘宝NPM安装Hexo。$ cnpm install -g hexo-cli （与原先的npm完全一样，只是命令改为cnpm,一样等待hexo安装完成），出现的WARN可以不用理会，继续输入以下命令：$ cnpm install hexo –save 2、验证软件正确安装 git –version 检验git是否安装成功，显示出git的具体版本 node -v 检验node是否安装成功，显示出node的具体版本 npm -v 检验npm是否安装成功，显示出npm的具体版本 hexo -v 检验hexo是否安装成功，显示出hexo的具体版本 3、 使用Hexo建站 安装完后，创建文件夹（例如D：\Hexo），在文件夹内点击鼠标右键选择Git bash，输入以下指令： $ hexo init 该命令会在目标文件夹内建立网站所需要的所有文件。 接下来是安装依赖包： $ npm install 或者 $ cnpm install 搭建起本地的Hexo博客 本地运行博客只要输入该命令 $ hexo generate 和 $ hexo server 或者 $ hexo s -g 启动本地博客，打开浏览器，输入localhost:4000,就可以在本地看到你的个人博客了 4、 一般的搭建方法 在上面，我们已经配置好了所需的所有东西，也成功地搭建了一个本地Hexo博客。现在，需要使用GitHub Pages搭建一个别人能够访问的Hexo博客。 4.1 使用默认theme 我们继续使用上面的文件夹D:\Hexo（也可以新建一个文件夹重新生成），然后编辑该文件夹下的_config.yml。 默认生成的_config.yml：1234# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: 修改后的_config.yml：1234deploy: type: git repo: 对应仓库的SSH地址（可以在GitHub对应的仓库中复制） branch: 分支（User Pages为master，Project Pages为gh-pages） 为了能够使Hexo部署到GitHub上，需要安装一个插件：1$ npm install hexo-deployer-git --save 或者 $ cnpm install hexo-deployer-git --save 执行下列指令即可完成部署：1234$ hexo generate$ hexo deploy或者$ hexo d -g 之后，可以通过在浏览器键入：username.github.io进行浏览。 4.2 简介 blog/_config.yml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#博客名称title: 我的博客#副标题subtitle: 一天进步一点#简介description: 记录生活点滴#博客作者author: John Doe#博客语言language: zh-CN#时区timezone:#博客地址,与申请的GitHub一致url: http://elfwalk.github.ioroot: /#博客链接格式permalink: :year/:month/:day/:title/permalink_defaults:source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: true tab_replace:default_category: uncategorizedcategory_map:tag_map:#日期格式date_format: YYYY-MM-DDtime_format: HH:mm:ss#分页，每页文章数量per_page: 10pagination_dir: page#博客主题theme: landscape#发布设置deploy: type: git #elfwalk改为你的github用户名 repository: https://github.com/elfwalk/elfwalk.github.io.git branch: master 5、优化部署与管理(☆☆☆) Hexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，就不可能了（除非你自己写html）。 其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。 但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库(）。 所以，利用了分支！！！简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。 5.1 搭建流程1. 创建仓库，username.github.io； 2. 创建两个分支：master 与 hexo； 3. 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）； 4. 使用git clone git@github.com:username/username.github.io.git拷贝仓库； 5. 在本地username.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）; 6. 修改_config.yml中的deploy参数，分支应为master； 7. 依次执行git add .; git commit -m &quot;…&quot;; git push origin hexo提交网站相关的文件； 8. 执行hexo generate -d生成网站并部署到GitHub上。 这样一来，在GitHub上的username.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。 5.3 管理流程5.3.1 日常修改 1. 在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理： 2. 依次执行git add .git; commit -m &quot;…&quot;; git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）； 3. 然后才执行hexo generate -d发布网站到master分支上。 5.3.２本地资料丢失当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： 1. 使用git clone git@github.com:username/username.github.io.git拷贝仓库（默认分支为hexo）； 2. 在本地新拷贝的username.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Work Begin]]></title>
    <url>%2F2018%2F04%2F07%2FWorkBegin%2F</url>
    <content type="text"><![CDATA[Work BeginWork hard and start recording your knowledge every day. Don’t forget to improve your professional knowledge in your work.Need Work…]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[225. Implement Stack using Queues]]></title>
    <url>%2F2017%2F08%2F31%2F225-Implement-Stack-using-Queues%2F</url>
    <content type="text"><![CDATA[Implement the following operations of a stack using queues. push(x) –Push element x onto stack.pop() –Removes the element on top of the stack.top() –Get the top element.empty() –Return whether the stack is empty. Notes:You must use only standard operations of a queue – which means only push to back, peek / pop from front, size, and is empty operations are valid.Depending on your language, queue may not be supported natively.You may simulate a queue by using a list or deque(double - ended queue), as long as you use only standard operations of a queue.You may assume that all operations are valid(for example, no pop or top operations will be called on an empty stack). 题意： 使用队列实现堆栈的push(x) ，pop()，top()，empty()操作。 只能使用一个队列的标准操作 - 这意味着只能从前面，后面，peek / pop从前面，大小，并且是空的操作是有效的。根据您的语言，队列可能不被本机支持。您可以使用列表或deque（双端队列）来模拟队列，只要您仅使用队列的标准操作即可。可以假设所有操作都有效（例如，在空堆栈上不会调用pop或top操作）。 思路： 方法一： 用两个队列模拟一个堆栈： 12345678队列a和b （1）取栈顶元素： 返回有元素的队列的首元素 （2）判栈空：若队列a和b均为空则栈空 （3）入栈：a队列当前有元素，b为空（倒过来也一样）则将需要入栈的元素先放b中，然后将a中的元素依次出队列并入列倒b中。（保证有一个队列是空的） （4）出栈：将有元素的队列出列即可。比如先将1插入队a中 ，现在要将2入栈，则将2插入b中然后将a中的1出列入到b中，b中的元素变为 2 ，1a为空，现在要压入3 则将3插入a中 ，依次将b中的2 ，1 出列并加入倒a中 ，a中的元素变为 3，2，1 b为空注意：算法保证在任何时候都有一队列为空 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Stack &#123; queue&lt;int&gt; q1; queue&lt;int&gt; q2;public: // Push element x onto stack. void push(int x) &#123; if (q1.empty()) &#123; q1.push(x); while (!q2.empty()) &#123; int temp = q2.front(); q2.pop(); q1.push(temp); &#125; &#125; else &#123; q2.push(x); while (!q1.empty()) &#123; int temp = q1.front(); q1.pop(); q2.push(temp); &#125; &#125; &#125; // Removes the element on top of the stack. void pop() &#123; if (!q1.empty()) q1.pop(); if (!q2.empty()) q2.pop(); &#125; // Get the top element. int top() &#123; if (!q1.empty()) return q1.front(); if (!q2.empty()) return q2.front(); &#125; // Return whether the stack is empty. bool empty() &#123; return q1.empty()&amp;&amp;q2.empty(); &#125;&#125;; 方法二： 利用双端队列，实现代码简单，但是不懂原理，效率低，真正要学习的是两个队列实现栈，以及两个栈实现队列。 1234567891011121314151617181920212223class Stack &#123; deque&lt;int&gt; res;public: // Push element x onto stack. void push(int x) &#123; res.push_back(x); &#125; // Removes the element on top of the stack. void pop() &#123; res.pop_back(); &#125; // Get the top element. int top() &#123; return res.back(); &#125; // Return whether the stack is empty. bool empty() &#123; return res.empty(); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[224. Basic Calculator]]></title>
    <url>%2F2017%2F08%2F31%2F224-Basic-Calculator%2F</url>
    <content type="text"><![CDATA[Implement a basic calculator to evaluate a simple expression string.he expression string may contain open(and closing parentheses), the plus + or minus sign - , non - negative integers and empty spaces . You may assume that the given expression is always valid.Some examples :“1 + 1” = 2“ 2-1 + 2 “ = 3“(1+(4+5+2)-3)+(6+8)” = 23 题意： 实现基本的计算器来计算一个简单的表达式字符串，表达式字符串可能包含打开“（”和闭括号“）”，加号或减号，非负整数和空格。 思路： 方法一： 两个要点： 1、无括号时，顺序执行 2、有括号时，先执行括号中的 两个栈： 一个存放操作数，每次进栈要注意，如果操作符栈顶元素为’+’/‘-‘，则需要立即计算。 一个存放操作符（包括括号），每次出现’)’时，不断进行出栈计算再进栈，直到弹出’(‘，说明当前括号内计算完毕。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Solution &#123;public: int calculate(string s) &#123; stack&lt;int&gt; num;//存放操作数 stack&lt;int&gt; op;//存放操作符 int i = 0; while (i &lt; s.size()) &#123; while (i &lt; s.size() &amp;&amp; s[i] == ' ')//跳过字符串中的空格字符 i++; if (i == s.size()) break; if (s[i] == '+' || s[i] == '-' || s[i] == '(') &#123; op.push(s[i]); i++; &#125; else if (s[i] == ')') &#123; while (op.top() != '(') &#123;// calculation within parentheses int n2 = num.top(); num.pop(); int n1 = num.top(); num.pop(); if (op.top() == '+') num.push(n1 + n2); else num.push(n1 - n2); op.pop(); &#125; op.pop(); while (!op.empty() &amp;&amp; op.top() != '(') &#123; int n2 = num.top(); num.pop(); int n1 = num.top(); num.pop(); if (op.top() == '+') num.push(n1 + n2); else num.push(n1 - n2); op.pop(); &#125; i++; &#125; else &#123; int n = 0; while (i &lt; s.size() &amp;&amp; s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') &#123; n = n * 10 + (s[i] - '0'); i++; &#125; num.push(n); while (!op.empty() &amp;&amp; op.top() != '(') &#123; int n2 = num.top(); num.pop(); int n1 = num.top(); num.pop(); if (op.top() == '+') num.push(n1 + n2); else num.push(n1 - n2); op.pop(); &#125; &#125; &#125; return num.top(); &#125;&#125;; 方法二： 由于表达式中只含有括号和加减法运算，我们可以通过加减法的规律对表达式进行化简，，因为只有加减，去括号的话只会影响括号内部的符号变换，表达式都是从左到右依次执行的，然后求值。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int calculate(string s) &#123; stack&lt;int&gt; num; num.push(1); char op = '+'; long re = 0; for (int i = 0; i &lt; s.length(); i++) &#123; switch (s[i]) &#123; case ' ': break; case '+': case '-': op = s[i]; break; case '(': num.push(num.top() * (op == '-' ? -1 : 1)); op = '+'; break; case ')': num.pop(); break; default: int tmp = 0; while (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') &#123; tmp = tmp * 10 + s[i] - '0'; i++; &#125; i--; re += (op == '-' ? -1 : 1)*num.top()*tmp; &#125; &#125; return re; &#125;&#125;; 方法三： 通用性代码，可以包含乘除，加括号等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121class Solution &#123;public: int calculates5(string s) &#123; if (s.empty()) &#123; return 0; &#125; //1、把表达式去掉空格存到队列中 queue&lt;string&gt; que;//存放表达式序列 for (int i=0;i&lt;s.size();) &#123; string str = ""; switch (s[i]) &#123; case ' ': i++; break; case '+': case '-': case '(': case ')': str = s[i]; que.push(str); i++; break; default: while (i&lt;s.size()&amp;&amp;s[i]&gt;='0'&amp;&amp;s[i]&lt;='9') &#123; str += s[i]; i++; &#125; que.push(str); break; &#125; &#125; //2、把中缀表达式转换为后缀表达式 stack&lt;string&gt; stackA; stack&lt;string&gt; stackB; while (!que.empty()) &#123; string temp = que.front(); que.pop(); char op = temp.at(0); if (op=='(') &#123; stackB.push(temp); &#125; else if (op==')') &#123; while (!stackB.empty() &amp;&amp; stackB.top() != "(") &#123; stackA.push(stackB.top()); stackB.pop(); &#125; if (!stackB.empty()) &#123; stackB.pop(); &#125; &#125; else if (op=='+' || op =='-') &#123; if (stackB.empty() || stackB.top()=="(") &#123; stackB.push(temp); &#125; else &#123; while (!stackB.empty()&amp;&amp;stackB.top()!="(") &#123; stackA.push(stackB.top()); stackB.pop(); &#125; stackB.push(temp); &#125; &#125; else &#123; stackA.push(temp); &#125; &#125; while (!stackB.empty()) &#123; stackA.push(stackB.top()); stackB.pop(); &#125; while (!stackA.empty()) &#123; stackB.push(stackA.top()); stackA.pop(); &#125; //3、通过后缀表达式进行计算 stack&lt;int&gt; result; while (!stackB.empty()) &#123; int res = 0; string temp = stackB.top(); stackB.pop(); char op = temp.at(0); switch (op) &#123; case '+': res = result.top(); result.pop(); res += result.top(); result.pop(); result.push(res); break; case '-': res = result.top(); result.pop(); res = result.top() - res; result.pop(); result.push(res); break; default: result.push(atoi(temp.c_str())); break; &#125; &#125; return result.top(); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[222. Count Complete Tree Nodes]]></title>
    <url>%2F2017%2F08%2F31%2F222-Count-Complete-Tree-Nodes%2F</url>
    <content type="text"><![CDATA[Given a complete binary tree, count the number of nodes. 题意： 给定一棵完全二叉树，求树种节点的个数。 思路： 如果用常规的解法一个个遍历，就是O(n)时间复杂度 ，不通过。因为是完全二叉树，满二叉树有一个性质是节点数等于2^h-1，h为高度，所以可以这样判断节点的左右高度是不是一样，如果是一样说明是满二叉树，就可以用刚才的公式，如果左右不相等就递归计算左右节点。 方法一： 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。根据完全二叉树的这个性质，可以这样来求解完全二叉树中节点的个数。对于一个节点node，计算它最左端的节点到node的深度为leftDepth，计算它最右端的节点到node的深度是rightDepth；如果leftDepth和rightDepth相等，那么以node为根节点的树是一棵满二叉树，此时以node为根节点的树的节点个数是pow(2,leftDepth)-1；如果leftDepth和rightDepth不相等，递归求解node的左子树的节点数和右子树的节点数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: int depthLeft(TreeNode* root) &#123; if (!root) &#123; return 0; &#125; int height = 0; while (root) &#123; root = root-&gt;left; height++; &#125; return height; &#125; int depthRight(TreeNode* root) &#123; if (!root) &#123; return 0; &#125; int height = 0; while (root) &#123; root = root-&gt;right; height++; &#125; return height; &#125; int countNodes(TreeNode* root) &#123; if (!root) &#123; return 0; &#125; int ld = depthLeft(root); int rd = depthRight(root); if (ld == rd) &#123; int lnum = pow(2,ld) - 1; return lnum; &#125; return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1;//最后加一加的是根节点 &#125;&#125;; 方法二： 也是比较左右子树的高度是否相等，如果左子树等于右子树的高度（都按左子树计算高度，因为完全二叉树的高度由左子树的高度确定的）则左子树肯定是完全二叉树，右子树再递归判读，如果左子树不等于右子树高度，右子树肯定是完全二叉树，左子树再递归判断。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int depth(TreeNode* root) &#123; if (!root) &#123; return 0; &#125; int height = 0; while (root) &#123; root = root-&gt;left; height++; &#125; return height; &#125; int countNodes(TreeNode* root) &#123; if (!root) &#123; return 0; &#125; int ld = depth(root-&gt;left); int rd = depth(root-&gt;right); if (ld==rd) &#123; return pow(2, ld) + countNodes(root-&gt;right); /* int lnum = (2 &lt;&lt; (ld - 1)) + countNodes(root-&gt;left);//当层数是0的时候左移公式出现问题 return lnum;*/ &#125; return pow(2, rd) + countNodes(root-&gt;left); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[219. Contains Duplicate II]]></title>
    <url>%2F2017%2F08%2F30%2F219-Contains-Duplicate-II%2F</url>
    <content type="text"><![CDATA[Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the arraysuch that nums[i] = nums[j] and the difference between i and j is at most k. 题意： 给定整数数组和整数k，找出数组中是否有两个不同的索引i和j，使得nums [i] = nums [j]，i和j之间的差最多为k。 思路： 利用hash表，key为元素值，value为此元素所对应的索引的集合，遍历元素组，把相同元素的索引都放入到对应hash表的value集合中，然后遍历hash表，找出集合大小大于1的value集合，遍历此集合，求出相同元素索引间最小距离。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123; if (nums.empty()) &#123; return false; &#125; map&lt;int, vector&lt;int&gt;&gt; hash; for (int i = 0; i &lt; nums.size(); i++) &#123; hash[nums[i]].push_back(i); &#125; for (auto itr = hash.begin();itr!=hash.end();itr++) &#123; if (itr-&gt;second.size()&gt;1) &#123; int minIndex = INT_MAX; for (int j = 1; j &lt; itr-&gt;second.size(); j++) &#123; int m = j - 1; minIndex = min(minIndex, itr-&gt;second[j] - itr-&gt;second[m]); &#125; if (minIndex&lt;=k) &#123; return true; &#125; &#125; &#125; return false; &#125;&#125;; 方法二： 思路同方法一，利用hash表，不同点是一边遍历数组，一边在hash表对应的索引值进行相减比较。 12345678910111213141516171819202122232425class Solution &#123;public: bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123; if (nums.empty()) &#123; return false; &#125; map&lt;int, int&gt; hash; for (int i = 0; i &lt; nums.size(); i++) &#123; auto itr = hash.find(nums[i]); if (itr != hash.end()) &#123; if (i - itr-&gt;second &lt;= k) &#123; return true; &#125; else hash.erase(itr); &#125; hash[nums[i]] = i; &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[216. Combination Sum III]]></title>
    <url>%2F2017%2F08%2F30%2F216-Combination-Sum-III%2F</url>
    <content type="text"><![CDATA[Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Example 1:Input: k = 3, n = 7Output:[[1,2,4]] Example 2:Input: k = 3, n = 9Output:[[1,2,6], [1,3,5], [2,3,4]] 题意： 找到所有可能的k个数字的组合，其总和为n，因为只能使用从1到9的数字，并且每个组合应该是唯一的数字集合。 思路： 典型的递归回溯题，需要找出所有的k个数的和等于n的组合，所以要求出所有情况，并且组合中没有重复元素，结果集中k个数的集合也是唯一的。 1234567891011121314151617181920212223242526272829class Solution &#123; vector&lt;vector&lt;int&gt;&gt; res;//存放k个数的所有组合public: vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; vector&lt;int&gt; sumNum; backtracking(n, k, 1,sumNum); return res; &#125; void backtracking(int target, int counts, int index, vector&lt;int&gt; sumNum) &#123; if (target==0) &#123; if (counts==0)//满足这两个if条件才能放入结果集 &#123; res.push_back(sumNum); return; &#125; &#125; else &#123; for (int i = index; i &lt; 10; i++)//i是1到9，所以直接设定上界为10 &#123; sumNum.push_back(i); backtracking(target-i, counts-1,i + 1, sumNum);//因为子数组不存在重复元素，所以index递增1 sumNum.pop_back();//递归回溯把之前进入子数组集的元素弹出 &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[215. Kth Largest Element in an Array]]></title>
    <url>%2F2017%2F08%2F30%2F215-Kth-Largest-Element-in-an-Array%2F</url>
    <content type="text"><![CDATA[Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. For example,Given [3,2,1,5,6,4] and k = 2, return 5. Note:You may assume k is always valid, 1 ≤ k ≤ array’s length. 题意： 查找未排序数组中的第k个最大元素。 请注意，它是排序顺序中的第k个最大元素，而不是第k个不同的元素。 思路： 题意要理解：第k大的元素时从最大边开始数起，最大的为第一大，次大的为第二大。。。。 378题的第k小的元素时从最小边开始数起，最小的为第一小，次小的为第二小。。。 方法一： 利用优先队列做，也就是建立最小堆（或者最大堆）来求第k大的元素。priority_queue容器详解 。 123456789101112131415161718192021222324252627282930class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int res = 0; //最小堆的实现 //priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; queMin;//functional //for (auto n : nums) //&#123; // queMin.push(n); // if (queMin.size()&gt;k) // &#123; // queMin.pop(); // &#125; //&#125; //return queMin.top(); //最大堆的实现 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; queMax;//== priority_queue&lt;int&gt; queMax 默认构建最大堆 for (auto n : nums) &#123; queMax.push(n); &#125; while (k&gt;1) &#123; queMax.pop(); k--; &#125; return queMax.top(); &#125;&#125;; 方法二： 直接利用c++的STL库nth_element。nth_element函数详解 。 1234567class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; nth_element(nums.begin(), nums.begin() + k, nums.end()); return *(nums.begin() + k); &#125;&#125;; 方法三： 利用QuickSelect的方法实现方法二的查找第k个元素的方法，快速查找的思想和快排相同，快排具体详解见快排实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; quickSelect(nums, 0, nums.size() - 1, nums.size()-k);//因为下面排序是从小到大，所以找nums.size()-k处元素 return nums[nums.size()-k]; &#125; int getPartition(vector&lt;int&gt;&amp; nums, int low, int height) &#123; int keyVal = nums[height]; int i = low - 1; while (low&lt;height) &#123; if (nums[low]&lt;keyVal) &#123; i = i + 1; swap(nums[i], nums[low]); &#125; low++; &#125; swap(nums[i + 1], nums[height]); return i + 1; &#125; bool quickSelect(vector&lt;int&gt;&amp; nums,int low,int height, int k) &#123; if (k&lt;low||k&gt;height) &#123; return false; &#125; //三元区中项的思想优化快选中项 int mid = (low + height) / 2; if (nums[low]&gt;nums[height]) &#123; swap(nums[low], nums[height]); &#125; if (nums[mid]&gt;nums[height]) &#123; swap(nums[mid], nums[height]); &#125; if (nums[low] &gt; nums[mid]) &#123; swap(nums[mid], nums[low]); &#125; swap(nums[mid], nums[height]); int par = getPartition(nums, low, height); if (k==par) &#123; return true; &#125; if (k &lt; par) &#123; quickSelect(nums, low, par-1, k); &#125; else quickSelect(nums, par+1, height, k); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[214. Shortest Palindrome]]></title>
    <url>%2F2017%2F08%2F29%2F214-Shortest-Palindrome%2F</url>
    <content type="text"><![CDATA[Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation. For example:Given “aacecaaa”, return “aaacecaaa”.Given “abcd”, return “dcbabcd”. 题意： 给定一个字符串，在字符串的前面添加字符将它转换成一个回文串。找到并返回可以通过执行这个变化后转换的最短回文串。 思路： 方法一： 在s前面添加字符串出现最短的回文串，就是找到距离第一个元素最近的对称点，左侧形成对称的话，如果右侧还有元素存在，只需反转加到s的前面即可。 其中更加注意的一点就是：对称的对称轴元素可能为一个，也可能为两个。 从某个char开始向两边扩展(左右两边的字符相等), 如果能一直扩展到字符串的头部, 则将末尾余下的reverse,再加到原字符串的头部。 中轴字符选从中间开始,这样找到的即为最短的. 中轴字符可能为一个, 也可能为两个. 123456789101112131415161718192021222324252627282930313233343536373839404142434445//此法效率不是很高class Solution &#123;public: string shortestPalindrome(string s) &#123; int sLen = s.size(); if (sLen &lt;= 1) return s; string res = ""; int center = sLen / 2; for (int i = center; i &gt;= 0; i--)//从中间往左边查找对称点 &#123; if (s[i]==s[i+1]) &#123; res = isPalindrome(s, i, i+1);//偶数的情况 if (res!="#") &#123; return res; &#125; &#125; //else//切记此处不是else，也就是说，可能即使s[i]==s[i+1]的情况也会出现奇数个的情况,例如：aaaaa //&#123; res = isPalindrome(s, i, i);//奇数的情况 if (res != "#") &#123; return res; &#125; //&#125; &#125; return res; &#125; string isPalindrome(string s, int l, int r) &#123; int i = 1;//i表示从中间元素向两边扩展的距离 for (; l - i &gt;= 0 &amp;&amp; r + i &lt; s.length(); i++) &#123; if (s[l - i] != s[r + i]) break; &#125; if (l - i &gt;= 0)//说明不是最靠近左侧的对称点，返回#标识 return "#"; string tempStr = s.substr(r + i); reverse(tempStr.begin(), tempStr.end()); s = tempStr + s; return s; &#125;&#125;; 方法二： 下面的算法主要依据KMP算法，实现主串和模式串的匹配，其中主串是s的反转串，模式串是s。用kmp字符串匹配算法就可以完美地完成O(n)复杂度的算法。只需对kmp做一点点调整： 判断匹配结束的时机：是reverse_s串匹配到了尾部，且匹配成功。 用mark记录匹配到结尾时s串的下标位置：为了从s串尾部截取子串接到reverse_s后形成回文字符串。 如何保证最短：由于第一次成功匹配到reverse_s尾部后就结束循环，此时的mark标记的位置所形成的回文段（字符串s从0到mark下标所形成的子串）应该是最长的。 使用c++自带stl函数：reverse操作，substr操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123;public: string shortestPalindrome(string s) &#123; int sLen = s.size(); if (sLen &lt;= 1) return s; string res = ""; string reverse_s(s); reverse(reverse_s.begin(), reverse_s.end()); vector&lt;int&gt; next(sLen, 0); getNext(s, next); int i = 0, j = 0,mark = 0; while (i&lt;sLen&amp;&amp;j&lt;sLen) &#123; if (j == -1|| reverse_s[i] == s[j]) &#123; i++; j++; if (i == sLen) &#123; mark = j; break; &#125; &#125; else &#123; j = next[j]; &#125; &#125; res = mark == sLen ? s : reverse_s + s.substr(mark); return res; &#125; //求模式串的next数组的方法 void getNext(string s, vector&lt;int&gt; &amp;next) &#123; int sLen = s.size(); int k = -1; int j = 0; next[0] = -1; while (j&lt;sLen-1) &#123; if (k == -1 || s[k] == s[j]) &#123; k++; j++; if (s[k] == s[j]) &#123; next[j] = next[k]; &#125; else next[j] = k; &#125; else k = next[k]; &#125; &#125;&#125;; 方法三： 思路：让在前面补一些字符使得给定的字符串变成回文，观察可以发现我们需要添加多少个字符与给定字符串的前缀子串回文的长度有关．也就是说去掉其前缀的回文子串，我们只需要补充剩下的子串的逆序就行了。 举个例子： aacecaaa，其前缀的最大回文子串是aacecaa，剩下了一个a，因此我们只需要在前面加上一个a的逆序a就行了．再例如abcd，其前缀的最大回文是a，因此剩下的子串就为bcd，所以需要在前面加上bcd的逆序，就变成了dcbabcd．所以这样问题就转化为求字符串的前缀最大回文长度． 一个naive的方法是先判断整个字符串是否回文，否的话再判断前n-1个子串是否回文，这样依次缩减长度，直到找到一个回文子串就是最大的前缀回文子串．这种方法简单粗暴，容易理解和实现，如果在面试中要求不是很严格的情况下说不定可以过关, 反正总比不会好点^.^．其时间复杂度是O(n!)． KMP，这是一个非常高效的字符串比较算法．其原理是给定一个字符串S和P，要在S中寻找是否存在P，一般的方法是逐位比较，如果不能完全匹配，则S再回到开始位置向右移动一位，P回到0位置再开始比较．在KMP中不需要回到首部重新开始比较，借助与记录从P的开头到当前位置P中的前缀和后缀有多少位是相等的，这样当P和S比较的时候如果P[i] != S[j]了，不需要回到P[0]的位置重新比较，我们可以查看P中已经匹配过的子串中（也就是P[0, i-1]子串）前缀和后缀有多少位是相等的，然后将P的前缀和已经S[j]之前的后缀是匹配的，就可以不用回溯S了．所以借助与KMP记录最长前缀和后缀的方法，我们可以将原字符串翻转以后加在原字符串的后面，其最大的前缀和后缀就是前缀的最大回文长度．我们还需要在这两个字符串之间加一个冗余字符，因为形如aaaaa这种字符串如果不加一个冗余字符最大前缀和后缀会变大． 12345678910111213141516171819202122232425//效率高，但是不太理解class Solution &#123;public: string shortestPalindrome(string s) &#123; int sLen = s.size(); if (sLen &lt;= 1) return s; string res = ""; string reverse_s(s); reverse(reverse_s.begin(), reverse_s.end()); string str = s + "#" + reverse_s; int strLen = str.size(); vector&lt;int&gt; maxPalindromeVec(strLen, 0); for (int i =1;i&lt;strLen;i++) &#123; int k = maxPalindromeVec[i - 1]; while (k&gt;0&amp;&amp;str[k]!=str[i]) &#123; k = maxPalindromeVec[k - 1]; &#125; maxPalindromeVec[i] = (k += str[k] == str[i]); &#125; return str.substr(sLen + 1, sLen - maxPalindromeVec[strLen - 1]) + s; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[209. Minimum Size Subarray Sum]]></title>
    <url>%2F2017%2F08%2F28%2F209-Minimum-Size-Subarray-Sum%2F</url>
    <content type="text"><![CDATA[Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. For example, given the array [2,3,1,2,4,3] and s = 7,the subarray [4,3] has the minimal length under the problem constraint. 题意： 给定含有n个正整数的数组和一个正整数，求最小长度的子数组，使子数组的和sum ≥ s，如果不存在这样的子数组，返回0。 思路： 方法一： 利用滑动窗口机制，用两个指针来维持和的最大值，然后求最小子数组长度。pre和last指针之间维持着大于s的和的子数组，通过减小和扩大滑动窗口大小，来实现查找对小的和大于s的子数组，时间复杂度是O(n)。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int res = 0; int len = nums.size(); if (len==0) &#123; return res; &#125; int pre = 0, last = 0; int minLen = INT_MAX; int sum = nums[pre]; while (pre&lt;len) &#123; if (sum&lt;s) &#123; if (pre == len-1) &#123; break; &#125; pre++;//移动滑动窗口前指针 sum += nums[pre]; &#125; else &#123; int dis = pre - last + 1; minLen = min(minLen, dis); sum -= nums[last]; last++;//移动滑动窗口后指针 &#125; &#125; return minLen==INT_MAX?res:minLen; &#125;&#125;; 方法二： 时间复杂度是O(nlogn)的算法。 12345Now let&apos;s move on to the O(nlogn) solution. Well, this less efficient solution is far more difficult to come up with. The idea is to first maintain an array of accumulated summations of elements in nums. Specifically, for nums = [2, 3, 1, 2, 4, 3] in the problem statement, sums = [0, 2, 5, 6, 8, 12, 15]. Then for each element in sums, if it is not less than s, we search for the first element that is greater than sums[i] - s (in fact, this is just what the upper_bound function does) in sums using binary search.Let&apos;s do an example. Suppose we reach 12 in sums, which is greater than s = 7. We then search for the first element in sums that is greater than sums[i] - s = 12 - 7 = 5 and we find 6. Then we know that the elements in nums that correspond to 6, 8, 12 sum to a number 12 - 5 = 7 which is not less than s = 7. Let&apos;s check for that: 6 in sums corresponds to 1 in nums, 8 in sums corresponds to 2 in nums, 12 in sums corresponds to 4 in nums. 1, 2, 4 sum to 7, which is 12 in sums minus 5 in sums.We add a 0 in the first position of sums to account for cases like nums = [3], s = 3. 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int res = 0; int len = nums.size(); if (len == 0) &#123; return res; &#125; int minLen = INT_MAX; vector&lt;int&gt; sumNum(len + 1, 0); for (int i = 0; i &lt; len; i++) &#123; sumNum[i + 1] = sumNum[i] + nums[i]; &#125; for (int i = 0; i &lt; len; i++) &#123; int l = i + 1; int r = len; int target = sumNum[i] + s; if (target &gt; sumNum[r]) break; if (target &lt; sumNum[l]) return 1; while (l &lt; r) &#123; int mid = (l + r) / 2; if (sumNum[mid] &lt; target) l = mid + 1;//特别注意此处，当sumNum[mid] == target的时候坚决不能让mid+1，否则会造成元素多1个，只要大于等于target的时候一定躺r=mid,不要移动l else r = mid; &#125; minLen = min(minLen, l - i); &#125; return minLen == INT_MAX ? res : minLen; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[206. Reverse Linked List]]></title>
    <url>%2F2017%2F08%2F28%2F206-Reverse-Linked-List%2F</url>
    <content type="text"><![CDATA[Reverse a singly linked list. Hint:A linked list can be reversed either iteratively(迭代) or recursively(递归).Could you implement both ? 题意： 反向单向链表：把整个链表反转，，最后一个节点是头结点，其实就是完成单链表的反转。 同时用迭代和递归实现。 思路： 方法一： 利用迭代，非递归实现，利用三个指针，分别记录当前节点，当前节点的下一个节点，以及下一个节点的下一个节点，用于反转断开链表后从新获取后面未反转单链的头结点。 123456789101112131415161718ListNode* reverseList(ListNode* head) &#123; if (head == NULL || head-&gt;next == NULL) return head; ListNode *p = head; ListNode *tempfirst = head-&gt;next; ListNode *tempsecond = tempfirst-&gt;next; p-&gt;next = NULL; while (tempfirst != NULL) &#123; tempfirst-&gt;next = p; //p-&gt;next = tempfirst; p = tempfirst; tempfirst = tempsecond; if (tempsecond != NULL) tempsecond = tempsecond-&gt;next; &#125; return p;&#125; 方法二： 递归实现，递归前指针p指向头结点的下一个节点，head指向头结点，一直向下递归，直到链表尾部，就像入栈操作一样，先入栈的后出栈，当递归返回上一层时，p在head后面，直接修改next指向，完成节点反转，然后继续返回上一层，直到递归栈为空，从而实现所有节点的反转。 1234567891011ListNode* reverseList(ListNode* head) &#123; if(head==NULL) return NULL; if (head-&gt;next == NULL) return head; ListNode *p = head-&gt;next; ListNode *n = reverseList(p);//n指针一直指向反转后的头结点 head-&gt;next = NULL; p-&gt;next = head; return n;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[205. Isomorphic Strings]]></title>
    <url>%2F2017%2F08%2F28%2F205-Isomorphic-Strings%2F</url>
    <content type="text"><![CDATA[Given two strings s and t, determine if they are isomorphic.Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters.No two characters may map to the same character but a character may map to itself. For example,Given “egg”, “add”, return true.Given “foo”, “bar”, return false.Given “paper”, “title”, return true.Note:You may assume both s and t have the same length. 题意： 给定两个字符串S和T，确定两个字符串是否是同构的。 两个字符串是同构的，如果s中的字符可以通过替换转换为t。 所有字符的出现都必须用另一个字符替换，同时保留字符的顺序。没有两个字符可以映射到同一个字符，但一个字符可以映射其本身。 思路： 核心就是建立映射表，把两个字符串中的字符相映射，判断两个字符串不是同构的根据是s中同一个字符映射t中两个不同的字符，或者t中同一个字符映射s中两个不同的字符，这样就会违反题目中定义的规则。如果遍历完两个字符串所有字符，没有出现上述情况，则两个字符串是同构字符串。 12345678910111213141516171819202122232425262728class Solution &#123;public: bool isIsomorphic(string s, string t) &#123; if (Isomorphic(s,t)&amp;&amp;Isomorphic(t,s)) &#123; return true; &#125; return false; &#125; bool Isomorphic(string s, string t) &#123; map&lt;char, char&gt; hashmap; for (int i = 0; i &lt; s.size(); i++) &#123; if (hashmap[s[i]]) &#123; if (hashmap[s[i]] != t[i]) &#123; return false; &#125; &#125; else &#123; hashmap[s[i]] = t[i]; &#125; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[204. Count Primes]]></title>
    <url>%2F2017%2F08%2F28%2F204-Count-Primes%2F</url>
    <content type="text"><![CDATA[Count the number of prime numbers less than a non - negative number, n. 题意： 计算小于n的非负数的质数的个数。 思路：1、 Let&apos;s start with a isPrime function. To determine if a number is prime, we need to check if it is not divisible by any number less than n. The runtime complexity of isPrime function would be O(n) and hence counting the total prime numbers up to n would be O(n2). Could we do better? 2、 As we know the number must not be divisible by any number &gt; n / 2, we can immediately cut the total iterations half by dividing only up to n / 2. Could we still do better? 3、 Let&apos;s write down all of 12&apos;s factors: 2 × 6 = 12 3 × 4 = 12 4 × 3 = 12 6 × 2 = 12 As you can see, calculations of 4 × 3 and 6 × 2 are not necessary. Therefore, we only need to consider factors up to √n because, if n is divisible by some number p, then n = p × q and since p ≤ q, we could derive that p ≤ √n. Our total runtime has now improved to O(n1.5), which is slightly better. Is there a faster approach? public int countPrimes(int n) { int count = 0; for (int i = 1; i &lt; n; i++) { if (isPrime(i)) count++; } return count; } private boolean isPrime(int num) { if (num &lt;= 1) return false; // Loop&apos;s ending condition is i * i &lt;= num instead of i &lt;= sqrt(num) // to avoid repeatedly calling an expensive function sqrt(). for (int i = 2; i * i &lt;= num; i++) { if (num % i == 0) return false; } return true; } 4、 The Sieve of Eratosthenes is one of the most efficient ways to find all prime numbers up to n. But don&apos;t let that name scare you, I promise that the concept is surprisingly simple. Sieve of Eratosthenes: algorithm steps for primes below 121. &quot;Sieve of Eratosthenes Animation&quot; by SKopp is licensed under CC BY 2.0. We start off with a table of n numbers. Let&apos;s look at the first number, 2. We know all multiples of 2 must not be primes, so we mark them off as non-primes. Then we look at the next number, 3. Similarly, all multiples of 3 such as 3 × 2 = 6, 3 × 3 = 9, ... must not be primes, so we mark them off as well. Now we look at the next number, 4, which was already marked off. What does this tell you? Should you mark off all multiples of 4 as well? 5、 4 is not a prime because it is divisible by 2, which means all multiples of 4 must also be divisible by 2 and were already marked off. So we can skip 4 immediately and go to the next number, 5. Now, all multiples of 5 such as 5 × 2 = 10, 5 × 3 = 15, 5 × 4 = 20, 5 × 5 = 25, ... can be marked off. There is a slight optimization here, we do not need to start from 5 × 2 = 10. Where should we start marking off? 6、 In fact, we can mark off multiples of 5 starting at 5 × 5 = 25, because 5 × 2 = 10 was already marked off by multiple of 2, similarly 5 × 3 = 15 was already marked off by multiple of 3. Therefore, if the current number is p, we can always mark off multiples of p starting at p2, then in increments of p: p2 + p, p2 + 2p, ... Now what should be the terminating loop condition? 7、 It is easy to say that the terminating loop condition is p &lt; n, which is certainly correct but not efficient. Do you still remember Hint #3? 8、 Yes, the terminating loop condition can be p &lt; √n, as all non-primes ≥ √n must have already been marked off. When the loop terminates, all the numbers in the table that are non-marked are prime. The Sieve of Eratosthenes uses an extra O(n) memory and its runtime complexity is O(n log log n). For the more mathematically inclined readers, you can read more about its algorithm complexity on Wikipedia. 123456789101112131415161718192021222324252627class Solution &#123;public: int countPrimes(int n) &#123; int counts = 0; vector&lt;int&gt; isPrimes(n, 1); for (int i =2;i*i&lt; n;i++) &#123; if (!isPrimes[i]) &#123; continue; &#125; for (int j = i*i;j&lt; n;j+=i) &#123; isPrimes[j] = 0; &#125; &#125; for (int i = 2;i&lt;n;i++) &#123; if (isPrimes[i]) &#123; cout &lt;&lt; i &lt;&lt; " "; counts++; &#125; &#125; return counts; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[203. Remove Linked List Elements]]></title>
    <url>%2F2017%2F08%2F28%2F203-Remove-Linked-List-Elements%2F</url>
    <content type="text"><![CDATA[Remove all elements from a linked list of integers that have value val. ExampleGiven : 1 – &gt; 2 – &gt; 6 – &gt; 3 – &gt; 4 – &gt; 5 – &gt; 6, val = 6Return: 1 – &gt; 2 – &gt; 3 – &gt; 4 – &gt; 5 题意： 删除链表中所有与给定值相等的元素节点。 思路： 思路很简单，一边遍历一边删除链表比较链表中元素值，如果等于目标值直接删除节点。注意：1、删除的节点在头结点的情况；2、删除节点后记得释放内存空间； 123456789101112131415161718192021222324252627282930ListNode* removeElements(ListNode* head, int val) &#123; if (head == NULL) &#123; return NULL; &#125; ListNode removeHead(-1);//建立临时头结点、便于删除链表第一个节点 ListNode *tempHead = &amp;removeHead; tempHead-&gt;next = head; ListNode *pre = head; while (pre != NULL) &#123; if (pre-&gt;val == val) &#123; tempHead-&gt;next = pre-&gt;next; pre-&gt;next = NULL; /*new &lt;--&gt; delete new[] &lt;--&gt; delete[] malloc &lt;--&gt; free C++中的new / delete是新实现的内存分配器，而malloc和free是C标准库实现的另一套内存分配器，他们走的是不同的算法，所以不能混用了.*/ delete(pre); //free(pre); pre = tempHead-&gt;next; &#125; else &#123; pre = pre-&gt;next; tempHead = tempHead-&gt;next; &#125; &#125; return removeHead.next;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[202. Happy Number]]></title>
    <url>%2F2017%2F08%2F28%2F202-Happy-Number%2F</url>
    <content type="text"><![CDATA[Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process : Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example : 19 is a happy number​ 1^2 + 9^2 = 82​ 8^2 + 2^2 = 68​ 6^2 + 8^2 = 100​ 1^2 + 0^2 + 0^2 = 1 题意： 写一个算法来判断一个数字是否“happy”。 一个“happy”的数字是由下面的过程定义的一个数字：从任何正整数开始，用它的数字的平方代替数字，重复这个过程直到数字等于1，或者在一个不包括1的循环中循环。这个过程以1结尾的数字是“happy”数字。 思路： 递归循环求得数字的每一位，对每一位求平方再求和，求出来的和判断是否为1，如果为1循环结束，数字是happy数字，如果不为1，判断此和是否出现过，如果出现过说明求和出现循环，数字不是happy数字，如果没有重复出现过此和，则继续对此数字逐位求平方和。 123456789101112131415161718192021222324252627bool isHappy(int n) &#123; vector&lt;int&gt; digital; set&lt;int&gt; placeDig; int count = 0; while (1) &#123; //cout &lt;&lt;"循环第"&lt;&lt; ++count &lt;&lt; "次"&lt;&lt;endl; while (n) &#123; int dig = n % 10; n /= 10; digital.push_back(dig); &#125; int sum = 0; for (auto &amp;num : digital) &#123; sum += pow(num, 2); &#125; //cout &lt;&lt; "sum:::" &lt;&lt; sum &lt;&lt; endl; digital.clear(); if (sum == 1) return true; auto res = placeDig.insert(sum);//判断此和是否循环出现过，set如果元素存在，insert()方法返回值的pair第二个元素为false if (res.second == false) &#123; return false; &#125; else n = sum; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[199. Binary Tree Right Side View]]></title>
    <url>%2F2017%2F08%2F26%2F199-Binary-Tree-Right-Side-View%2F</url>
    <content type="text"><![CDATA[Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. 123456789For example:Given the following binary tree, 1 &lt;--- / \2 3 &lt;--- \ \ 5 4 &lt;---You should return [1, 3, 4]. 题意： 给定一棵二叉树，返回从右边看这棵二叉树所看到的节点序列（从上到下）。 思路： 层次遍历法，遍历到每层最后一个节点时，把其放到结果集中。 1234567891011121314151617181920212223242526272829303132333435363738struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; vector&lt;int&gt; res; if (!root) return res; queue&lt;TreeNode*&gt; que1; que1.push(root); while (!que1.empty()) &#123; queue&lt;TreeNode*&gt; que2; while (!que1.empty()) &#123; TreeNode* temp = que1.front(); que1.pop(); if (temp-&gt;left) &#123; que2.push(temp-&gt;left); &#125; if (temp-&gt;right) &#123; que2.push(temp-&gt;right); &#125; if (que1.empty()) &#123; res.push_back(temp-&gt;val);//取最右边元素放入结果集 &#125; &#125; que1 = que2; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[188. Best Time to Buy and Sell Stock IV]]></title>
    <url>%2F2017%2F08%2F26%2F188-Best-Time-to-Buy-and-Sell-Stock-IV%2F</url>
    <content type="text"><![CDATA[Say you have an array for which the ith element is the price of a given stock on day i.Design an algorithm to find the maximum profit. You may complete at most k transactions. Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 题意： 一个数组第i个元素是表示股票在第i天的价格，只允许最多完成k次交易，设计一个找到最大收益的算法。 注意：不能从事多个交易在同一时间（即，你必须卖出股票后，才能再次购买股票）。 思路： 典型的动态规划股票问题，这应该是股票问题中最难的，完成k次交易，获得最大收益。思路同121. Best Time to Buy and Sell Stock，122. Best Time to Buy and Sell Stock II，123. Best Time to Buy and Sell Stock III，利用动态规划的局部最优构造全局最优的思想解决问题。 方法一：12345678910111213题目的关键是下面的动态转移方程:local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff)，global[i][j]=max(local[i][j],global[i-1][j])，而这个方程的具体理解如下：首先global比较简单，不过是不断地和已经计算出的local进行比较，把大的保存在global中。然后看local,关键是要理解local的定义，local[i][j]表示，前i天进行了j次交易，并且第i天进行了第j次交易的最大利润，所以local[i][j]中必然有一次交易，也就是当近一次交易，发生在第i天。 local由两个部分的比较完成。第一部分是，global[i-1][j-1]+max(diff,0), 表示的就是，前面把之前的j - 1次交易，放在之前的i - 1天，然后让第i天来进行第j次交易，那么加入此时diff(price[i] - price[i - 1])大于零，那么正好可以可借助这次交易的机会增长里利润(利润= diff)，否则的话，如果diff小于零，那就在第i天当天进行一次买卖，凑一次交易的次数，但是产生利润为0.第二部分是, local[i-1][j]+diff， 这里的 local[i-1][j]表示的是，前面j次交易在第i -1天就已经完成了，可是因为说了local[a][b]一定要表达在第a天完成了b次交易的最大利润，所以就需要强制使得交易在第i天发生，为了实现这一点，只需要在local[i - 1][j]的基础上，加上diff(price[i] - price[i - 1])就可以了。如果diff &lt; 0 那也没有办法，因为必须满足local的定义。接下来算global的时候，总会保证取得一个更大的值。 123456789101112131415161718192021222324252627282930这一题的难度要远高于前面几题，需要用到动态规划，但是需要额外的辅助。先按照之前的方法对数组进行统计，计算出无限制条件下的最少交易次数tradeCount和最大获益profitCount。如果这个最少交易次数已经小于k了，那么直接返回最大获益即可。同时也因为在k &lt; tradeCount的情况下，进行动态规划的效率很低，所以要先进行处理来避免。在动态规划的部分，维护两个数组：local和global。其中local[i][j]表示总交易次数为i截止到第j天并且在最后一天要做交易的情况下的最大获益，global[i][j]表示总交易次数为i截止到第j天的最大获益。之所以在global之外还要维护一个local数组，是因为在计算global[i][j]时，面临两种情况： 最后一天不做交易，那么直接等于global[i][j - 1] 最后一天要做交易，那么又需要分别考虑罪有一天是否有收益的问题，所以要增加一个local数组进行辅助递推公式：int diff = prices[j] - prices[j - 1];local[i][j] = Math.max(global[i - 1][j - 1], local[i][j - 1] + diff);global[i][j] = Math.max(global[i][j - 1], local[i][j]);解释一下local[i][j] = Math.max(global[i - 1][j - 1], local[i][j - 1] + diff);这一条，当diff &lt; 0时，在最后一条做交易必然是亏的，所以其实此时local[i][j]直接等于global[i - 1][j - 1]；当diff &gt; 0时，本来应该比较两种情况的，global[i - 1][j - 1] + diff和local[i][j - 1] + diff，但是通过以下推断我们可以知道local[i][j - 1] &gt; global[i - 1][j - 1]，所以无须比较。推断：因为global[i - 1][j - 1] = Math.max(global[i - 1][j - 2], local[i - 1][j - 1])所以global[i - 1][j - 1] = global[i - 1][j - 2]或者global[i - 1][j - 1] = local[i - 1][j - 1])由题意可知：local[i][j - 1] &gt; local[i - 1][j - 1])又因为local[i][j - 1] = Math.max(global[i - 1][j - 2], local[i][j - 2] + diff)所以local[i][j - 1] &gt;= global[i - 1][j - 2]综上local[i][j - 1] &gt; local[i - 1][j - 1])并且local[i][j - 1] &gt;= global[i - 1][j - 2]，即local[i][j - 1] &gt; global[i - 1][j - 1]这里还有一个性质，就是当i大于最大收益所需的交易次数时，其实local[i][j] == global[i][j]，多出来的交易都是当天买卖，不会产生收益。 123456789101112131415161718192021222324252627282930313233343536//“局部最优和全局最优解法”class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; int res = 0; int len = prices.size(); if (k==0||len&lt;2) &#123; return 0; &#125; if (k&gt;=len/2)//k大于最多交易次数就变为122. Best Time to Buy and Sell Stock II &#123; for (int i = 1;i&lt;len;i++) &#123; res += max(0, prices[i] - prices[i - 1]); &#125; return res; &#125; vector&lt;vector&lt;int&gt;&gt; local(len, vector&lt;int&gt;(k + 1, 0)); vector&lt;vector&lt;int&gt;&gt; global(len, vector&lt;int&gt;(k + 1, 0)); for (int j = 1; j &lt;= k; j++) &#123; for (int i = 1;i&lt;len;i++)//注意动态方程中天数和交易次数在二维数组中行列顺序 &#123; /*int diff = prices[j] - prices[j - 1]; local[i][j] = Math.max(global[i - 1][j - 1], local[i][j - 1] + diff); global[i][j] = Math.max(global[i][j - 1], local[i][j]);*/ int diff = prices[i] - prices[i - 1]; //local[i][j] = max(global[i - 1][j - 1] + max(diff, 0), local[i-1][j] + diff); local[i][j] = max(global[i - 1][j - 1], local[i-1][j] + diff);//此处local[i][j]表示总交易次数为i截止到第j天并且在最后一天要做交易的情况下的最大获益，global[i][j]表示总交易次数为i截止到第j天的最大获益。i表示交易次数，j表示第几天。 global[i][j] = max(global[i-1][j], local[i][j]); &#125; &#125; return global[len - 1][k]; &#125;&#125;; 方法二： 不太懂的一个方法,思路同123. Best Time to Buy and Sell Stock III方法二，代码简洁，但是不太理解。 123456789101112131415161718192021222324252627282930class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; int res = 0; int len = prices.size(); if (k == 0 || len&lt;2) &#123; return 0; &#125; if (k &gt;= len / 2) &#123; for (int i = 1; i&lt;len; i++) &#123; res += max(0, prices[i] - prices[i - 1]); &#125; return res; &#125; vector&lt;int&gt; buy(k+1,INT_MIN),sale(k+1,0); for (int i = 0;i&lt;len;i++) &#123; for (int j =1;j&lt;=k;j++) &#123; buy[j] = max(buy[j], sale[j - 1] - prices[i]); sale[j] = max(sale[j], buy[j] + prices[i]); &#125; &#125; return sale[k]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[187. Repeated DNA Sequences]]></title>
    <url>%2F2017%2F08%2F26%2F187-Repeated-DNA-Sequences%2F</url>
    <content type="text"><![CDATA[All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”.When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10 - letter - long sequences(substrings) that occur more than once in a DNA molecule. For exampleGiven s = “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”,Return:[“AAAAACCCCC”, “CCCCCAAAAA”]. 题意： 所有的DNA都是由简写为A，C，G，T的核苷酸构成的，例如ACGAATTCCG。在研究DNA时，辨别DNA中重复的序列在有些时候是很有用的。 编写一个程序来找到一个DNA分子中出现次数超过一次的长度为10的子序列（子串）。 思路： 如果时间上没有要求的话，用find和substr搞定是没问题的，然而在测试数据较大的时候这种方法必然会超时。这个题的标签是Hash Table和Bit Manipulation，参考https://leetcode.com/discuss/24478/i-did-it-in-10-lines-of-c中的方案，需要利用hash表，以及按位运算来解决此题。 测试数据中只会出现4种字符’A’,’C’,’G’,’T’，其ASC值分别为65,67,71,84,对应的二进制位如下所示，这里仅列取32位情况下的低8位，前24位全部为0。 A — 65 — 0100 0001 C — 67 — 0100 0011 G — 71 — 0100 0111 T — 84 — 0101 0100 可以发现，仅通过低3位就能把4种字符区分开来，题目又要求了是长度为10的子串（10-letter-long），试想为什么不是11或者更大呢，因为10个字符每个用3位表示一个字符的话刚好是30位，而一个int是32位，刚好能放下，如果是11+就放不下了。因此，我们可以把一个长度为10的字符串映射成一个int数，用其低30位表示这个串，作为这个串的key，然后把key存在Hash Table中，当key重复出现时就代表子串重复出现了。 除了上述方法外，受其启发，其实只用2个二进制位就可以唯一区分4中字符，比如A-00,C-01,G-10,T-11，这样，我们只用int的低20位就可以表示一个字符串的key，这种方法甚至可以最多用于处理长度为16的子串。比上面一种方法略显复杂的是，需要手动将ACGT映射成2位二进制数，方法也是多种多样的。比如： 12345678910111213141516171819202122232425262728//转换2位二进制数方法一：int function(char c) &#123; int ret = 0; switch (c) &#123; case 'A': break; case 'G': ret = 1; break; case 'C': ret = 2; break; case 'T': ret = 3; break; &#125; return ret;&#125;//转换2位二进制数方法二：// 数组映射，调用时使用nums[c - 65]即可得到字符c的映射码int nums[20]; nums[0] = 0; nums[2] = 1; nums[6] = 2; nums[19] = 3;//转换2位二进制数方法三：//(s[i] - 64) % 5完成映射 A : ('A' - 64) % 5 = 1 (mod 5) = 1 = 01 B : ('C' - 64) % 5 = 3 (mod 5) = 3 = 11 C : ('G' - 64) % 5 = 7 (mod 5) = 2 = 10 D : ('T' - 64) % 5 = 20 (mod 5) = 0 = 00key = key &lt;&lt; 2 &amp; 0xfffff | (s[i] - 64) % 5; 方法一： 用ACGT的ASC码的后2位来映射的解法，然后做移位操作，相与操作后，下面代码中&amp;0xfffff应该保证后20位相等，即加入一个字符构成的序列的key值，只要重复前面出现，经过key = ((key &lt;&lt; 2) | ((s[i] - 64) % 5))&0xfffff;计算的key值就会相等。 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; vector&lt;string&gt; res; if (s.size()&lt;10) &#123; return res; &#125; unordered_map&lt;int, int&gt; hash; int key = 0, i = 0; for (;i&lt;9;++i) &#123; key = ((key &lt;&lt; 2) | ((s[i] - 64) % 5))&amp;0xfffff; &#125; for (;i&lt;s.size();++i) &#123; key = ((key &lt;&lt; 2) | ((s[i] - 64) % 5))&amp;0xfffff; int val = hash[key]; hash[key]++; if (val == 1) res.push_back(s.substr(i - 9, 10)); &#125; return res; &#125;&#125;; 方法二： 用ACGT的ASC码的后3位来映射的解法。在代码编写中，对于最开始的9个字符是为了构造第一个key而做功，一般说来从第10个字符开始才开始判定key的重复出现情况。然而由于AGCT的映射码均为三位且没有任何一个码是000，因此在前面9个字符也是可以与其他字符一致处理的，不会出现误判。一致处理的代码大致如下： 123456789101112131415class Solution &#123;public: vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; vector&lt;string&gt; strs; unordered_map&lt;int, int&gt; map; int key = 0; for (int i = 0, end = s.size(); i &lt; end; ++i) &#123; key = ((key &lt;&lt; 3) | (s[i] &amp; 0x7)) &amp; 0x3fffffff; int val = map[key]++; if (val == 1) strs.push_back(s.substr(i - 9, 10)); &#125; return strs; &#125;&#125;; 123456789101112131415161718//不一致处理的代码大概如下，先处理前9个字符，然后处理后面的：class Solution &#123;public: vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; vector&lt;string&gt; strs; if (s.size() &lt;= 10) return strs; unordered_map&lt;int, int&gt; map; int key = 0, i = 0; for (; i &lt; 9; ++i) key = ((key &lt;&lt; 3) | (s[i] &amp; 0x7)) &amp; 0x3fffffff; for (int end = s.size(); i &lt; end; ++i) &#123; key = ((key &lt;&lt; 3) | (s[i] &amp; 0x7)) &amp; 0x3fffffff; if (map[key]++ == 1) strs.push_back(s.substr(i - 9, 10)); &#125; return strs; &#125;&#125;; ###]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[179. Largest Number]]></title>
    <url>%2F2017%2F08%2F26%2F179-Largest-Number%2F</url>
    <content type="text"><![CDATA[Given a list of non negative integers, arrange them such that they form the largest number.For example, given[3, 30, 34, 5, 9], the largest formed number is 9534330.Note : The result may be very large, so you need to return a string instead of an integer. 题意： 给定一组非负整数数组，排列组合这些整数，使其构成所有组合中最大的数。 思路： 分析如下： eg1. [0, 0, 0 , 0] -&gt; 0 eg2. [1211, 12] -&gt; 121211而不是121112。 所以可以考虑排序，而排序的根据(也就是比较函数的比较原理)不是这些数的值的相对大小，而是它们构成新的数的大小比较。 所以，虽然1211 &gt; 12， 但是 “1211” + “12” = “121112”, “12” + “1211” = “121211”, “121112” &lt; “121211” 所以从构成新的数的角度来看, “1211” &lt; “12” 。 对所有数进行排序，规则如下： 给定两个非负整数：a, b 将它们转换成字符串形式，然后进行连接。可得两种结果： a在前，b在后，记为：strAB b在前，a在后，记为：strBA 如果strAB &gt; strBA，那么排序时a在b的前面。 其他的就是要注意全是0的情况和前导0的情况. 12345678910111213141516171819202122232425262728string largestNumber(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) &#123; return NULL; &#125; sort(nums.begin(), nums.end(), [](int a, int b) &#123;return to_string(a) + to_string(b) &gt; to_string(b) + to_string(a); &#125;); string res = ""; for (auto rr : nums) &#123; res += to_string(rr); &#125; /* Input: [0, 0] Output : "00" Expected : "0" 其他的就是要注意全是0的情况和前导0的情况 */ //1 /*if (res[0]=='0') &#123; return "0"; &#125; else return res;*/ //2 auto pos = res.find_first_not_of('0'); return pos == string::npos ? "0" : res; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[173. Binary Search Tree Iterator]]></title>
    <url>%2F2017%2F08%2F26%2F173-Binary-Search-Tree-Iterator%2F</url>
    <content type="text"><![CDATA[Implement an iterator over a binary search tree(BST).Your iterator will be initialized with the root node of a BST.Calling next() will return the next smallest number in the BST. Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. 题意： 在二叉搜索树（BST）上实现一个迭代器。迭代器的初始化值是二叉搜索树的根节点。 调用next()函数将返回二叉搜索树的下一个更小的元素。 注意：next() and hasNext() 函数运行的时间复杂度平均O（1），空间复杂度O（h），其中h是树的高度。 思路： 主要借助栈完成儿茶搜索树的中序遍历，并且用全局树节点指针记录栈顶元素，挥着栈顶元素的右子树，通过全局树节点指针和栈是否为空判断迭代器是否可以获取元素，用next()函数进行取值。 1234567891011121314151617181920212223242526272829303132333435363738/*** Definition for binary tree**/struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class BSTIterator &#123;public: BSTIterator(TreeNode *root) &#123; bstRoot = root; &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; return (bstRoot ||!s.empty()); &#125; /** @return the next smallest number */ int next() &#123; int res = 0; while(bstRoot) &#123; s.push(bstRoot); bstRoot = bstRoot-&gt;left; &#125; TreeNode *temp = s.top(); res = temp-&gt;val; s.pop(); bstRoot = temp-&gt;right; return res; &#125;private: stack&lt;TreeNode*&gt; s; TreeNode *bstRoot;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[166. Fraction to Recurring Decimal]]></title>
    <url>%2F2017%2F08%2F26%2F166-Fraction-to-Recurring-Decimal%2F</url>
    <content type="text"><![CDATA[Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. For example,Given numerator = 1, denominator = 2, return “0.5”.Given numerator = 2, denominator = 1, return “2”.Given numerator = 2, denominator = 3, return “0.(6)”. Hint:No scary math, just apply elementary math knowledge.Still remember how to perform a long division ?Try a long division on 4 / 9, the repeating part is obvious.Now try 4 / 333. Do you see a pattern ?Be wary of edge cases!List out as many test cases as you can think of and test your code thoroughly. 题意： 给定两个整数表示一个分数的分子和分母，返回字符串格式的分数。 如果小数部分是重复的，把重复部分写在括号中构成字符串。 提示： 只需要运用初等数学知识，要运用进行长除法。 尝试长除法的4 / 9，重复的部分是明显的。现在试4 / 333，能看长除法模式。 思路： 有以下几种情况: 如果可以直接除尽, 那么最好, 直接返回 如果不能直接除尽, 那么先取整数, 再计算小数. 计算小数部分时就是每次取商, 又可分为能除尽, 和循环小数 如果能除尽那么当最后可以整除的时候返回结果 比较麻烦的是循环小数. 我们需要将每次的被除数和当前商的位置用一个hash表存起来, 这样当某次发现相同的被除数时说明出现了循环, 那么就加在第一次出现这个被除数的商的位置加括号，并且在做运算的时候可能会越界, 因此我们要将除数和被除数都以long类型存储, 并且在运算之前将符号先提取出来。 123456789101112131415161718192021222324class Solution &#123;public: string fractionToDecimal(int numerator, int denominator) &#123; if (numerator == 0) return "0"; long num1 = fabs(numerator), num2 = fabs(denominator); int flag = (numerator&gt;0 ^ denominator&gt;0) ? 1 : 0; string ans = (flag ? "-" : "") + to_string(num1 / num2); if (num1%num2 == 0) return ans; unordered_map&lt;int, int&gt; hash; num1 = num1%num2; ans += "."; while (!hash.count(num1)) &#123; hash[num1] = ans.size(); num1 *= 10; ans += to_string(num1 / num2); if (num1 % num2 == 0) return ans; num1 = num1%num2; &#125; ans.insert(hash[num1], 1, '('); ans += ')'; return ans; &#125;&#125;; 扩展： 计算机原码、补码、反码知识。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*是int是4个字节表示,也就是32位.最高位是符号位,取值范围是：- 2 ^ 31-- - 2 ^ 31 - 1 k位的二进制整数可以表示的状态共2^k种，所以，负数有2^(k-1)个。int型占4个字节，有32位，所以负数有2^31个，最小的负数就是-2^31=-2147483648了。 二进制数, 正数的反码和补码就是它自己，或说正数没有反码和补码。 负数有反码和补码。 负数反码，符号位搁置不动，其它位，把原码 1 变0， 原码0 变1。 负数补码，等于反码加 1。 负数的补码为取反加1，由于10000000，最高位为1，可知是负数，先减一，为01111111，再取反10000000，得到128，所以原数为-128 在32位操作系统中，由于是二进制，其能最大存储的数据是1111111111111111111111111111111 所需知识点: 1：在计算机中整数的存储 1.1：整数位正数时，以原码形式存储；为负数时以补码形式存储。 1.2：正数的补码，原码，反码是一样的； 负数的反码是将除符号位以外的其他位全部取反得到（例：原码1000 0001，其反码为1111 1110）； 负数的补码是将这个负数的反码加1 得到（例：原码1000 0001，其反码为1111 1110，其补码为1111 1111）。 1.3：已知一个原码A的补码B，要求得这个原码A，只需要求得这个已知的补码B的补码C，这个补码的补码C就是已知的补码的原码A。 (例：已知原码A的补码B为：1111 1111，B的反码为：1000 0000，B的补码为：1000 0001)。 1.4:32位的二进制数用16进制表示方法：将32位的二进制数的每相邻4位作为一个二进制数，计算出值，再用1位16进制数表示。 （例：1111 1111 1111 1111 1111 1111 1111 1111就可以表示为 f f f f f f f f,因为二进制数1111是15,16进制的15表示为 f ）。 最小值： 0x8000 0000为带符号整型数的最小值。用二进制表示为1000 0000 0000 0000 0000 0000 0000 0000； 因为是带符号型所以最后面的1是符号位，而且这个二进制数只是原码A的补码B，因为符号位是1，表示负数，所以需要求得它B的补码C才能知道这个数的值是多大。它的反码为1111 1111 1111 1111 1111 1111 1111 1111， 它的补码C是反码加一，进一位，为：1 1000 0000 0000 0000 0000 0000 0000 0000 0000； 这个补码C就是原来二进制数的原码， 它的大小是2的31次方，即2147483648，所以这个数的值是-2147483648。是带符号整形的最小值。不带符号整型的最小值是0 若果0x8000 0000是一个无符号型整数，那么它表示为二进制数为：1000 0000 0000 0000 0000 0000 0000 0000。 没有符号位，直接得它的值为2的31次方，为2147483648。 最大值： 0xFFFF FFFF为不带符号整型的最大值，用二进制表示为：1111 1111 1111 1111 1111 1111 1111 1111 它的大小是2的32次方减1，得到4294967296 - 1 = 4294967295。是不带符号整型的最大值。带符号整型的最大值在后面详述。 若果0xFFFF FFFF是一个带符号整型，那么它表示为二进制数为：1111 1111 1111 1111 1111 1111 1111 1111 最后一位数1是符号位，这个二进制数是负数，需要求得它的补码才能知道它的值，它是某一个数的原码A的补码B。 可以求得它的反码为1000 0000 0000 0000 0000 0000 0000 0000 ， 反码加1得到它的补码为：1000 0000 0000 0000 0000 0000 0000 0001。 求得它的值为-1。 0x7FFF FFFF是带符号整型的最大值，它用二进制数表示为：0111 1111 1111 1111 1111 1111 1111 1111。 它的最后一位是符号位0，所以是正数，它的原码，反码，补码都是一样的。 它的值为2的32次方减1，为：2147483647。是带符号整型的最大值。 */]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[164. Maximum Gap]]></title>
    <url>%2F2017%2F08%2F26%2F164-Maximum-Gap%2F</url>
    <content type="text"><![CDATA[Given an unsorted array, find the maximum difference between the successive(相邻的) elements in its sorted form.Try to solve it in linear time / space.Return 0 if the array contains less than 2 elements.You may assume all elements in the array are non - negative integers and fit in the 32 - bit signed integer range.//如果我们 题意： 给定一个未排序的数组，把数组排序，找出相邻元素之间的最大差值。 思路： 刚开始思路是最直接的方法是先用快排排序再找相邻元素的最大差值。但是因为快速排序的时间复杂度是O(n * log(n))，而题目要求的时间复杂度是：O(n)，所以不符合题目要求。 基于桶排序的思路：桶排序的原理，首先获取所排序数组a中最大数的位数，然后根据位数循环分发原数组的元素到一个临时的二维数组b中去（临时二维数组有10行，列数和排序数组中列数相同），分发的规则是根据个位、十位、百位、、、的大小来进行分发，从个位开始逐渐到高位，每次分发后都要回收（即把b中每行中记录的a的数据重新写到a中，每一位的比较都要回收），当比较完a中最大数的最高位时，a所回收的b中的序列即为排序好的序列。 简单原理就是：根据每一位的大小进行排序（从个位到最高位），每位比较一次进行结束就进行回收，那么此位就会按照大小进行排序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//获取nums数组中最大的元素位数int getMaxNumDigits(vector&lt;int&gt; &amp;nums) &#123; int maxValue = 0; int digits = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i]&gt;maxValue) &#123; maxValue = nums[i]; &#125; &#125; while (maxValue) &#123; digits++; maxValue /= 10; &#125; return digits;&#125;//把a中元素分发到临时二维数组b中,此时要根据比较的位数进行分发，所以应该有一个控制位数的int参数void distributeElement(vector&lt;int&gt; &amp;nums, vector&lt;vector&lt;int&gt;&gt; &amp;b,int digits) &#123; int divisor = 1;//除数，用于控制得到比较位 for (int i = 1;i&lt;digits;i++) &#123; divisor *= 10; &#125; for (int i =0;i&lt;nums.size();i++) &#123; int valueOfBit = (nums[i] / divisor) % 10;//得到此位大小，确定此位所在b中第几行 int numOfCol = ++b[valueOfBit][0];//确定nums[i]放在第几列 b[valueOfBit][numOfCol] = nums[i];//分发到b中 &#125;&#125;//将b中的元素按照顺序复制回a中, 此过程称为回收, 用回收函数collectElments()实现void collectElments(vector&lt;int&gt; &amp;nums, vector&lt;vector&lt;int&gt;&gt; &amp;b) &#123; int k = 0; for (int i = 0 ;i&lt;b.size();i++) &#123; for (int j = 1;j&lt;=b[i][0];j++) &#123; nums[k++] = b[i][j]; &#125; &#125;&#125;int maximumGap(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt; 2) &#123; return 0; &#125; //1、获取nums数组中最大的元素位数,用来控制对每一位的比较（1位：(num/1)%10; 2位：(num/10)%10;3位：(num/10*10)%10;4位：(num/10*10*10)%10................） int digits = getMaxNumDigits(nums); //2、按位进行调用分发函数和回收函数 for (int i = 1 ;i&lt;=digits;i++) &#123; //3、首先创建临时的二维数组b，用于存储分发的nums的数据。并且每一位分发开始前b的每个元素都为0 vector&lt;int&gt; tempB(nums.size(), 0); vector&lt;vector&lt;int&gt;&gt; b(10, tempB); //3.1、进行分发 distributeElement(nums, b, i); //3.2、每一位分发后进行回收 collectElments(nums, b); &#125; //4、到最后一位结束堆排序完成，nums中就是排序后的元素序列 /*for (int i = 0;i&lt;nums.size();i++) &#123; cout &lt;&lt; nums[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;*/ int maxNumGap = 0; for (int i = 0; i &lt; nums.size() - 1; i++) &#123; maxNumGap = maxNumGap &gt; nums[i + 1] - nums[i] ? maxNumGap : nums[i + 1] - nums[i]; &#125; return maxNumGap;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[162. Find Peak Element]]></title>
    <url>%2F2017%2F08%2F26%2F162-Find-Peak-Element%2F</url>
    <content type="text"><![CDATA[A peak element is an element that is greater than its neighbors.Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that num[-1] = num[n] = -∞.For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.Note:Your solution should be in logarithmic complexity(对数复杂度). 题意： 峰值元素是一种比它的左右邻居元素都大的元素。 给定的输入数组中的num[i] ≠ num [i+ 1 ]，找到一个峰值元素并返回它的值对应的索引。 数组可能包含多个峰值，在这种情况下，返回任何一个峰值的索引都是好的。 注意： 数组可能包含多个峰值，在这种情况下返回任何一个峰值的索引都是正确的。 思路： 找到数组中的一个峰值，并不是数组中的最大的那个峰值，所以可以利用二分查找的方法就行查找，时间复杂度会降低很多。 1234567This problem is similar to Local Minimum. And according to the given condition, num[i] != num[i+1], there must exist a O(logN) solution. So we use binary search for this problem. If num[i-1] &lt; num[i] &gt; num[i+1], then num[i] is peak If num[i-1] &lt; num[i] &lt; num[i+1], then num[i+1...n-1] must contains a peak If num[i-1] &gt; num[i] &gt; num[i+1], then num[0...i-1] must contains a peak If num[i-1] &gt; num[i] &lt; num[i+1], then both sides have peak (n is num.length) 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int findPeakElement(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int l = 0, r = len - 1; while (l &lt; r) &#123; int mid = (l + r) / 2; if (l == mid) &#123; if (nums[l] &gt; nums[r]) return l; else return r; &#125; else if (nums[mid] &gt; nums[mid + 1] &amp;&amp; nums[mid] &gt; nums[mid - 1]) &#123; return mid; &#125; else if (nums[mid] &lt; nums[mid + 1]) &#123; l = mid; &#125; else if (nums[mid] &lt; nums[mid - 1]) &#123; r = mid; &#125; &#125; return l; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[160. Intersection of Two Linked Lists]]></title>
    <url>%2F2017%2F08%2F26%2F160-Intersection-of-Two-Linked-Lists%2F</url>
    <content type="text"><![CDATA[Write a program to find the node at which the intersection of two singly linked lists begins. 123456789For example, the following two linked lists : A: a1 → a2 ↘ c1 → c2 → c3 ↗ B : b1 → b2 → b3 begin to intersect at node c1. Notes :​ If the two linked lists have no intersection at all, return null.​ The linked lists must retain their original structure after the function returns.​ You may assume there are no cycles anywhere in the entire linked structure.​ Your code should preferably run in O(n) time and use only O(1) memory. 题意： 写一个程序来查找两个单链表相交的开始节点。 注意： 如果两个链表根本没有交集，返回null。 程序不能改变单链表原有的结构。 假设链表没有环的链接结构存在。 代码最好运行在O（n）时间复杂度，使用O（1）的内存空间。 思路： 方法一： 如果两个链表相交，先用 countA=0, countB=0统计两个单链表的长度，因为如果二者有交点的话，如example中所示，二者的后半部分是相同的，成“Y”字形，所以只要减去长的单链表中和短单链表相差的元素个数，然后再同时让两个单链表向后移动，则当二者相同时就是二者的交点。 123456789101112131415161718192021222324252627282930313233343536373839ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; if (headA==NULL||headB==NULL) &#123; return NULL; &#125; ListNode *p=headA, *q=headB; int countA=0, countB=0; while (p !=NULL) &#123; countA++; p = p-&gt;next; &#125; while (q != NULL) &#123; countB++; q = q-&gt;next; &#125; int distances = countA &gt;= countB ? countA - countB : countB - countA; while (distances) &#123; if (countA &gt;= countB) headA = headA-&gt;next; else &#123; headB = headB-&gt;next; &#125; distances--; &#125; while (headA != NULL&amp;&amp;headB != NULL) &#123; if (headA == headB) &#123; return headA; &#125; headA = headA-&gt;next; headB = headB-&gt;next; &#125; return NULL;&#125; 方法二： 不用整形变量值来记录哪个链表长，而是利用指针的移动差来重新设定除去长链表中的元素的头结点，然后再移动比较，当相等时就是要查找的第一个相同的节点。其实查找相同节点的方法是和上面一样的，但是找元素差不同。首先当A链表指针pA遍历到尾节点之后为空的话，就让其指向B链表头，如果B链表指针pB遍历到尾节点之后为空的话，就让其指向A链表头，这样交换，让二者相等相与的时候肯定是两个链表的开始节点。 12345678910111213141516171819202122232425ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; if (headA == NULL || headB == NULL) return NULL; ListNode *pA = headA; ListNode *pB = headB; while (pA!=NULL&amp;&amp;pB!=NULL&amp;&amp;pA!=pB) &#123; pA = pA-&gt;next; pB = pB-&gt;next; if (pA==pB) &#123; return pA;//这个条件也能控制把不想交的两个单链表结果返回为空 &#125; if (pA==NULL)//当为NULL交换指针指向 &#123; pA = headB; &#125; if (pB==NULL)//当为NULL交换指针指向 &#123; pB = headA; &#125; &#125; return pA;//这个判断条件是为了满足第一个头结点开始就是相同节点的情况&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[155. Min Stack]]></title>
    <url>%2F2017%2F08%2F25%2F155-Min-Stack%2F</url>
    <content type="text"><![CDATA[Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) –Push element x onto stack.pop() –Removes the element on top of the stack.top() –Get the top element.getMin() –Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); – &gt; Returns - 3.minStack.pop();minStack.top(); – &gt; Returns 0.minStack.getMin(); – &gt; Returns - 2. 题意： 设计一个支持入栈、出栈、获取栈顶元素，并在能在常数时间内取出的最小元素。 思路： 主要是设计常量时间获取栈顶最小素，主要是通过存储最小元素栈来实现，当push元素的时候首先插入常规栈，然后和最小元素栈的栈顶元素比较是否小于等于，如果是就入最小元素栈；当pop元素的时候比较普通栈顶和最小元素栈顶是否相同，如果相同，就同时弹出；当top获取栈顶元素的时候直接返回普通栈栈顶元素；getMin时直接返回最小栈的栈顶原素。 123456789101112131415161718192021222324252627282930class MinStack &#123;public: void push(int x) &#123; val.push(x);//先插入普通栈，如果小于等于最小元素栈栈顶元素，则插入最小元素栈 if (minVal.empty() || x &lt;= minVal.top()) minVal.push(x); &#125; void pop() &#123; if (minVal.top() == val.top())//弹出时，只有最小元素栈栈顶和普通栈栈顶相等的时候最小元素栈才弹出栈顶元素 &#123; minVal.pop(); val.pop(); &#125; else val.pop(); &#125; int top() &#123; return val.top(); &#125; int getMin() &#123; return minVal.top(); &#125;private: stack&lt;int&gt; val;//普通栈 stack&lt;int&gt; minVal;//最小元素栈&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[153. Find Minimum in Rotated Sorted Array]]></title>
    <url>%2F2017%2F08%2F24%2F153-Find-Minimum-in-Rotated-Sorted-Array%2F</url>
    <content type="text"><![CDATA[Suppose a sorted array is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).Find the minimum element.You may assume no duplicate exists in the array. 题意： 假设一个已排序的数组是在某个点（枢纽元素）上进行旋转，而且事先不知道枢纽元为什么的旋转。找出旋转后的数组的最小元素。注意：没有重复元素存在。 思路： 变形的二分查找，这和之前的33. Search in Rotated Sorted Array题型相同，只不过是查找的是最小元素，并不是查找给定的目标值，思路相同，设置首指针、尾指针，根据中间节点进行划分，逐渐缩小查找区域，最后找到最小值。 1234567891011In this problem, we have only three cases.Case 1. The leftmost value is less than the rightmost value in the list: This means that the list is not rotated(旋转).e.g&gt; [1 2 3 4 5 6 7 ]Case 2. The value in the middle of the list is greater than the leftmost and rightmost values in the list.e.g&gt; [ 4 5 6 7 0 1 2 3 ]Case 3. The value in the middle of the list is less than the leftmost and rightmost values in the list.e.g&gt; [ 5 6 7 0 1 2 3 4 ]As you see in the examples above, if we have case 1, we just return the leftmost value in the list. If we have case 2, we just move to the right side of the list. If we have case 3 we need to move to the left side of the list. 12345678910111213141516171819202122class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int left = 0, right = len - 1; while (left &lt; right) &#123; if (nums[left] &lt; nums[right]) &#123; return nums[left]; &#125; int mid = (left + right) / 2; if (nums[right] &lt; nums[mid]) &#123; left = mid + 1; &#125; else right = mid; &#125; return nums[left]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[150. Evaluate Reverse Polish Notation]]></title>
    <url>%2F2017%2F08%2F24%2F150-Evaluate-Reverse-Polish-Notation%2F</url>
    <content type="text"><![CDATA[Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are + , -, *, / .Each operand may be an integer or another expression. Some examples :[“2”, “1”, “+”, “3”, ““] -&gt; ((2 + 1) 3) -&gt; 9[“4”, “13”, “5”, “/“, “+”] -&gt; (4 + (13 / 5)) -&gt; 6 题意： 把逆波兰表达式（后缀表达式）转换为正常的算术运算表达式，然后对算术运算表达式进行求值。 有效的运算符+，-，*，/，每个操作数可以是整数或一个表达式。 思路： 主要利用容器栈进行表达式的转换 。从左到右读表达式，如果读到操作数就将它压入栈S中，如果读到n元运算符(即需要参数个数为n的运算符)则取出由栈顶向下的n项按操作数运算，再将运算的结果代替原栈顶的n项，压入栈S中 。如果后缀表达式未读完，则重复上面过程，最后输出栈顶的数值则为结束。 其实这就是计算表达式求值的最后一步，当想要计算一个带括号，以及复杂运算符的表达式时，要先把中缀表达式，也就是普通算术运算表达式转换为后缀表达式，然后从前往后遍历后缀表达式，是值的话直接入栈，非值去栈顶元素，运算结束再插入栈顶，知道遍历后缀表达结束，栈顶元素就是普通表达式的值。 1234567891011121314151617181920212223242526272829303132333435363738int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; stack;//辅助栈 int size = tokens.size(); for (int i = 0; i &lt; size; i++) &#123; string str = tokens[i]; int first;//记录运算符对应的左操作数 int second;//记录运算符对应的右操作数 if (str == "+") &#123; second = stack.top(); stack.pop(); first = stack.top(); stack.pop(); stack.push(second + first); &#125; else if (str == "-") &#123; second = stack.top(); stack.pop(); first = stack.top(); stack.pop(); stack.push(first - second); &#125; else if (str == "*") &#123; second = stack.top(); stack.pop(); first = stack.top(); stack.pop(); stack.push(first*second); &#125; else if (str == "/") &#123; second = stack.top(); stack.pop(); first = stack.top(); stack.pop(); stack.push(first / second); &#125; else &#123; //非运算符，为整数，直接解析并压栈 int val = atoi(str.c_str()); stack.push(val); &#125; &#125; return stack.top();&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[149. Max Points on a Line]]></title>
    <url>%2F2017%2F08%2F24%2F149-Max-Points-on-a-Line%2F</url>
    <content type="text"><![CDATA[Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. 题意： 在二维平面上给定n个坐标点，找落在同一条直线上点的个数，并找出落在同一直线上点最多的个数。 思路： 首先注意： 1231）如果点的个数小于3个，则最大数目为点的个数； 2）考虑重复点的情况，重复点是无法计算斜率的； 3）考虑直线与y轴平行时，斜率为无穷大的情况。 容易出错的地方： 123 1）只考虑横坐标相等或纵坐标相等的情况，忽略斜率相等的情况，如&#123;&#123;0, 0&#125;, &#123;1, 1&#125;, &#123;-1, -1&#125;&#125;； 2）忽略两点重合的情况，如&#123;&#123;1,, 1&#125;, &#123;1, 1&#125;, &#123;2, 2&#125;, &#123;2, 2&#125;&#125;；3）忽略只有一个点和两个点的情况； 主要思路：选定一个点，分别计算其他点和它构成的直线的斜率，斜率相同的点肯定在同一条直线上。 计算斜率时，注意重合点和x值相同的两个点（数学上称斜率不存在，此时斜率用int的最大值表示）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475struct Point &#123; int x; int y; Point() :x(0), y(0) &#123;&#125; Point(int a,int b) :x(a), y(b) &#123;&#125;&#125;;class Solution &#123;public: int maxPoints(vector&lt;Point&gt;&amp; points) &#123; if (points.size() &lt;= 2) &#123; return points.size(); &#125; int maxRes = 0; unordered_map&lt;double, int&gt; hash; for (int i = 0; i &lt; points.size(); i++)//以每一个点为固定点 &#123; hash.clear(); int duplicate = 1;//记录跟固定点重合的个数,初始化为1，代表固定点，避免最后计算个数的时候再加上一个固定点，因为hashmap中存储的都是除掉固定点以外的点。 //j = i+1可以减少重复的检索判断，运行效率高 Your runtime beats 78.40% of cppsubmissions. //j = 0 会把以前遍历检索过的点重新检索判断一遍,效率低Your runtime beats 21.86% of cppsubmissions. for (int j = i+1; j &lt; points.size(); j++)//遍历其它点，求其与固定点的斜率 &#123; //j=0为起始点开始循环的时候才需要判断i==j的自身情况 if (i == j)//如果是点自身，跳过 &#123; continue; &#125; else if((points[i].y == points[j].y)&amp;&amp;(points[i].x == points[j].x))//如果跟固定点重合 &#123; duplicate++; continue; &#125; else &#123; double k = 0.0; double m = 0.0; if (points[i].x == points[j].x)//如果垂直于x轴，设其斜率最大，即如果跟固定点在同一条竖线上，斜率设为最大 &#123; k = INT_MAX; &#125; else &#123; //此处要千万注意：首先要把分子转化为double类型，乘上1.0，不然整形和整形相除得到的还是整形会把斜率后面的小数忽略掉，然后整形再转换为double，这样精度就会不够，造成斜率只要整数部分相同就会断定在一条直线上出现错误。double/int 的结果值为double k = 1.0*(points[i].y - points[j].y) / (points[i].x - points[j].x);//计算斜率 &#125; if (hash.count(k)) &#123; hash[k]++; &#125; else &#123; hash[k] = 1; &#125; &#125; &#125; if (hash.empty()) &#123; maxRes = duplicate &gt; maxRes ? duplicate : maxRes; &#125; else &#123; for (auto h : hash) &#123; if (h.second + duplicate &gt; maxRes) &#123; maxRes = h.second + duplicate; &#125; &#125; &#125; &#125; return maxRes; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[148. Sort List]]></title>
    <url>%2F2017%2F08%2F24%2F148-Sort-List%2F</url>
    <content type="text"><![CDATA[Sort a linked list in O(n log n) time using constant space complexity. 题意： 在 O(n log n)的时间复杂度内，在恒定的空间复杂度内，排序单链表。 思路： 表面上看，能够有O(n lgn)时间复杂度的算法为，快速排序，堆排序，归并排序，三者的空间复杂度分别为O(1), O(N), O(N)，所以一开始，想着用快速排序的方法来解决，但是对于链表而言，快速排序没有归并排序时间复杂度低、稳定。 通常而言，也就是针对数组而言，归并排序的空间复杂度为O(N), 你需要开出O(N)的额外空间来容纳数组，来表示归并后的顺序。但是，对于链表而言，你可以省下这部分空间的开销，你只需要改变节点的next指针的指向，就可以表示新的归并后的顺序了，所以空间复杂度陡然降到了O(1)。 归纳一下，就是说，如果待排序的元素存储在数组中，那么快速排序相对归并排序就有两个原因更快。一是，可以很快地进行元素的读取(相对于链表，数组的元素是顺序摆放的，而链表的元素是随机摆放的)，数组的partion这步就比链表的partion这步快。二是，归并排序在merge阶段需要辅助数组，需要申请O(N)的空间，申请空间也是需要时间的。而快排不需要额外申请空间。如果待排序的元素存储在链表中，快排的优点就变成了缺点。归并排序于是就速度更优了。 方法一： 链表的归并排序，获取单链表的中点，实现对单链表先划分，便于比较归并，然后进行两个单链表的合并，最后通过进行递归的归并排序，不断的划分单链表，然后再逐一进行合并。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//1、获取单链表的中点，实现对单链表先划分，便于后面的比较归并。ListNode* getMid(ListNode *head) &#123; if (head==NULL||head-&gt;next==NULL) &#123; return head; &#125; ListNode *fast = head; ListNode *slow = head; ListNode *preEnd = NULL; while (fast!=NULL&amp;&amp;fast-&gt;next!=NULL) &#123; fast = fast-&gt;next-&gt;next; if (fast == NULL||fast-&gt;next == NULL) &#123; preEnd = slow; &#125; slow = slow-&gt;next; &#125; preEnd-&gt;next = NULL; return slow;&#125;//2、两个单链表的合并算法ListNode* mergeTwoList(ListNode *l1, ListNode *l2) &#123; ListNode newHead(-1); ListNode *newPointer = &amp;newHead; while (l1&amp;&amp;l2) &#123; if (l1-&gt;val&lt;l2-&gt;val) &#123; newPointer-&gt;next = l1; newPointer = newPointer-&gt;next; l1 = l1-&gt;next; &#125; else &#123; newPointer-&gt;next = l2; newPointer = newPointer-&gt;next; l2 = l2-&gt;next; &#125; &#125; while (l1) &#123; newPointer-&gt;next = l1; newPointer = newPointer-&gt;next; l1 = l1-&gt;next; &#125; while (l2) &#123; newPointer-&gt;next = l2; newPointer = newPointer-&gt;next; l2 = l2-&gt;next; &#125; return newHead.next;&#125;//3、进行递归的归并排序，不断的划分单链表，然后再逐一进行合并。ListNode* mergeSort(ListNode *head) &#123; if (head==NULL||head-&gt;next==NULL) &#123; return head; &#125; ListNode *nextHead = getMid(head); ListNode *l1 = mergeSort(head); ListNode *l2 = mergeSort(nextHead); ListNode *res = mergeTwoList(l1, l2); return res;&#125; 方法二： 链表的快速排序，和数组快速排序中相同，先把数据进行分块，这里利用两个指针p和q，这两个指针均往next方向移动，移动的过程中保持p之前的key都小于选定的key，p和q之间的key都大于选定的key，那么当q走到末尾的时候便完成了一次划分点的寻找。 12345678910111213141516171819202122232425262728293031323334//单链表快速排序：//分为两步，首先找到链表的分割点(即左边都比他小，右边都比它大的点)，然后以分割点为左右在进行分割，即继续调用快速排序递归函数//1、先把数据进行分块，经典划分法ListNode* getPartion(ListNode *PBegin, ListNode *PEnd) &#123; ListNode *p = PBegin; ListNode *q = PBegin-&gt;next; int valKey = PBegin-&gt;val; while (q!=PEnd) &#123; if (q-&gt;val&lt;valKey) &#123; p = p-&gt;next; swap(p-&gt;val, q-&gt;val); &#125; q = q-&gt;next; &#125; swap(PBegin-&gt;val, p-&gt;val);//把标志点交换到中间，实现左边都是比他小的，右边都是比它大的。 return p;&#125;//2、进行递归形式的对每一个块再进行分块，最后得到有序的序列。ListNode* Quicksort(ListNode *PBegin, ListNode *PEnd)&#123; if (PBegin!=PEnd) &#123; ListNode *partion = getPartion(PBegin, PEnd); Quicksort(PBegin, partion); Quicksort(partion-&gt;next, PEnd); &#125; return PBegin;&#125;ListNode* sortList(ListNode* head) &#123; return Quicksort(head，NULL);&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[147. Insertion Sort List]]></title>
    <url>%2F2017%2F08%2F23%2F147-Insertion-Sort-List%2F</url>
    <content type="text"><![CDATA[Sort a linked list using insertion sort. 题意： 使用插入排序对单链表进行排序。 思路： 在遍历每个元素过程中，遍历已排序部分进行插入。首先建立一个临时的头结点，然后循环判断传入的链表有没有取到最后一个元素，此方法的一个思路清晰点就是，（1）分别用两个指针指向原链表，一个指向待比较的元素，一个指向待比较元素的下一个元素。（2）每次从头判断已经部分有序链表，用一个指针ListNode *cur = sortedHead;记录每次都是从有序链表的头结点开始比较，且cur指针指向有序链表中待比较元素的前面，若原值比所比较的值小，则在cur指针后插入，如果不小于则cur指针向后移动。 1234567891011121314151617181920ListNode* insertionSortList(ListNode* head) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return head; &#125; ListNode *sortHead = new ListNode(-1); while (head!=NULL) &#123; ListNode *temp = head-&gt;next; ListNode *cur = sortHead; while (cur-&gt;next!=NULL&amp;&amp;cur-&gt;next-&gt;val&lt;head-&gt;val) &#123; cur = cur-&gt;next; &#125; head-&gt;next = cur-&gt;next; cur-&gt;next = head; head = temp; &#125; return sortHead-&gt;next;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[145. Binary Tree Postorder Traversal]]></title>
    <url>%2F2017%2F08%2F23%2F145-Binary-Tree-Postorder-Traversal%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the postorder traversal of its nodes’ values. 123456789For example :Given binary tree&#123; 1,#,2,3 &#125;, 1 \ 2 / 3return[3, 2, 1]. 题意： 二叉树的后续遍历。 思路： 方法一： 递归实现。 1234567891011121314class Solution&#123; vector&lt;int&gt; resVals;public: void postorderTraversal(TreeNode *root) &#123; if (!root) &#123; return; &#125; postorderTraversal(root-&gt;left);//递归调用，后序遍历左子树 postorderTraversal(root-&gt;right);//递归调用，后序遍历右子树 resVals.push_back(root-&gt;val);//遍历数据,放入结果集 &#125; &#125;; 方法二： 非递归实现，后续遍历非递归实现的一个难点，就是要有一个临时节点指针来记录右子树节点是否是被访问过的，如果右子树为空，或者被访问过，则当前节点可以进去结果集。 12345678910111213141516171819202122232425262728293031class Solution&#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; vals; if (!root) return vals; stack&lt;TreeNode*&gt; s; TreeNode *temp = root; TreeNode *preVisited = NULL;//记录被访问的右子树节点 while(temp || !s.empty()) &#123; if(temp)&#123; s.push(temp); temp = temp -&gt; left; &#125; else&#123; temp = s.top(); if(temp-&gt;right==NULL || temp-&gt;right == preVisited)&#123; vals.push_back(temp-&gt;val); preVisited = temp; s.pop(); temp = NULL; &#125; else temp = temp -&gt;right; &#125; &#125; return vals; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[144. Binary Tree Preorder Traversal]]></title>
    <url>%2F2017%2F08%2F23%2F144-Binary-Tree-Preorder-Traversal%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the preorder traversal of its nodes’ values. 123456789For example :Given binary tree&#123; 1,#,2,3 &#125;, 1 \ 2 / 3return[1, 2, 3]. 题意： 二叉树的先根序遍历。 思路： 方法一： 二叉树的先根序遍历递归实现。 12345678910111213141516171819202122struct TreeNode &#123; int val; TreeNode *left, *right; TreeNode(int x) :val(x), left(NULL), right(NULL) &#123;&#125;&#125;;//二叉树的先序遍历的递归形式//递归操作：(递归操作就像栈存储数据一样，先进后出)//思想：若二叉树为空，返回。否则 1）遍历根节点；2）先序遍历左子树；3）先序遍历右子树class Solution&#123; vector&lt;int&gt; resVals;public: void preOrderRecursive(TreeNode *root) &#123; if (!root) &#123; return; &#125; resVals.push_back(root-&gt;val);//遍历数据,放入结果集 preOrderRecursive(root-&gt;left);//递归调用，先序遍历左子树 preOrderRecursive(root-&gt;right);//递归调用，先序遍历右子树 &#125; &#125;; 方法二： 二叉树的先根序遍历非递归实现,借助栈。 1234567891011121314151617181920212223242526272829class Solution&#123;public: vector&lt;int&gt; preorderTraversal1(TreeNode* root) &#123; vector&lt;int&gt; vals; if (!root) &#123; return vals; &#125; stack&lt;TreeNode*&gt; s; TreeNode *tmp=root; while (tmp || !s.empty()) &#123; if(tmp) &#123; vals.push_back(tmp-&gt;val); s.push(tmp); tmp = tmp-&gt;left; &#125; else &#123; tmp = s.top(); s.pop(); tmp = tmp-&gt;right; &#125; &#125; return vals; &#125;&#125;；]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[143. Reorder List]]></title>
    <url>%2F2017%2F08%2F23%2F143-Reorder-List%2F</url>
    <content type="text"><![CDATA[Given a singly linked list L : L0→L1→…→Ln - 1→Ln,reorder it to : L0→Ln→L1→Ln - 1→L2→Ln - 2→… You must do this in - place without altering the nodes’ values. For example,Given{ 1,2,3,4 }, reorder it to{ 1,4,2,3 }. 题意： 给定一个单链表正常顺序，然后重新组合链表节点顺序，规则如L0→Ln→L1→Ln - 1→L2→Ln - 2→… 必须在常量空间，切不能改变节点元素值的情况下解题。 思路： 方法一： 非递归实现，先找到单链表的中点，然后断开，把后半部分逆转依次插入前半部分。 123456789101112131415161718192021222324252627282930313233//递归实现链表的反转ListNode* reverseList(ListNode *head) &#123; if (head==NULL||head-&gt;next==NULL) &#123; return head; &#125; ListNode *p = head-&gt;next; ListNode *n = reverseList(p); head-&gt;next = NULL; p-&gt;next = head; return n;&#125;void reorderList(ListNode* head) &#123; ListNode *fast = head; ListNode *slow = head; while (fast!=NULL&amp;&amp;fast-&gt;next!=NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; ListNode *lastHead = slow-&gt;next; slow-&gt;next = NULL; ListNode *n = reverseList(lastHead); while (n!=NULL) &#123; ListNode *headPre = head-&gt;next; ListNode *nPre = n-&gt;next; head-&gt;next = n; n-&gt;next = headPre; head = headPre; n = nPre; &#125;&#125; 方法二： 递归实现，利用递归来执行head指针的前进和后退，当满足条件head == mid时递归结束，head往回移动。利用forward接收后半段的头结点，然后依次向后移动取节点插入到head的后面。 123456789101112131415161718192021222324252627282930313233343536ListNode *reorderList(ListNode *head,int counts) &#123; if (head == NULL ) &#123; return NULL; &#125; if (counts==1)//count减后的值是head指针距离要断开指针的位置的大小 &#123; ListNode *temp = head-&gt;next; head-&gt;next = NULL; return temp; &#125; else if (counts==2) &#123; ListNode *temp = head-&gt;next-&gt;next; head-&gt;next-&gt;next = NULL; return temp; &#125; else &#123; ListNode *forward = reorderList(head-&gt;next, counts - 2); ListNode *temp = forward-&gt;next; forward-&gt;next = head-&gt;next; head-&gt;next = forward; return temp; &#125;&#125;void reorderList(ListNode *head) &#123; ListNode *slow = head; int counts = 0;//计算链表长 while (slow) &#123; slow = slow-&gt;next; counts++; &#125; reorderList(head,counts);&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[142. Linked List Cycle II]]></title>
    <url>%2F2017%2F08%2F23%2F142-Linked-List-Cycle-II%2F</url>
    <content type="text"><![CDATA[Given a linked list, return the node where the cycle begins.If there is no cycle, return null. Note: Do not modify the linked list. 题意： 给定一个链表，如果存在环，返回环开始的链表节点，如果不存在环返回空。注意：不要修改链表。 思路： 首先判断是否存在环，思路同141. Linked List Cycle，对单恋表快慢指针相遇后，相遇点到环起始点，以及单链表头到环起始点的距离进行总结，可以得到如下结论——相遇点到环起始点的距离和链表头到环起始点的距离相同（不带链表头结点）；相遇点到环起始点的距离和链表头到环起始点的距离相差1（带链表头结点，因为ListNode head(-1);会增加1个距离）。 123456789101112131415161718192021222324252627切记此结论是从相遇点起算起到环起始点的距离，以及快指针是慢指针的2倍移动速度。切记要是想用相等距离，一定从带链表真实值的第一个节点作为头结点。Example: 图中： X a Y b Z -------------|---------| | | |---------| c X是链表的起点。 Y是环的起点。 Z是fast和slow首次相遇的地方（二者同时从X出发，slow每次移动一步，fast每次移动两步）。 a, b, c分别表示XY（蓝色）, YZ（红色）, ZY（绿色）的长度。 当fast和slow在Z点首次相遇时： fast移动的距离是：a + b + c + b slow移动的距离是：a + b 因为fast的移动速度是slow的两倍，所以： (a + b + c + d) == 2 * (a + b) 由此可以推出： a == c 我们需要用上面的推论来寻找环的起点（Y）。 当fast和slow首次相遇时，我们就到了Z点。 由于a == c，也就是X到Y 与 Z到Y的距离相等。 因此，如果我们让指针p和q分别从X和Z出发，并且每次都移动一步，当它们相遇时，恰好就是环的起点Y。 12345678910111213141516171819202122232425ListNode* detectCycle(ListNode *head) &#123; if (head == NULL) &#123; return NULL; &#125; ListNode *fast, *slow; fast = slow = head; while (fast!=NULL&amp;&amp;fast-&gt;next!=NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; while (fast==slow) &#123; auto tempHead1 = head; auto tempHead2 = slow; while (tempHead1!=tempHead2) &#123; tempHead1 = tempHead1-&gt;next; tempHead2 = tempHead2-&gt;next; &#125; return tempHead1; &#125; &#125; return NULL;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[141. Linked List Cycle]]></title>
    <url>%2F2017%2F08%2F22%2F141-Linked-List-Cycle%2F</url>
    <content type="text"><![CDATA[141. Linked List CycleGiven a linked list, determine if it has a cycle in it. Follow up :Can you solve it without using extra space ? 题意： 给定一个链表，判断此链表是否有环，不使用额外内存空间。 思路： 定义一个快指针pre，定义一个慢指针last，遍历给定链表，快指针每次前进两步pre = pre-&gt;next-&gt;next，慢指针每次前进一步 last = last-&gt;next，当快慢指针相与时，说明链表存在环，反之不存在。 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head==NULL) return false; ListNode *pre = head, *last = head; while (pre!=NULL&amp;&amp;pre-&gt;next!=NULL) &#123; pre = pre-&gt;next-&gt;next; last = last-&gt;next; if (last == pre) &#123; return true; &#125; &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[138. Copy List with Random Pointer]]></title>
    <url>%2F2017%2F08%2F22%2F138-Copy-List-with-Random-Pointer%2F</url>
    <content type="text"><![CDATA[138. Copy List with Random PointerA linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. 题意： 给出了一个链表，每个节点包含一个额外的随机指针，它可以指向列表中的任意节点或NULL。 返回链表的深层拷贝。 思路： 如果是简单的copy List 的话，那么我们只需要从头到尾遍历下来，new出对应个数的Node，并把它们的连接关系设置好就可以了，但是这道题目中每个节点Node出现了Random属性，也就意味着可能当前结点Node所依赖的那个Random对应的结点还没有被创建出来。 主要做如下三步处理： 在OldList中的每个结点后，插入一个CopyNode，这个结点的Random域为空，Next域指向OldList节点的下一个需要复制的节点。 由于所有的CopyNode都已经创建出来了，我们就可以调整这些CopyNode真正的Random域的值了，oldItr-&gt;next-&gt;random = oldItr-&gt;random-&gt;next;。 调整所有CopyNode的Next域的值，恢复OldList所有Node的Next的值到初始状态，特别注意，要恢复原链表 图解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct RandomListNode &#123; int label; RandomListNode *next, *random; RandomListNode(int x) :label(x), next(NULL), random(NULL) &#123;&#125;&#125;;//1、构建新节点random指针：new1-&gt;random = old1-&gt;random-&gt;next, new2 -&gt; random = NULL, new3 - random = NULL, new4-&gt;random = old4-&gt;random-&gt;next////2、恢复原始链表以及构建新链表：例如old1-&gt;next = old1-&gt;next-&gt;next, new1-&gt;next = new1-&gt;next-&gt;nextRandomListNode *copyRandomList3(RandomListNode *head) &#123; if (head == NULL) &#123; return NULL; &#125; RandomListNode *p = head; //1、构造新拷贝节点的random为空，新拷贝节点插入到旧节点之后的单链表 while (p) &#123; RandomListNode *pNext = p-&gt;next; RandomListNode *q = new RandomListNode(p-&gt;label); p-&gt;next = q; q-&gt;next = pNext; p = pNext; &#125; //2、构建新节点random指针：new1-&gt;random = old1-&gt;random-&gt;next, new2 - random = NULL, new3 - random = NULL, new4-&gt;random = old4-&gt;random-&gt;next RandomListNode *oldItr = head; while (oldItr)//此处的条件判断很重要，用旧的头依次向后移动并判断 &#123; if (oldItr-&gt;random) &#123; oldItr-&gt;next-&gt;random = oldItr-&gt;random-&gt;next; &#125; oldItr = oldItr-&gt;next-&gt;next;//只要oldItr不为空，oldItr-&gt;next就不会为空，因为可定后面有复制的元素 &#125; //3、恢复原始链表以及构建新链表：例如old1-&gt;next = old1-&gt;next-&gt;next, new1-&gt;next = new1-&gt;next-&gt;next RandomListNode *newHead = head-&gt;next; RandomListNode *new2 = head-&gt;next; RandomListNode *old2 = head; while (new2-&gt;next!=NULL) &#123; old2-&gt;next = old2-&gt;next-&gt;next; old2 = old2-&gt;next; new2-&gt;next = new2-&gt;next-&gt;next; new2 = new2-&gt;next; &#125; old2-&gt;next = NULL; new2-&gt;next = NULL; return newHead;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[131. Palindrome Partitioning]]></title>
    <url>%2F2017%2F08%2F22%2F131-Palindrome-Partitioning%2F</url>
    <content type="text"><![CDATA[131. Palindrome PartitioningGiven a string s, partition s such that every substring of the partition is a palindrome.Return all possible palindrome partitioning of s. For example, given s = “aab”,Return[ [“aa”,”b”], [“a”,”a”,”b”]] 题意： 给定的字符串S，S的一个搜索子分区的分区是一个回文子串。返回所有可能的回文子串组合。 思路： 回溯递归法，因为要穷举出所有的所有的回文子串的组合，所以每层递归把当前层的回文子串放入结果集中，从下一个字符开始进入下一层，递归查找剩余子串中的回文子串组合，当递归遍历到字符串末尾的时候，说明一个回文子串组合查找完毕，放入结果集中，进行回溯递归上一层。注意：要当前层子串满足是回文串的时候才能递归进行下一层剩下字符串回文子串的查找。 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; tmp; getPartition(s, 0, tmp, res); return res; &#125;private: void getPartition(string&amp; s, int idx, vector&lt;string&gt;&amp; tmp, vector&lt;vector&lt;string&gt;&gt;&amp; res) &#123; if (idx == s.length()) &#123; res.push_back(tmp); return; &#125; for (int i = idx, n = s.length(); i &lt; n; i++) &#123; int l = idx, r = i; while (l &lt; r &amp;&amp; s[l] == s[r]) l++, r--; if (l &gt;= r) &#123;//控制满足回文子串才能进入下一层，减少递归层次，降低时间复杂度 tmp.push_back(s.substr(idx, i - idx + 1)); getPartition(s, i + 1, tmp, res); tmp.pop_back(); &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[129. Sum Root to Leaf Numbers]]></title>
    <url>%2F2017%2F08%2F21%2F129-Sum-Root-to-Leaf-Numbers%2F</url>
    <content type="text"><![CDATA[129. Sum Root to Leaf NumbersGiven a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.Find the total sum of all root-to-leaf numbers. 1234567For example, 1 / \ 2 3The root-to-leaf path 1-&gt;2 represents the number 12.The root-to-leaf path 1-&gt;3 represents the number 13.Return the sum = 12 + 13 = 25. 题意： 给定一个二叉树只包含数字0-9，根节点到每个叶节点路径可以表示一个数。例如根节点到叶节点路径路1 -&gt; 2 -&gt; 3代表数字123。求所有路径组合成的数的总和。 思路： 方法一： 层序遍历的时候只要不到叶节点，就把本节点的值乘10加到左右孩子节点上，这样每遍历一层，和就会相加一层，当是叶节点时，从根节点到本叶节点的数字也就求出来了，加到总和sum中，按队列，广度优先遍历，非递归实现。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int sumNumbers(TreeNode* root) &#123; int sum = 0; if (!root) &#123; return sum; &#125; queue&lt;TreeNode*&gt; q; q.push(root); while (!q.empty()) &#123; int levelSize = q.size(); while (levelSize &gt; 0)//控制每层，进行层序遍历 &#123; TreeNode* temp = q.front(); q.pop(); if (!temp-&gt;left&amp;&amp;!temp-&gt;right)//到达叶节点，把到叶节点的路径和加入到总sum中 &#123; sum += temp-&gt;val; &#125; if (temp-&gt;left) &#123; temp-&gt;left-&gt;val = temp-&gt;val * 10 + temp-&gt;left-&gt;val;//把本层节点值*10加入到下层左孩子节点中 q.push(temp-&gt;left); &#125; if (temp-&gt;right) &#123; temp-&gt;right-&gt;val = temp-&gt;val * 10 + temp-&gt;right-&gt;val;//把本层节点值*10加入到下层右孩子节点中 q.push(temp-&gt;right); &#125; levelSize--; &#125; &#125; return sum ; &#125;&#125;; 方法二： 递归实现，节点可能出现的情况: (1)左孩子或者右孩子两个都为NULL(叶节点)，此时递归返回。 (2)左孩子或者右孩子某一个为NULL，此时继续推进下一层调用，只是在下一层中，会发现有一个为NULL节点，走到NULL节点当然应该返回了。 (3)左孩子或者右孩子都不为NULL，此时继续推进下一层的调用。 1234567891011121314151617181920212223class Solution &#123;public: int sumVal(TreeNode* root, int sum) &#123;//sum中存的是root节点之上的所有路径节点总和 if (!root) &#123; return 0; &#125; sum = sum * 10 + root-&gt;val; if (!root-&gt;left &amp;&amp; !root-&gt;right)//到达叶子节点 &#123; return sum; &#125; return sumVal(root-&gt;left, sum) + sumVal(root-&gt;right, sum); &#125; int sumNumbers(TreeNode* root) &#123; if (!root) &#123; return 0; &#125; return sumVal(root, 0); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[125. Valid Palindrome]]></title>
    <url>%2F2017%2F08%2F21%2F125-Valid-Palindrome%2F</url>
    <content type="text"><![CDATA[125. Valid PalindromeGiven a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. For example,“A man, a plan, a canal: Panama” is a palindrome.“race a car” is not a palindrome. Note:Have you consider that the string might be empty ? This is a good question to ask during an interview.For the purpose of this problem, we define empty string as valid palindrome. 题意： 给定一个字符串，确定它是否是回文，只考虑字母数字字符和忽略空格。 思路： 利用前后两个指针，回文串肯定是关于中间对称的，所以利用前后指针遍历比较，遍历的过程中忽略空格、忽略大小写，当前指针大于后指针的时候，说明遍历结束是回文串，如果遍历过程中有一个字符不等则肯定不是回文串。 1234567891011121314151617181920212223242526272829class Solution &#123;public: bool isPalindrome(string s) &#123; int i = 0, j = s.size() - 1; while (i &lt; j) &#123; if (!isalnum(s[i])) &#123; i++; continue; &#125; if (!isalnum(s[j])) &#123; j--; continue; &#125; if (tolower(s[i]) == tolower(s[j])) &#123; i++; j--; if (i &gt; j) return true; &#125; else &#123; return false; &#125; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[124. Binary Tree Maximum Path Sum]]></title>
    <url>%2F2017%2F08%2F21%2F124-Binary-Tree-Maximum-Path-Sum%2F</url>
    <content type="text"><![CDATA[124. Binary Tree Maximum Path SumGiven a binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path does not need to go through the root. 123456For example:Given the below binary tree, 1 / \ 2 3Return 6. 题意： 给出一个二叉树，找出最大路径的总和。 对于这个问题，路径被定义为从一个起始节点到树中的任何节点沿着父子关系连接的任意序列。注意：路径不需要经过根。 思路： 主要是理解题意，就是查找从一个节点到其左右子树中最大路径值得和。 需要考虑以上两种情况： 1 左子树或者右子树中存有最大路径和不能和根节点形成一个路径 2 左子树 右子树 和根节点形成最大路径 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int maxPathSum(TreeNode* root) &#123; int maxSum = INT_MIN; getMaxPath(root, maxSum); return maxSum; &#125; int getMaxPath(TreeNode* root, int &amp;maxSum) &#123; if (!root) &#123; return 0; &#125; //左子树最大路径值(路径特点：左右节点只能选一个) int leftSum = getMaxPath(root-&gt;left, maxSum); //右子树最大路径值(路径特点：左右节点只能选一个) int rightSum = getMaxPath(root-&gt;right, maxSum); //以root节点的双侧路径((root节点以及左右子树)) int curSum = root-&gt;val; if (leftSum&gt;0) &#123; curSum += leftSum; &#125; if (rightSum&gt;0) &#123; curSum += rightSum; &#125; maxSum = max(curSum, maxSum); // 以root节点的单侧路径(root节点以及左右子树的一个)，求其中最大值 return max(root-&gt;val, max(root-&gt;val + leftSum, root-&gt;val + rightSum)); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[123. Best Time to Buy and Sell Stock III]]></title>
    <url>%2F2017%2F08%2F21%2F123-Best-Time-to-Buy-and-Sell-Stock-III%2F</url>
    <content type="text"><![CDATA[123. Best Time to Buy and Sell Stock IIISay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 题意： 一个数组第i个元素是表示股票在第i天的价格，设计一个算法找到最大的利润。可以完成两次交易，即买卖股票两次。然而，你不可以从事多个事务在同一时间（即，你必须卖出股票，在你再次购买股票前）。 思路： 方法一： 根据121. Best Time to Buy and Sell Stock的思路,构造一个从前往后买的最大收益数组，在构造一个从后往前买的最大收益数组，刚好满足两次交易。 12345678910111213141516171819不同于Best Time to Buy and Sell Stock I中定义的初始状态A[i]表示第i天卖出挣的最大数目的钱，这个更进一步直接定义A[i]表示前i天赚的最大数目的钱。minPrice表示从第0天到第i-1天中的最低价格。A[0]=0。（初始状态）A[1]=max(prices[1]-prices[0],A[0])A[2]=max(prices[2]-minPrice,A[1]).....即A[i]=max(price[i]-minPrice,A[i-1]).A[0]=0 另外一次扫描从数组后向前扫描，定义B[i]表示从第i天到最后一天n能赚的最大数目的钱。maxPrice表示第i+1天到n天的最高价格。B[n]=0。（初始状态）B[n-1]=max(maxPrice-prices[n-1],B[n])B[n-2]=max(maxPrice-prices[n-2],B[n-1]).....即B[i]=max(maxPrice-prices[i],B[i+1])B[n]=0 那么以第i天为分割点能赚的最多数目的钱为A[i]+B[i]问题的解为max&#123;A[i]+B[i]&#125;。0&lt;=i&lt;=n。时间复杂度是O(N)，空间复杂度是O(N)。 123456789101112131415161718192021222324252627282930class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0; int len = prices.size(); if (len==0) &#123; return res; &#125; int minBuyPre = prices[0]; vector&lt;int&gt; preProfit(len, 0); for (int i =1;i&lt;len;i++) &#123; minBuyPre = min(minBuyPre, prices[i]); preProfit[i] = max(prices[i] - minBuyPre, preProfit[i - 1]); &#125; int maxSailTail = prices[len-1]; vector&lt;int&gt; tailProfit(len, 0); for (int i =len-2;i&gt;=0;i--) &#123; maxSailTail = max(maxSailTail, prices[i]); tailProfit[i] = max(maxSailTail-prices[i], tailProfit[i + 1]); &#125; for (int j = 0;j&lt;len;j++) &#123; res = max(preProfit[j] + tailProfit[j], res); &#125; return res; &#125;&#125;; 方法二： 在Discuss中看到一种很棒的解法，代码只有10行左右，但是不是很好理解。 第二种解法的核心是假设手上最开始只有0元钱，那么如果买入股票的价格为price，手上的钱需要减去这个price，如果卖出股票的价格为price，手上的钱需要加上这个price。 12345678910它定义了4个状态：Buy1[i]表示前i天做第一笔交易买入股票后剩下的最多的钱；Sell1[i]表示前i天做第一笔交易卖出股票后剩下的最多的钱；Buy2[i]表示前i天做第二笔交易买入股票后剩下的最多的钱；Sell2[i]表示前i天做第二笔交易卖出股票后剩下的最多的钱；那么Sell2[i]=max&#123;Sell2[i-1],Buy2[i-1]+prices[i]&#125;Buy2[i]=max&#123;Buy2[i-1],Sell[i-1]-prices[i]&#125;Sell1[i]=max&#123;Sell[i-1],Buy1[i-1]+prices[i]&#125;Buy1[i]=max&#123;Buy[i-1],-prices[i]&#125; 可以发现上面四个状态都是只与前一个状态有关，所以可以不使用数组而是使用变量来存储即可。这是leetcode中的讨论网址：https://leetcode.com/discuss/18330/is-it-best-solution-with-o-n-o-1 1234567891011121314151617class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len = prices.size(); int buy1 = INT_MIN; int buy2 = INT_MIN; int sell1 = 0, sell2 = 0; for (int i = 0;i&lt;len;i++) &#123; sell2 = max(sell2, prices[i] + buy2); buy2 = max(buy2, sell1-prices[i]); sell1 = max(sell1, prices[i] + buy1); buy1 = max(buy1, -prices[i]); &#125; return sell2; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[122. Best Time to Buy and Sell Stock II]]></title>
    <url>%2F2017%2F08%2F21%2F122-Best-Time-to-Buy-and-Sell-Stock-II%2F</url>
    <content type="text"><![CDATA[122. Best Time to Buy and Sell Stock IISay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 题意： 一个数组第i个元素是表示股票在第i天的价格，设计一个算法找到最大的利润。可以完成多次交易，即买卖股票多次。然而，你不可以从事多个事务在同一时间（即，你必须卖出股票，在你再次购买股票前）。 思路： 方法一： 在Best Time to Buy and Sell Stock系列中，和本题最像的是[188. Best Time to Buy and Sell Stock IV ，在Best Time to Buy and Sell Stock IV中是求某个给定k次交易的最大收益，本题由于是可以操作任意次数，只为获得最大收益，而且对于一个上升子序列，比如：[5, 1, 2, 3, 4]中的1, 2, 3, 4序列来说，对于两种操作方案： 在1买入，4卖出 在1买入，2卖出同时买入，3卖出同时买入，4卖出 这两种操作下，收益是一样的。所以可以从头到尾扫描prices，如果price[i] – price[i-1]大于零则计入最后的收益中，即贪心法。 12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0; int len = prices.size(); if (len == 0) return 0; for (int i = 1; i &lt; len; i++) &#123; res += max(prices[i] - prices[i - 1], 0); &#125; return res; &#125;&#125;; 方法二： 根据[121. Best Time to Buy and Sell Stock]的思路,构建利益数组，当到某天价格减去之前购买最小值的结果大于当天利益收入时，更新最小购买值的值，寻找下次抛出的最大值，一直到最后，利用贪心的策略，即利益一旦减小，就记录利益的最大值，更新后面最小值。 12345678910111213141516171819202122232425class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res; int len = prices.size(); if (len == 0) return 0; vector&lt;int&gt; profit(len, 0); int minBuy = INT_MAX; for (int i = 0; i &lt; len; i++) &#123; minBuy = min(prices[i], minBuy); int tempVal = prices[i] - minBuy; if (tempVal &gt; profit[i]) &#123; profit[i] = tempVal; minBuy = prices[i]; &#125; &#125; for (int s : profit) &#123; res += s; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[121. Best Time to Buy and Sell Stock]]></title>
    <url>%2F2017%2F08%2F21%2F121-Best-Time-to-Buy-and-Sell-Stock%2F</url>
    <content type="text"><![CDATA[121. Best Time to Buy and Sell StockSay you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1:Input: [7, 1, 5, 3, 6, 4]Output: 5max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example 2:Input: [7, 6, 4, 3, 1]Output: 0In this case, no transaction is done, i.e. max profit = 0. 题意： 一个数组第i个元素是表示股票在第i天的价格，只允许最多完成一个交易（即买入一次股票，卖出一次股票），设计一个找到最大收益的算法。 思路： 方法一： 典型动态规划题，动态规划的思想重要一点就是利用以前已经计算出来的值，重点不在递归上，而在于重复利用之前计算的值，减少计算量，提高效率，递归是辅助计算工具。 这题的主要思路就是把每天的收益减去之前的最小买入的值，然后存在一个当天收益的数组中，更新数组中的值得时候要比较当天减去最小买入收益值与之前的收益大小，存入收益最大值,然后取出最大值就是股票最大收益。 12345678910111213141516171819class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len = prices.size(); if (len==0) &#123; return 0; &#125; vector&lt;int&gt; profit(len,0); int minBuy = prices[0]; for (int i = 1; i &lt; len; i++) &#123; minBuy = min(minBuy, prices[i]); profit[i] = max(profit[i - 1], prices[i] - minBuy); &#125; return profit[len-1]; &#125;&#125;; 方法二： 同方法一，但是不用收益数组来记录最大收益，而是利用临时变量来记录，当收益大时，直接更新临时变量，最后临时变量中存储的就是收益最大值。 12345678910111213141516171819class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len = prices.size(); if (len == 0) &#123; return 0; &#125; int maxRes = 0; int minBuy = prices[0]; for (int i = 0; i &lt; len; i++) &#123; minBuy = min(minBuy, prices[i]); maxRes = max(maxRes, prices[i] - minBuy); &#125; return maxRes; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[120. Triangle]]></title>
    <url>%2F2017%2F08%2F19%2F120-Triangle%2F</url>
    <content type="text"><![CDATA[120. TriangleGiven a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. 12345678For example, given the following triangle[ [2], [3,4], [6,5,7], [4,1,8,3]]The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note:Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. 题意： 给定一个三角形，找到从上到下的最小路径求和。每一步你可以移动到下面一行相邻的数字**，特别注意是相邻的数字。 只用O（n）额外的空间来做，其中n是三角形中的总行数。 思路： 从三角形的底部往顶部走进行遍历，一次查找最小元素，这样当查找本行的最小和时，只需与下一行相邻元素相加的和进行比较求出最小和。 这道题最主要需要学的地方就是换角度思考问题，把上到的下的查找转换为下到上的查找，从而降低代码逻辑难度。 123456789101112131415161718192021class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; int m = triangle.size(); if (m == 0) return 0; int n = triangle[0].size(); if (n == 0) return 0; vector&lt;int&gt; minSum(triangle[m - 1]); for (int i = m - 2; i &gt;= 0; i--) &#123; for (int j =0;j&lt;triangle[i].size();j++) &#123; minSum[j] = min(minSum[j], minSum[j + 1]) + triangle[i][j]; &#125; &#125; return minSum[0]; &#125;&#125;; 下面是从上往下遍历三角形的过程中，求出当前行每个元素与上层元素相加的最小和，要考虑的边界问题相对较多，代码繁琐。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; /*[ [2], [3, 4], [6, 5, 7], [4, 1, 8, 3] ]*/ int m = triangle.size(); if (m == 0) return 0; int n = triangle[0].size(); if (n == 0) return 0; if (m == 1 &amp;&amp; n == 1) return triangle[0][0]; int sum = INT_MAX; for (int i =1;i&lt;m;i++) &#123; int col = triangle[i].size(); for (int j = 0;j&lt;col;j++) &#123; if (j==0) &#123; triangle[i][j] += triangle[i - 1][j]; if (i==m-1) &#123; sum = min(sum, triangle[i][j]); &#125; &#125; else if (j==col - 1) &#123; triangle[i][j] += triangle[i - 1][j - 1]; if (i == m - 1) &#123; sum = min(sum, triangle[i][j]); &#125; &#125; else &#123; triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1]); if (i == m - 1) &#123; sum = min(sum, triangle[i][j]); &#125; &#125; &#125; &#125; return sum; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[119. Pascal's Triangle II]]></title>
    <url>%2F2017%2F08%2F19%2F119-Pascal-s-Triangle-II%2F</url>
    <content type="text"><![CDATA[119. Pascal’s Triangle IIGiven an index k, return the kth row of the Pascal’s triangle. For example, given k = 3,Return [1,3,3,1]. Note:Could you optimize your algorithm to use only O(k) extra space? 题意： 给定一个索引K，返回的第k行杨辉三角形的值。 思路： 思路同118. Pascal’s Triangle，利用上一行三角形的值构造下一行，但是此题是只需要第k行的值，所以不用建造二维数组浪费空间，只需要用以为数组，通过记录上一行的值，然后从后往前遍历记录值，构造下一行值，其中有一点注意在遍历上行值求本行值的时候，本行因为比上一行多一个元素，所以索引也应该从比上一行元素值多一个的索引处开始，然后往前遍历求本行值。 利用每一行多出来的最后的位置开始来累加值，从后往前遍历结果数组的方法和思想很值得借鉴,而且代码看起来很简洁。 123456789101112131415class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; res(rowIndex+1,0); res[0] = 1; for (int i =1;i&lt;=rowIndex;i++) &#123; for (int j =i;j&gt;=1;j--) &#123; res[j] += res[j - 1]; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[118. Pascal's Triangle]]></title>
    <url>%2F2017%2F08%2F18%2F118-Pascal-s-Triangle%2F</url>
    <content type="text"><![CDATA[118. Pascal’s TriangleGiven numRows, generate the first numRows of Pascal’s triangle. For example, given numRows = 5,Return [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 题意： 给定一个行数numrows，产生相应行数的Pascal三角形。 思路： 根据杨辉三角规律，通过上述例子也可以找到规律，从第三行开始，每行除了第一个和最后一个是1外，其他元素等于上一行对应两个元素的和，比如第 i 行 j 列（i &gt; 1 &amp;&amp; j &gt; 0）,res[i][j] = res[ i - 1 ][ j ] + res[i - 1][ j - 1 ]。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; res; for (int i =0;i&lt;numRows;i++) &#123; vector&lt;int&gt; temp(i+1); if (i==0) &#123; temp[0] = 1; res.push_back(temp); &#125; else if (i==1) &#123; temp[0] = 1; temp[i] = 1; res.push_back(temp); &#125; else &#123; temp[0] = 1; for (int j = 1;j&lt;i;j++) &#123; temp[j] = res[i - 1][j - 1] + res[i - 1][j]; &#125; temp[i] = 1; res.push_back(temp); &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[117. Populating Next Right Pointers in Each Node II]]></title>
    <url>%2F2017%2F08%2F18%2F117-Populating-Next-Right-Pointers-in-Each-Node-II%2F</url>
    <content type="text"><![CDATA[117. Populating Next Right Pointers in Each Node IIFollow up for problem “Populating Next Right Pointers in Each Node”.What if the given tree could be any binary tree? Would your previous solution still work? Note: You may only use constant extra space. 12345678910111213For example,Given the following binary tree, 1 / \ 2 3 / \ \4 5 7After calling your function, the tree should look like: 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ \4-&gt; 5 -&gt; 7 -&gt; NULL 题意： 题意同116. Populating Next Right Pointers in Each Node，题目做了一些更改：就是树不一定是满二叉树。 思路： 思路同116. Populating Next Right Pointers in Each Node，解法的核心：递推思想依然不需要改变，依然是依据当前层的next 指针，设置下一层的 next 指针。只是找结点麻烦些，我们定义了两个函数，findNextLevelNextNode(root, curNode)用来找(n+1)层的下一个节点，findNextLevelStartNode(root)用来找下一层的起始节点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (!root) &#123; return; &#125; while (root) &#123; TreeLinkNode* startNode = findNextLevelStartNode(root);//寻找下一层的第一个节点 TreeLinkNode* curNode = startNode; TreeLinkNode* nextNode = findNextLevelNextNode(root, curNode);//寻找下一层的next节点 while (nextNode) &#123; curNode-&gt;next = nextNode; curNode = nextNode; nextNode = findNextLevelNextNode(root, curNode); &#125; root = startNode; &#125; &#125; TreeLinkNode* findNextLevelStartNode(TreeLinkNode* curRoot) &#123; if (!curRoot) &#123; return NULL; &#125; if (curRoot-&gt;left) &#123; return curRoot-&gt;left; &#125; return findNextLevelNextNode(curRoot, curRoot-&gt;left); &#125; TreeLinkNode* findNextLevelNextNode(TreeLinkNode* curRoot,TreeLinkNode* curNode) &#123; if (curRoot-&gt;left==curNode&amp;&amp;curRoot-&gt;right) &#123; return curRoot-&gt;right; &#125; else &#123; while (curRoot-&gt;next) &#123; curRoot = curRoot-&gt;next; if (curRoot-&gt;left&amp;&amp;curRoot-&gt;left!=curNode) &#123; return curRoot-&gt;left; &#125; if (curRoot-&gt;right&amp;&amp;curRoot-&gt;right != curNode) &#123; return curRoot-&gt;right; &#125; &#125; &#125; return NULL; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[116. Populating Next Right Pointers in Each Node]]></title>
    <url>%2F2017%2F08%2F17%2F116-Populating-Next-Right-Pointers-in-Each-Node%2F</url>
    <content type="text"><![CDATA[116. Populating Next Right Pointers in Each NodeGiven a binary tree ​ struct TreeLinkNode {​ TreeLinkNode left;​ TreeLinkNode right;​ TreeLinkNode *next;​ }Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space.​ You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children). 12345678910111213For example,Given the following perfect binary tree, 1 / \ 2 3 / \ / \ 4 5 6 7After calling your function, the tree should look like: 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ / \ 4-&gt;5-&gt;6-&gt;7 -&gt; NULL 题意： 给定一个二叉树，填充每个节点的next针指向它的下一个右节点。如果没有下一个右节点，则next指针应设置为null。 最初，所有next指针都设置为null。 注意： 只能使用常量内存空间。 你可以假设它是一个完全二叉树（即所有叶子都在同一层，而且每个父母都有两个孩子）。（完全二叉树降低题目难度）。 思路： 这道题之所以放上来是因为题目中的那句话：You may only use constant extra space 这就意味着，深搜是不能用的，因为递归是需要栈的，因此空间复杂度将是 O(logn)。毫无疑问广搜也不能用，因为队列也是占用空间的，空间占用还高于 O(logn)，难就难在这里，深搜和广搜都不能用。但是核心仍然是广搜，可以借用 next 指针，做到不需要队列就能完成广度搜索。 如果当前层所有结点的next 指针已经设置好了，那么据此，下一层所有结点的next指针也可以依次被设置。 1234567891011121314151617181920212223class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (!root) &#123; return; &#125; while (root-&gt;left)//注意这个地方是root的左子树不能为空，如果左子树为空表明下一层不存在节点，则构造结束 &#123; TreeLinkNode* tempRoot = root; while (tempRoot) &#123; tempRoot-&gt;left-&gt;next = tempRoot-&gt;right; if (tempRoot-&gt;next) &#123; tempRoot-&gt;right-&gt;next = tempRoot-&gt;next-&gt;left; &#125; tempRoot = tempRoot-&gt;next; &#125; root = root-&gt;left; &#125; &#125; &#125;; 引申：要连接的二叉树不是一颗完全二叉树题117. Populating Next Right Pointers in Each Node II]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[115. Distinct Subsequences]]></title>
    <url>%2F2017%2F08%2F16%2F115-Distinct-Subsequences%2F</url>
    <content type="text"><![CDATA[115. Distinct SubsequencesGiven a string S and a string T, count the number of distinct subsequences of T in S. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not). Here is an example:S = “rabbbit”, T = “rabbit” Return 3. 题意： 给定一个字符串S和字符串T，统计不同的子序列T的在S中出现的数量。 字符串的子序列是一个新字符串，它从原始字符串中形成，通过删除一些（可以是没有）字符而不干扰其余字符的相对位置。（例如“ACE”是“ABCDE”的一个子序列，而“AEC”不是）。 思路： 题目给定两个字符串，选择只可以用删除字符的方法从第一个字符串变换到第二个字符串，求出一共有多少种变换方法；动态规划思想应用的典型题目。 123456789101112定义二维数组dp[i][j]为s[0, i)中包含多少个值为t[0, j)的子序列。先考虑几个基本情况： （1）对于dp[0][0]： 此时s[0, 0)和t[0, 0)都是空串，我们可以说前者是包含一个值为空串的子序列的，因此dp[0][0] = 1。 （2）对于dp[0][j] (j &gt;= 1)： s[0, 0)是空串，而t[0, j)不是空串，因此前者不可能含有值为后者的子序列。此时，dp[0][j] = 0。 （3）对于dp[i][0] (i &gt;= 1)： s[0, i)不是空串，而t[0, 0)是空串，我们认为前者包含一个值为空串的子序列。因此，dp[i][0] = 1。 （4）对于dp[i][j] (i &gt;= 1 and j &gt;= 1)： 如果s[i - 1] == t[j - 1]，那么：dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]。意思是：如果当前S[i]==T[j]，那么当前这个字母即可以保留也可以抛弃，所以变换方法等于保留这个字母的变换方法加上不用这个字母的变换方法。 如果二者不等，那么：dp[i][j] = dp[i - 1][j]。意思是：如果当前字符不等，那么就只能抛弃当前这个字符。 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int numDistinct(string s, string t) &#123; if (s.empty()) &#123; return 0; &#125; int sLen = s.size(); int tLen = t.size(); if (sLen&lt;tLen) &#123; return 0; &#125; vector&lt;vector&lt;int&gt;&gt; dp(sLen + 1, vector&lt;int&gt;(tLen + 1, 0)); for (int i=0;i&lt;sLen+1;i++) &#123; dp[i][0] = 1; &#125; for (int i =1;i&lt;sLen+1;i++) &#123; for (int j = 1;j&lt;tLen+1;j++) &#123; if (s[i - 1] == t[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; &#125; else dp[i][j] = dp[i - 1][j - 1]; &#125; &#125; return dp[sLen][tLen]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[114. Flatten Binary Tree to Linked List]]></title>
    <url>%2F2017%2F08%2F16%2F114-Flatten-Binary-Tree-to-Linked-List%2F</url>
    <content type="text"><![CDATA[114. Flatten Binary Tree to Linked ListGiven a binary tree, flatten it to a linked list in-place. 1234567891011121314151617181920For example,Given 1 / \ 2 5 / \ \ 3 4 6The flattened tree should look like: 1 \ 2 \ 3 \ 4 \ 5 \ 6 题意： 给定一个二叉树，在常量空间内把它转换为一个链表。 思路： 方法一： 在遍历的过程中，逐渐把根节点的左子树转换为右子树，并且右子树放到左子树的最右面的叶子节点后面，使根节点的左子树为空，然后继续循环遍历以右子树为下一个根节点，循环上面的思路，直到右子树为空。 123456789101112131415161718192021222324class Solution &#123;public: void flatten(TreeNode* root) &#123; if (!root || (!root-&gt;left &amp;&amp; !root-&gt;right)) &#123; return; &#125; while (root)//循环直到root为空 &#123; if (root-&gt;left) &#123; TreeNode *pre = root-&gt;left; while (pre-&gt;right)//寻找左子树的最右叶子节点 &#123; pre = pre-&gt;right; &#125; pre-&gt;right = root-&gt;right;//把根节点的右子树放到左子树的最右叶子节点的右子节点上 root-&gt;right = root-&gt;left;//把根节点的右子树转换为左子树 root-&gt;left = NULL;//左子树置为空 &#125; root = root-&gt;right; &#125; &#125;&#125;; 方法二： 因为最后flatten的结果是树的前序遍历的结果，所以考虑一边进行前序遍历，一边进行flatten转化。逻辑很重要，在while循环体中，应该先把curNode-&gt;right, curNode-&gt;left压栈，再去进行flatten。如果颠倒了顺序，就会在flatten时破坏一些还没有被处理的节点，这些节点被压栈，随后就会发生错误。 1234567891011121314151617181920212223242526272829class Solution &#123;public: void flatten(TreeNode* root) &#123; if (!root || (!root-&gt;left &amp;&amp; !root-&gt;right)) &#123; return; &#125; stack&lt;TreeNode*&gt; s; TreeNode *temp = root; TreeNode *curNode = NULL; s.push(temp); while (!s.empty()) &#123; curNode = s.top(); s.pop(); if (curNode-&gt;right)//注意先放进去右子节点 &#123; s.push(curNode-&gt;right); &#125; if (curNode-&gt;left)//后方左子节点，这样出站的时候就会先出栈左子树节点做为右子树节点 &#123; s.push(curNode-&gt;left); &#125; temp-&gt;right = curNode;//temp代表上层根节点 temp-&gt;left = NULL; temp = curNode; &#125; &#125;&#125;; 方法三： 最简单的思路，时间复杂度高一些，直接进行先根序遍历，然后把这些节点存储在节点数组中，左后遍历数组中每一个节点，使其左子树节点置为空，右子树节点为数组下一个节点。 1234567891011121314151617181920212223242526272829303132class Solution &#123;private: vector&lt;TreeNode*&gt; res;public: void flatten(TreeNode* root) &#123; if (!root||(!root-&gt;left&amp;&amp;!root-&gt;right)) &#123; return; &#125; stack&lt;TreeNode*&gt; s; TreeNode* temp = root; while (temp || !s.empty()) &#123; if (temp) &#123; res.push_back(temp); s.push(temp); temp = temp-&gt;left; &#125; else &#123; temp = s.top()-&gt;right; s.pop(); &#125; &#125; for (int i = 0; i &lt; res.size() - 1; i++) &#123; res[i]-&gt;left = NULL; res[i]-&gt;right = res[i + 1]; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[113. Path Sum II]]></title>
    <url>%2F2017%2F08%2F16%2F113-Path-Sum-II%2F</url>
    <content type="text"><![CDATA[113. Path Sum IIGiven a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. 1234567891011121314For example:Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1return[ [5,4,11,2], [5,8,4,5]] 题意： 给定一个二叉树和一个目标和，找出所有的根到叶的路径，使每个路径的总和等于给定的和。 思路： 思路同112. Path Sum都是遍历跟到叶节点的路径，不同点是112. Path Sum只要找到一条满足的路径和就行，而此题要求找出所有的路径和等于目标和的路径元素集合。 方法一： 递归求解，如果root是叶节点，并且它的值恰好等于sum，直接返回root的值。否则，从root的子树中去找一条到叶节点的路径，且这条路径上的节点的和等于(sum － root-&gt;val)。然后我们把root加到这条路径里，就是符合题目要求的一条完整路径。 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; if (!root) return res; pathSumVec(root, path, res, sum); return res; &#125; void pathSumVec(TreeNode* root, vector&lt;int&gt; path, vector&lt;vector&lt;int&gt;&gt; &amp;pathSum, int sum) &#123; if (!root) return; path.push_back(root-&gt;val); if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; if (sum == root-&gt;val) &#123; pathSum.push_back(path); &#125; &#125; pathSumVec(root-&gt;left, path, pathSum, sum - root-&gt;val); pathSumVec(root-&gt;right, path, pathSum, sum - root-&gt;val); &#125;&#125;; 方法二： DFS的递归求和，然后到跟节点后和目标值比较，而不是像上面的方法，是把和减去键值，和叶节点的值进行比较。 如果root为空，直接返回空数组，否则调用pathSumVec函数。pathSumVec函数将传入的root节点值压入path数组，更新当前数组path的和值nowSum，如果root为叶子节点，且path数组和为target，则将path数组压入pathSum。对于左子树结点，递归调用pathSumVec(root-&gt;left, path, pathSum, sum,nowSum);，对于右子结点，递归调用 pathSumVec(root-&gt;right, path, pathSum, sum,nowSum);。请注意，path数组不能传入引用参数，应该传入形参。每个递归函数在运行过程中对path数组的操作都是各自为政，互不干涉的。 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; if (!root) return res; int nowSum = 0;//一个变量记录路径和，不像方法一中通过sum减去节点值记录 pathSumVec(root, path, res, sum,nowSum); return res; &#125; void pathSumVec(TreeNode* root, vector&lt;int&gt; path, vector&lt;vector&lt;int&gt;&gt; &amp;pathSum, int sum,int nowSum) &#123; if (!root) return; nowSum += root-&gt;val; path.push_back(root-&gt;val); if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; if (sum == nowSum) &#123; pathSum.push_back(path); &#125; &#125; pathSumVec(root-&gt;left, path, pathSum, sum,nowSum); pathSumVec(root-&gt;right, path, pathSum, sum,nowSum); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[112. Path Sum]]></title>
    <url>%2F2017%2F08%2F15%2F112-Path-Sum%2F</url>
    <content type="text"><![CDATA[112. Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. 12345678910For example:Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. 题意： 给定一个二叉树和一个和，确定树是否有根节点到叶节点的路径，这样路径上元素累加和等于给定的和。 思路： 方法一： 递归的遍历二叉树，当遇到叶子节点(!root-&gt;left &amp;&amp; !root-&gt;right)时，说明找到一条路径，存储路径节点值，把所有路径都找出来，然后相加比较，时间复杂度高，但是此处的递归查找路径上的元素的方法值得学习。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if (!root) return false; vector&lt;vector&lt;int&gt;&gt; path; vector&lt;int&gt; pathNum; pathNum.push_back(root-&gt;val); getPath(path, pathNum, root); for (auto s : path)//遍历所有路径，求路径元素和 &#123; //cout &lt;&lt; s.size()&lt;&lt;endl; int sumVal = 0; for (int val : s) &#123; sumVal += val; &#125; if (sumVal==sum) &#123; return true; &#125; &#125; return false; &#125; void getPath(vector&lt;vector&lt;int&gt;&gt; &amp;path, vector&lt;int&gt; pathNum, TreeNode* root) &#123; if (!root-&gt;left &amp;&amp; !root-&gt;right)//到达叶子节点 &#123; // pathNum.push_back(root-&gt;val); path.push_back(pathNum);//记录加入路径元素 return; &#125; if (root-&gt;left)//此节点左子树存在，则递归进入左子树，直到遇见根节点 &#123; pathNum.push_back(root-&gt;left-&gt;val); getPath(path, pathNum, root-&gt;left); pathNum.pop_back();//当一直到叶子节点返回，要把上一个路径叶节点元素弹出路径集合 &#125; if (root-&gt;right)//此节点右子树存在，则递归进入右子树，直到遇见根节点 &#123; pathNum.push_back(root-&gt;right-&gt;val); getPath(path, pathNum, root-&gt;right); pathNum.pop_back();//当一直到叶子节点返回，要把上一个路径叶节点元素弹出路径集合 &#125; &#125;&#125;; 方法二： 递归过程中直接判断，遍历从根到叶子的每一条路径，并求和。只要相等，就返回true，否则一直遍历下去，最后返回false。与方法一的区别就是不用再记录路径元素，而是直接遍历的过程中求和比较。 123456789101112131415161718192021222324252627class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if (!root) return false; return getPathSum(root-&gt;val,root,sum); &#125; bool getPathSum(int pathSum,TreeNode* root,int sum) &#123; if (!root-&gt;left &amp;&amp; !root-&gt;right)//到达叶子节点 &#123; if (pathSum==sum) &#123; return true; &#125; &#125; bool lp = false, rp = false; if (root-&gt;left)//左子树为着，递归遍历左子树，遍历过程中求和 &#123; lp = getPathSum(pathSum + root-&gt;left-&gt;val, root-&gt;left, sum); &#125; if (root-&gt;right) &#123; rp = getPathSum(pathSum + root-&gt;right-&gt;val, root-&gt;right, sum); &#125; return (lp || rp);//左右子树有一个和满足就可以 &#125;&#125;; 方法三： 思路同方法二，但是不是通过累加树节点到叶节点求和，而是每层递归的时候，把和减去当前层节点值，然后进入下一层，如果sum减到叶节点的时候，等于叶节点的值，则存在目标和为sum的路径，否则没有，这种目标值反向相减再比较的思路值得学习。 12345678910111213141516class Solution4 &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if (!root) return false; if (!root-&gt;left&amp;&amp;!root-&gt;right) &#123; if (root-&gt;val == sum) &#123; return true; &#125; &#125; return hasPathSum(root-&gt;left, sum-root-&gt;val)||hasPathSum(root-&gt;right,sum-root-&gt;val); &#125; &#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[111. Minimum Depth of Binary Tree]]></title>
    <url>%2F2017%2F08%2F15%2F111-Minimum-Depth-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[111. Minimum Depth of Binary TreeGiven a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. 题意： 给定一个二叉树，找出它的最小深度。 最小深度是从根节点到最近叶节点的最短路径上的节点数。 思路： 同样采用递归的思想，同求树高不同之处在于：找最小距离要注意(l&lt;r)? l+1:r+1的区别应用，当根节点为空，返回0，当根节点为唯一的二叉树节点时，返回1；否则，求解并返回 最小(非空，保证最终到达叶节点)左右子树深度 + 1； 1234567891011121314class Solution &#123;public: int minDepth(TreeNode* root) &#123; if (!root) return 0; int ld = minDepth(root-&gt;left); int rd = minDepth(root-&gt;right); if (ld == 0)//肯定最低的子树先到叶子节点，先等于0 return rd + 1; if (rd == 0) return ld + 1; return (ld&gt;rd ? rd : ld) + 1;//返回最小高度加1 &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[110. Balanced Binary Tree]]></title>
    <url>%2F2017%2F08%2F15%2F110-Balanced-Binary-Tree%2F</url>
    <content type="text"><![CDATA[110. Balanced Binary TreeGiven a binary tree, determine if it is height - balanced. For this problem, a height - balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 题意： 给定一棵二叉树，确定它是否是高度平衡树。 一个高度非平衡二叉树定义为一个二叉树的深度的两个子树节点不会相差超过1。 思路： 主要思想就是递归求树高，然后遍历所有树节点求树高，根据返回的左右子树的高度去判断子树高度相差是否大于1，大于1则不是高度平衡树。有两种方式判读，第一种是每遍历一个节点都求一回树高，在循环遍历里面比较左右子树高度，直到叶子节点，这种时间复杂度相对高些；第二种在递归求树高的递归函数中进行比较左右子树高度，一旦出现高度差大于1，直接返回，减少递归和遍历次数，时间复杂度低。 方法一： 上述第一种思路： 1234567891011121314151617181920212223242526class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; if (!root) &#123; return true; &#125; int leftDepth = depth(root-&gt;left); int rigthDepth = depth(root-&gt;right); if (abs(leftDepth - rigthDepth) &gt; 1)//递归遍历每一个节点的过程中判断是否平衡 &#123; return false; &#125; return isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);//递归遍历所有节点 &#125; int depth(TreeNode* root) &#123; if (!root) &#123; return 0; &#125; int l = depth(root-&gt;left); int r = depth(root-&gt;right); return (l &gt; r ? l : r) + 1; &#125;&#125;; 方法二： 上述第二种思路： 1234567891011121314151617181920212223242526272829303132333435//不在isBalanced()函数里面递归的判断是否平衡，在递归求树的高度的时候就进行判断class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; if (!root) &#123; return true; &#125; int leftDepth = depth(root-&gt;left);//求根节点的左子树树高 int rigthDepth = depth(root-&gt;right);//求根节点的右子树树高 //如果左右子树有不平衡的地方则返回-1 if (leftDepth&lt;0 || rigthDepth&lt;0 || abs(leftDepth-rigthDepth)&gt;1)//最后的绝对值与1相比是比较根节点的左右子树 &#123; return false; &#125; return true; &#125; int depth(TreeNode* root) &#123; if (!root) &#123; return 0; &#125; int l = depth(root-&gt;left); int r = depth(root-&gt;right); if (l&lt;0 || r&lt;0 || abs(l-r)&gt;1)//递归求树高的过程中进行判断是否平衡 &#123; return -1; &#125; else &#123; return (l &gt; r ? l : r) + 1; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[109. Convert Sorted List to Binary Search Tree]]></title>
    <url>%2F2017%2F08%2F15%2F109-Convert-Sorted-List-to-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[109. Convert Sorted List to Binary Search TreeGiven a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. 题意： 给定一个单项升序链表，把其转换成二叉搜索树。 思路： 思想同108. Convert Sorted Array to Binary Search Tree找中点，构造根节点，但是此处是找链表的中点节点构造二叉搜索树的根节点，所以不能像数组一样可以直接控制中间节点的索引，应该通过链表中间节点，和最后一个节点， 方法一： 下面方法的巧妙之处就是把链表最后一个节点的下一个节点做为尾节点，即NULL，或者递归过程中的mid节点，这样可以避免查找中间节点的前一个节点，来断开与右子树对应的后半段链表。 12345678910111213141516171819202122232425262728class Solution &#123;public: TreeNode *sortedListToBST(ListNode *head) &#123; return sortedListToBST( head, NULL );//此处尾节点设为NULL &#125;private: TreeNode *sortedListToBST(ListNode *head, ListNode *tail) &#123; if( head == tail ) return NULL; if( head-&gt;next == tail ) &#123; TreeNode *root = new TreeNode( head-&gt;val ); return root; &#125; ListNode *mid = head, *temp = head; while( temp != tail &amp;&amp; temp-&gt;next != tail ) // 寻找中间节点，不是判断！=NULL，而是判断!= tail，可以很好的控制来查找左右子树对应的链表的中间节点 &#123; mid = mid-&gt;next; temp = temp-&gt;next-&gt;next; &#125; TreeNode *root = new TreeNode( mid-&gt;val ); root-&gt;left = sortedListToBST( head, mid );//左子树对应链表的尾节点设为mid，相当于替换NULL，因为mid节点已经构造了树节点 root-&gt;right = sortedListToBST( mid-&gt;next, tail ); return root; &#125;&#125;; 方法二： 通过查找链表中间节点的过程中，返回链表中间节点的前一个节点，便于对应左右子树的子链表断开。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: ListNode* getMidNode(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode *fast = head; ListNode *slow = head; ListNode *slowPre = head; while(fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next) &#123; slowPre = slow; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return slowPre; &#125; TreeNode* createBST(ListNode* head) &#123; if(!head) return NULL; ListNode *midPre = getMidNode(head); ListNode *mid = midPre-&gt;next; if(mid) &#123; TreeNode *root = new TreeNode(mid-&gt;val); midPre-&gt;next = NULL; TreeNode *left = createBST(head); TreeNode *right = createBST(mid-&gt;next); root-&gt;left = left; root-&gt;right = right; return root; &#125; else return new TreeNode(head-&gt;val); &#125; TreeNode* sortedListToBST(ListNode* head) &#123; if(!head) return NULL; return createBST(head); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[108. Convert Sorted Array to Binary Search Tree]]></title>
    <url>%2F2017%2F08%2F14%2F108-Convert-Sorted-Array-to-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[108. Convert Sorted Array to Binary Search TreeGiven an array where elements are sorted in ascending order, convert it to a height balanced BST. 题意： 给定一个数组，其中的元素按升序排序，将它转换成一个高度平衡的二分搜索树。 思路： 给定一个区间[left, right]，取其中值mid=(left+right)/2对应的元素作为二叉树的根，左子树为[left, mid-1]，右子树为[mid+1,right]，递归的创建左右子树。 1234567891011121314151617181920212223class Solution &#123;public: TreeNode* arrayToBST(vector&lt;int&gt;&amp; nums, int left, int right) &#123; if (left&gt;right) &#123; return NULL; &#125; if (left == right) &#123; return new TreeNode(nums[left]); &#125; else &#123; int mid = (left + right) / 2; TreeNode *root = new TreeNode(nums[mid]); root-&gt;left = arrayToBST(nums, left, mid - 1); root-&gt;right = arrayToBST(nums, mid + 1, right); return root; &#125; &#125; TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; return arrayToBST(nums, 0, nums.size() - 1); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[107. Binary Tree Level Order Traversal II]]></title>
    <url>%2F2017%2F08%2F14%2F107-Binary-Tree-Level-Order-Traversal-II%2F</url>
    <content type="text"><![CDATA[107. Binary Tree Level Order Traversal IIGiven a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). 1234567891011121314For example:Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7return its bottom-up level order traversal as:[ [15,7], [9,20], [3]] 题意： 给定一个二叉树，返回它的自底向上，从叶子节点到根节点的层序遍历的节点值。（从左到右，从叶到根逐层地遍历）。 思路： 方法一： 按102. Binary Tree Level Order Traversal的层序遍历思想，把重上到下顺序得到的数组反转，非递归实现： 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if (!root) &#123; return res; &#125; vector&lt;vector&lt;int&gt;&gt; tempRes; queue&lt;TreeNode*&gt; q1; q1.push(root); while (!q1.empty()) &#123; queue&lt;TreeNode*&gt; q2; vector&lt;int&gt; nums; while (!q1.empty()) &#123; TreeNode *temp = q1.front(); nums.push_back(temp-&gt;val); q1.pop(); if (temp-&gt;left) q2.push(temp-&gt;left); if (temp-&gt;right) q2.push(temp-&gt;right); &#125; tempRes.push_back(nums); q1 = q2; &#125; //对层次遍历结果进行翻转 for (int i = tempRes.size()-1;i&gt;=0;i--) &#123; res.push_back(tempRes[i]); &#125; return res; &#125;&#125;; 方法二： 递归进行层次遍历，并将每个level对应于相应的vector。 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; void getLevelNums(TreeNode* root, int level) &#123; if (!root) &#123; return; &#125; if (level == res.size()) &#123; vector&lt;int&gt; num; res.push_back(num); &#125; res[level].push_back(root-&gt;val); getLevelNums(root-&gt;left, level + 1); getLevelNums(root-&gt;right, level + 1); &#125; vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; if (!root) &#123; return res; &#125; getLevelNums(root, 0); reverse(res.begin(), res.end()); return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[106. Construct Binary Tree from Inorder and Postorder Traversal]]></title>
    <url>%2F2017%2F08%2F14%2F106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal%2F</url>
    <content type="text"><![CDATA[106. Construct Binary Tree from Inorder and Postorder TraversalGiven inorder and postorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. 题意： 给定一个中序和后序遍历序列，构建一个二叉树。 注意：二叉树中元素无重复元素。 思路： 后序遍历中根的顺序是从后往前的，后序遍历最后一个元素是根结点（k），因此遍历后序数组时，应当从后往前搜索，在中序遍历序列中找值为k的下标idx，idx将中序遍历序列分成左右子树，可进行递归操作，后序遍历时先经过右子树的根再经过左子树的根。因此，递归时先递归遍历右子树，再递归遍历左子树。最后把得到的两个子树接到当前的根结点上。 1234567891011121314 1 / \ 2 3 / \ / \ 4 5 6 7对于上图的树来说， index: 0 1 2 3 4 5 6 中序遍历为: 4 2 5 1 6 3 7 后续遍历为: 4 5 2 6 7 3 1可以发现的规律是：1. 中序遍历中根节点是左子树右子树的分割点。2. 后续遍历的最后一个节点为根节点。同样根据中序遍历找到根节点的位置，然后顺势计算出左子树串的长度。在后序遍历中分割出左子树串和右子树串，递归的建立左子树和右子树。 1234567891011121314151617181920212223242526272829303132class Solution &#123; unordered_map&lt;int, int&gt; inorderHash;//声明为类的私有变量，类方法都可以使用，不用形参复制传递，避免造成超时现象public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; if (inorder.empty()||postorder.empty()) &#123; return NULL; &#125; //unordered_map&lt;int, int&gt; inorderHash;//把这个映射表放在函数内，以形参的形式复制传递会造成内存泄漏，造成//Status: Time Limit Exceeded for (int i = 0;i&lt;inorder.size();i++) &#123; inorderHash[inorder[i]] = i; &#125; return createTree(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1); &#125; TreeNode* createTree(vector&lt;int&gt;&amp; inorder, int inStartIndex, int inEndIndex, vector&lt;int&gt;&amp; postorder, int postStartIndex, int postEndIndex) &#123; if (inStartIndex &gt; inEndIndex || postStartIndex &gt; postEndIndex) &#123; return NULL; &#125; TreeNode* root = new TreeNode(postorder[postEndIndex]); int partition = inorderHash[postorder[postEndIndex]]; int len = partition - inStartIndex; TreeNode* left = createTree(inorder, inStartIndex,partition - 1, postorder, postStartIndex, postStartIndex + len - 1); TreeNode* right = createTree(inorder, partition + 1, inEndIndex, postorder, postStartIndex + len, postEndIndex - 1); root-&gt;left = left; root-&gt;right = right; return root; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[105. Construct Binary Tree from Preorder and Inorder Traversal]]></title>
    <url>%2F2017%2F08%2F14%2F105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal%2F</url>
    <content type="text"><![CDATA[105. Construct Binary Tree from Preorder and Inorder TraversalGiven preorder and inorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. 题意： 给定一个先序和中序遍历序列，构建一个二叉树。 注意：二叉树中元素无重复元素。 思路： 参照106. Construct Binary Tree from Inorder and Postorder Traversal构造树的思想，先序遍历中根的顺序是从前往后的，先序遍历第一个元素是根结点（k），在中序遍历序列中找值为k的下标idx，idx将中序遍历序列分成左右子树，可进行递归操作。 123456789101112131415 1 / \ 2 3 / \ / \ 4 5 6 7对于上图的树来说 index: 0 1 2 3 4 5 6 中序遍历为: 4 2 5 1 6 3 7 先续遍历为: 1 2 4 5 3 6 7 可以发现的规律是：1. 中序遍历中根节点是左子树右子树的分割点。2. 先续遍历的第一个节点为根节点。同样根据中序遍历找到根节点的位置，然后顺势计算出左子树串的长度。在先序遍历中分割出左子树串和右子树串，递归的建立左子树和右子树。 1234567891011121314151617181920212223class Solution &#123; unordered_map&lt;int, int&gt; hash;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; if (preorder.empty() || inorder.empty()) return NULL; for (int i = 0; i&lt;inorder.size(); i++) hash[inorder[i]] = i; return createTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1); &#125; TreeNode* createTree(vector&lt;int&gt;&amp; preorder, int preBeg, int preEnd, vector&lt;int&gt;&amp; inorder, int inBeg, int inEnd) &#123; if (preBeg&gt;preEnd || inBeg&gt;inEnd) return NULL; TreeNode *root = new TreeNode(preorder[preBeg]); int partition = hash[preorder[preBeg]]; int len = inEnd - partition; TreeNode *right = createTree(preorder, preEnd - len + 1, preEnd, inorder, partition + 1, inEnd); TreeNode *left = createTree(preorder, preBeg + 1, preEnd - len, inorder, inBeg, partition - 1); root-&gt;left = left; root-&gt;right = right; return root; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[104. Maximum Depth of Binary Tree]]></title>
    <url>%2F2017%2F08%2F14%2F104-Maximum-Depth-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[104. Maximum Depth of Binary TreeGiven a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 题意： 给定一个二叉树，求其最大深度。 最大深度是从根节点到最远叶节点的最长路径上的节点数。 思路： 方法一： 递归实现，利用二叉树的递归求二叉树树高： 1234567891011121314class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if (!root) &#123; return 0; &#125; else &#123; int dl = maxDepth(root-&gt;left); int dr = maxDepth(root-&gt;right); return (dl &gt; dr ? dl : dr) + 1; &#125; &#125;&#125;; 方法二： 利用二叉树的非递归层序遍历求树高： 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if (!root) &#123; return 0; &#125; int depth = 0; queue&lt;TreeNode*&gt; q1; q1.push(root); while (!q1.empty()) &#123; queue&lt;TreeNode*&gt; q2; while (!q1.empty()) &#123; TreeNode *tp = q1.front(); if (tp-&gt;left) &#123; q2.push(tp-&gt;left); &#125; if (tp-&gt;right) &#123; q2.push(tp-&gt;right); &#125; q1.pop(); &#125; depth++; q1 = q2; &#125; return depth; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[103. Binary Tree Zigzag Level Order Traversal]]></title>
    <url>%2F2017%2F08%2F14%2F103-Binary-Tree-Zigzag-Level-Order-Traversal%2F</url>
    <content type="text"><![CDATA[103. Binary Tree Zigzag Level Order TraversalGiven a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between). For example :Given binary tree[3, 9, 20, null, null, 15, 7], 1234567891011 3 / \ 9 20 / \15 7return its zigzag level order traversal as :[ [3], [20, 9], [15, 7]] 题意： 给定一个二叉树，返回其节点值的锯齿级顺序遍历。（从左到右，从右到左为下一层，在两层间交替从左到右或者从右到左的顺序）。 思路： 利用两个队列实现二叉树的层序遍历，遍历的结果值在把偶数层的值反转，假设根节点是第一层 ，掌握其中的层序遍历 方法以及102. Binary Tree Level Order Traversal的层序遍历方法。 1234567891011121314151617181920212223242526272829303132333435vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if (!root) &#123; return res; &#125; queue&lt;TreeNode*&gt; q1; q1.push(root); while (!q1.empty()) &#123; queue&lt;TreeNode*&gt; q2; vector&lt;int&gt; tempRes; while (!q1.empty()) &#123; TreeNode *temp = q1.front(); tempRes.push_back(temp-&gt;val); if (temp-&gt;left) &#123; q2.push(temp-&gt;left); &#125; if (temp-&gt;right) &#123; q2.push(temp-&gt;right); &#125; q1.pop(); &#125; q1 = q2; res.push_back(tempRes); &#125; for (int i=1;i&lt;res.size();i+=2) &#123; reverse(res[i].begin(), res[i].end()); &#125; return res;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ const 用法]]></title>
    <url>%2F2017%2F08%2F13%2FConst-Relate-Quesions%2F</url>
    <content type="text"><![CDATA[C++ const 用法 关于指针，主要注意四个方面：指针类型、指针指向类型、指针的值、指针指向的值。当const修饰的是指针类型，那么指针的值就不能改变，即不能指向其他内存空间，但是可以通过指针修改其指向内存空间里面的值。当const修饰是指针指向的内存空间时，那么指针可以指向其他内存空间，但是不能通过指针修改指针所指向内存空间里面的值。 C++ const 允许指定一个语义约束，编译器会强制实施这个约束，允许程序员告诉编译器某值是保持不变的。如果在编程中确实有某个值保持不变，就应该明确使用const，这样可以获得编译器的帮助。 1.const 修饰成员变量1234567891011121314#include&lt;iostream&gt;using namespace std;int main()&#123; int a1=3; ///non-const data const int a2=a1; ///const data int * a3 = &amp;a1; ///non-const data,non-const pointer const int * a4 = &amp;a1; ///const data,non-const pointer int * const a5 = &amp;a1; ///non-const data,const pointer int const * const a6 = &amp;a1; ///const data,const pointer const int * const a7 = &amp;a1; ///const data,const pointer return 0;&#125; const修饰指针变量时： (1)只有一个const，如果const位于*左侧，表示指针所指数据（所指内存空间）是常量，不能通过解引用修改该数据；指针本身是变量，可以指向其他的内存单元。 (2)只有一个const，如果const位于*右侧，表示指针本身是常量，不能指向其他内存空间；指针所指的数据可以通过解引用修改。 (3)两个const，*左右各一个，表示指针和指针所指数据（所指内存地址数据）都不能修改。 2.const修饰函数参数 传递过来的参数在函数内不可以改变，与上面修饰变量时的性质一样。 123void testModifyConst(const int x) &#123; x=5; ///编译出错&#125; 3.const修饰成员函数 (1) const修饰的成员函数不能修改任何的成员变量(mutable修饰的变量除外) mutable：在C++中，mutable是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中，甚至结构体变量或者类对象为const，其mutable成员也可以被修改。 12345678struct ST &#123; int a; mutable int b; &#125;; const ST st=&#123;1,2&#125;; st.a=11;//编译错误 st.b=22;//允许 (2) const成员函数不能调用非onst成员函数，因为非const成员函数可以会修改成员变量 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;class Point&#123; public : Point(int _x):x(_x)&#123;&#125; void testConstFunction(int _x) const&#123; ///错误，在const成员函数中，不能修改任何类成员变量 x=_x; ///错误，const成员函数不能调用非onst成员函数，因为非const成员函数可以会修改成员变量 modify_x(_x); &#125; void modify_x(int _x)&#123; x=_x; &#125; int x;&#125;; 4.const修饰函数返回值(1)指针传递 如果返回const data,non-const pointer，返回值也必须赋给const data,non-const pointer。因为指针指向的数据(内存空间里面的值)是常量不能修改。 1234567891011const int * mallocA()&#123; ///const data,non-const pointer int *a=new int(2); return a;&#125;int main()&#123; const int *a = mallocA(); ///int *b = mallocA(); ///编译错误 return 0;&#125; (2)值传递 如果函数返回值采用“值传递方式”，由于函数会把返回值复制到外部临时的存储单元中，加const 修饰没有任何价值。所以，对于值传递来说，加const没有太多意义。 所以： 不要把函数int GetInt(void) 写成const int GetInt(void)。 不要把函数A GetA(void) 写成const A GetA(void)，其中A 为用户自定义的数据类型。 在编程中如果确定不变的常量值，要尽可能多的使用const，这样可以获得编译器的帮助，以便写出健壮性的代码。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[102. Binary Tree Level Order Traversal]]></title>
    <url>%2F2017%2F08%2F12%2F102-Binary-Tree-Level-Order-Traversal%2F</url>
    <content type="text"><![CDATA[102. Binary Tree Level Order TraversalGiven a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example:Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its level order traversal as:[ [3], [9,20], [15,7]] 题意： 层序遍历二叉树。 思路： 二叉树的层序遍历主要是利用队列来实现，在遍历每一层进行输出结果时可以用两种方式进行控制，一种是利用第二临时队列存储下一层元素，在输出完本层元素后，把这个临时队列再赋值给之前那个队列，有队列赋值操作，效率低。 第二种，利用队列的大小来控制层的输出，不用用第二个临时队列来存储下层元素，在遍历下层元素的同时可以直接把此元素放入之前的队列中，代码如下： 12345678910111213141516171819202122232425262728class Solution2 &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty())&#123; int levelSize = q.size(); vector&lt;int&gt; level; while(levelSize&gt;0)&#123;//利用本层元素个数控制本层元素的输出 TreeNode *temp = q.front(); q.pop(); level.push_back(temp-&gt;val); if(temp-&gt;left) q.push(temp-&gt;left); if(temp-&gt;right) q.push(temp-&gt;right); levelSize--; &#125; res.push_back(level); //q1 = q2;减少队列的赋值操作 &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[101. Symmetric Tree]]></title>
    <url>%2F2017%2F08%2F12%2F101-Symmetric-Tree%2F</url>
    <content type="text"><![CDATA[101. Symmetric TreeGiven a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric:But the following [1,2,2,null,3,null,3] is not:Note:Bonus points if you could solve it both recursively and iteratively. 题意： 给定一个二叉树，检查它是否是自身的镜像（即围绕其中心轴对称）。 思路： 方法一： 递归实现，思路比较简练，只要注意控制好递归结束的条件： 1.停止条件是 left\==NULL &amp;&amp; right==NULL return true; 2.停止条件是 left!=NULL || right != NULL return false; 3.left-&gt;val == right-&gt;val 比较left-&gt;left和right.right &amp;&amp; left-&gt;right和right-&gt;left; 4.任何条件不成立都是false; 12345678910111213141516171819202122class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if (!root) &#123; return true; &#125; return isLeftAndRightSymmetric(root-&gt;left, root-&gt;right); &#125; bool isLeftAndRightSymmetric(TreeNode* left, TreeNode* right) &#123; if (!left &amp;&amp; !right) &#123; return true; &#125; else if (!left || !right) return false; else if (left-&gt;val != right-&gt;val) return false; return isLeftAndRightSymmetric(left-&gt;left, right-&gt;right) &amp;&amp; isLeftAndRightSymmetric(left-&gt;right, right-&gt;left); &#125;&#125;; 方法二： 非递归两个队列实现，层序遍历的左右队列中左右子树进行相互比较，两个队列，分别存储每一层根节点的下一层的左右子树，右左子树： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if (!root) &#123; return true; &#125; queue&lt;TreeNode*&gt; q1, q2; q1.push(root-&gt;left); q2.push(root-&gt;right); while (!q1.empty()&amp;&amp;!q2.empty()) &#123; TreeNode* q1Node = q1.front(); q1.pop(); TreeNode* q2Node = q2.front(); q2.pop(); if (!q1Node &amp;&amp; !q2Node) continue; else if (!q1Node || !q2Node) &#123; return false; &#125; else if (q1Node-&gt;val!=q2Node-&gt;val) &#123; return false; &#125; else &#123; q1.push(q1Node-&gt;left);//注意两个队列放入节点顺序q1是先left再right q1.push(q1Node-&gt;right); q2.push(q2Node-&gt;right);//注意两个队列放入节点顺序q2是先right再left q2.push(q2Node-&gt;left); &#125; &#125; return true; &#125;&#125;; 方法三： 非递栈实现，用一个栈来实现，要注意进栈时的左右子树节点进栈的顺序。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if (!root) &#123; return true; &#125; stack&lt;TreeNode*&gt; s; s.push(root-&gt;left); s.push(root-&gt;right); while (!s.empty()) &#123; TreeNode* sANode = s.top(); s.pop(); TreeNode* sBNode = s.top(); s.pop(); if (!sANode &amp;&amp; !sBNode) continue; else if (!sANode || !sBNode) &#123; return false; &#125; else if (sANode-&gt;val != sBNode-&gt;val) &#123; return false; &#125; else &#123; s.push(sANode-&gt;left);//先放sANode-&gt;left s.push(sBNode-&gt;right);//再放sBNode-&gt;right s.push(sANode-&gt;right);//先放sANode-&gt;right s.push(sBNode-&gt;left);//再放sBNode-&gt;left &#125; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100. Same Tree]]></title>
    <url>%2F2017%2F08%2F12%2F100-Same-Tree%2F</url>
    <content type="text"><![CDATA[100. Same TreeGiven two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 题意： 给定两个二叉树，编写一个函数检查它们是否相等。二叉树相同要求他们的树结构相同，节点中的值也相同。 思路： 方法一： 先遍历的变形，同时先序遍历两个树结构，非递归实现： 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; stack&lt;TreeNode*&gt; ps; stack&lt;TreeNode*&gt; qs; TreeNode *temp = p; TreeNode *temq = q; if ((temp == NULL&amp;&amp;temq != NULL) || (temp != NULL&amp;&amp;temq == NULL)) return false; while ((temp || !ps.empty())&amp;&amp;(temq || !qs.empty())) &#123; if ((temp == NULL&amp;&amp;temq != NULL) || (temp != NULL&amp;&amp;temq == NULL)) return false; if (temp&amp;&amp;temq) &#123; if (temp-&gt;val!=temq-&gt;val) &#123; return false; &#125; ps.push(temp); qs.push(temq); temp = temp-&gt;left; temq = temq-&gt;left; &#125; else &#123; temp = ps.top()-&gt;right; ps.pop(); temq = qs.top()-&gt;right; qs.pop(); &#125; &#125; return true; &#125;&#125;; 方法二： 先遍历的变形，同时先序遍历两个树结构，递归实现： 123456789101112131415161718class Solution &#123;public: bool isSameTree(TreeNode *p, TreeNode *q) &#123; if(!p &amp;&amp; !q) return true; else if(!p &amp;&amp; q) return false; else if(p &amp;&amp; !q) return false; else &#123; if(p-&gt;val != q-&gt;val) return false; else return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[99. Recover Binary Search Tree]]></title>
    <url>%2F2017%2F08%2F12%2F99-Recover-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[99. Recover Binary Search TreeTwo elements of a binary search tree(BST) are swapped by mistake.Recover the tree without changing its structure. Note:A solution using O(n) space is pretty straight forward.Could you devise a constant space solution ? 题意： 二叉搜索树（BST）的两个元素被错误地交换，希望在不改树变结构的情况下恢复二叉搜索树。 注意：使用O（n）空间的解相当直接，你能设计出一个常数空间解吗？ 思路： 方法一： 非递归的中序遍历： 中序遍历二叉树，出现的节点的值会升序排序，如果有两个节点位置错了，那肯定会出现降序。 设置一个pre节点指针，记录当前节点中序遍历时的前节点，如果当前节点小于pre节点的值，说明需要调整次序。 如果在中序遍历时节点值出现了两次降序，第一个错误的节点为第一次降序时较大的节点，第二个错误节点为第二次降序时较小的节点。 比如，原来的搜索二叉树在中序遍历的节点值依次为{1,2,3,4,5}，如果因为两个节点位置错了而出现{1,5,3,4,2}， 第一次降序为5-&gt;3，所以第一个错误节点为5，第二次降序为4-&gt;2,所以第二个错误节点为2，将5和2换过来就可以恢复。 切记要求空间复杂度为常数，不是O(n) 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public: void recoverTree(TreeNode* root) &#123; TreeNode* misNode1 = NULL; TreeNode* misNode2 = NULL; TreeNode* pre = NULL; stack&lt;TreeNode*&gt; s; TreeNode* temp = root; while (temp || !s.empty()) &#123; if (temp) &#123; s.push(temp); temp = temp-&gt;left; &#125; else &#123; temp = s.top(); s.pop(); //cout &lt;&lt; temp-&gt;val &lt;&lt; endl; if (pre) &#123; if (pre-&gt;val &gt; temp-&gt;val) &#123; if (!misNode1)//此处misNode1为空，说明找到第一个错误节点 &#123; misNode1 = pre; misNode2 = temp;//在 找到第一个错误节点时，把其相邻节点设置为错误节点2，是为了控制处理两个错误节点相邻的情况 &#125; else misNode2 = temp; &#125; &#125; pre = temp; temp = temp-&gt;right; &#125; &#125; swap(misNode1-&gt;val, misNode2-&gt;val); &#125;&#125;; 方法二： 递归的中序遍历： 如果把这棵二叉搜索树各结点的值用中序遍历的方式打印出来，那么就有一个位置上的数大于它后面相邻的数，之后又有一个位置上的数小于它前面相邻的数。这两个数正好相邻的情况再考虑。 只需先找出那个大于它后一个数的数misNode1，再找出那个小于它前一个数的数misNode2，之后再交换两者的值就行了。要实现这一点，我们需要保存前一个结点pre，然后找到pre-&gt;val &gt; cur-&gt;val这种反常的情况（共两次）。此时，若misNode1已经被找到了，让misNode1= pre，此时也设置misNode2 = cur。 接下来考虑两个数相邻的情况。由于两个数相邻，我们只能找到一次 pre-&gt;val &gt; cur-&gt;val 的情况，无法对misNode2进行赋值。但我们注意到，此时cur刚好就是我们要找的misNode2。再回到一般情况，就算此时的cur不是我们要找的misNode2，我们在后面第二次出现pre-&gt;val &gt; cur-&gt;val的情况时，我们依旧会对misNode2赋值。所以，我们在第一次遇到pre-&gt;val &gt; cur-&gt;val的情况时，分别将pre和cur赋值给misNode1和misNode2，在后面如果再次遇到pre-&gt;val &gt; cur-&gt;val的情况，我们再将misNode2修改为正确的值，并保持misNode1的值不变。这样，我们总能找到正确的misNode2和misNode2。 12345678910111213141516171819202122232425262728293031323334class Solution2 &#123; TreeNode* misNode1; TreeNode* misNode2; TreeNode* pre;public: void recoverTree(TreeNode* root) &#123; misNode1 = misNode2 = pre = NULL;//pre必须设为null，通过遍历的时候设进去。因为是中序遍历，所以pre应该是深层叶子左子树的父节点。 inOrderFindNode(root); swap(misNode1-&gt;val, misNode2-&gt;val); &#125; void inOrderFindNode(TreeNode* root)//递归中序遍历 &#123; if (!root) &#123; return; &#125; inOrderFindNode(root-&gt;left); if (pre)//当前驱结点不为空的时候再进行比较 &#123; if (pre-&gt;val&gt;root-&gt;val) &#123; if (!misNode1) &#123; misNode1 = pre; misNode2 = root; &#125; else misNode2 = root; &#125; &#125; pre = root; inOrderFindNode(root-&gt;right); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[98. Validate Binary Search Tree]]></title>
    <url>%2F2017%2F08%2F12%2F98-Validate-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[98. Validate Binary Search TreeGiven a binary tree, determine if it is a valid binary search tree (BST).Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Example 1: 2 / \ 1 3Binary tree [2,1,3], return true. Example 2: 1 / \ 2 3Binary tree [1,2,3], return false. 题意： 给定一个二叉树，确定它是否是一个有效的二叉搜索树（BST）。 假设BST定义如下： 节点的左子树只包含小于该节点键的节点。 节点的右子树只包含大于节点键的键的节点。 根节点的左、右子树也必须是二叉搜索树。 思路： 方法一： 参照99. Recover Binary Search Tree的思路，一边中序遍历二叉搜索树，一边进行判断，用一个指针记录前一个节点的值，因为中序遍历的二分查找树所得到的序列是递增序列，所以非递归实现如下： 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; if (!root) return true; bool flag = true; TreeNode* pre = NULL; TreeNode* temp = root; stack&lt;TreeNode*&gt; s; //中序遍历的二分查找树所得到的序列是递增序列 while (temp || !s.empty()) &#123; if (temp) &#123; s.push(temp); temp = temp-&gt;left; &#125; else &#123; temp = s.top(); s.pop(); if (pre) &#123; if (pre-&gt;val &gt;= temp-&gt;val) flag = false; &#125; pre = temp; temp = temp-&gt;right; &#125; &#125; return flag; &#125;&#125;; 方法二： 递归先序遍历实现： 12345678910111213141516171819202122232425262728293031class Solution &#123; TreeNode* pre; bool flag;public: bool isValidBST(TreeNode* root) &#123; if (!root) return true; flag = true; TreeNode* pre = NULL; inOrderFindNode(root); return flag; &#125; void inOrderFindNode(TreeNode* root) &#123; if (!root) &#123; return; &#125; inOrderFindNode(root-&gt;left); //cout &lt;&lt; root-&gt;val &lt;&lt; endl; if (pre)//当前驱结点不为空的时候再进行比较 &#123; if (pre-&gt;val &gt;= root-&gt;val) &#123; flag = false; &#125; &#125; pre = root; inOrderFindNode(root-&gt;right); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[97. Interleaving String]]></title>
    <url>%2F2017%2F08%2F11%2F97-Interleaving-String%2F</url>
    <content type="text"><![CDATA[97. Interleaving StringGiven s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. For example,Given:s1 = “aabcc”,s2 = “dbbca”, When s3 = “aadbbcbcac”, return true.When s3 = “aadbbbaccc”, return false. 题意： 给定S1、S2、S3，确定是否由S1和S2交织形成S3。 思路： 动态规划的思想，分解成小问题，s3[0,i+j]的字符与s1[0,i],s2[0,j]匹配，s3[0,i+j+1]的状态取决于s3[i+j+1] 与 s1[i+1]或者s2[0,j+1]是否匹配 12345设dp[i][j]，表示s1[0,i-1]和s2[0,j-1]交替组成s3[0, i+j-1]。//dp[i][j]就表示s1的前i个和s2的前j个是否和s3的前i+j个匹配如果s1[i-1]等于s3[i+j-1]，则dp[i][j]=dp[i-1][j]如果s2[j-1]等于s3[i+j-1]，则dp[i][j]=dp[i][j-1]因此状态转移方程如下：dp[i][j] = dp[i-1][j] &amp;&amp; (s1[i-1] == s3[i+j-1]) || dp[i][j-1] &amp;&amp; (s2[j-1] == s3[i+j-1]) 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; int s1Len = s1.size(), s2Len = s2.size(), s3Len = s3.size(); if (s3Len != s2Len + s1Len) &#123; return false; &#125; else if (s1Len == 0 &amp;&amp; s2Len == 0 &amp;&amp; s3Len == 0) return true; else if (s1[0] != s3[0] &amp;&amp; s2[0] != s3[0]) return false; //vector&lt;vector&lt;bool&gt;&gt; dp(s1Len + 1, vector&lt;bool&gt;(s2Len + 1, false));//这样造成效率低 vector&lt;vector&lt;int&gt;&gt; dp(s1Len + 1, vector&lt;int&gt;(s2Len + 1, 0)); dp[0][0] = 1; for (int i = 1; i &lt;= s1Len; i++) &#123; dp[i][0] = (s1[i - 1] == s3[i - 1]) &amp;&amp; dp[i - 1][0]; &#125; for (int j = 1; j &lt;= s2Len; j++) &#123; dp[0][j] = (s2[j - 1] == s3[j - 1]) &amp;&amp; dp[0][j - 1]; &#125; for (int i = 1; i &lt;= s1Len; i++) &#123; for (int j = 1; j &lt;= s2Len; j++) &#123; int k = i + j; dp[i][j] = (s1[i - 1] == s3[k - 1]) &amp;&amp; dp[i - 1][j] || (s2[j - 1] == s3[k - 1]) &amp;&amp; dp[i][j - 1]; &#125; &#125; return dp[s1Len][s2Len]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[96. Unique Binary Search Trees]]></title>
    <url>%2F2017%2F08%2F11%2F96-Unique-Binary-Search-Trees%2F</url>
    <content type="text"><![CDATA[96. Unique Binary Search TreesGiven n, how many structurally unique BST’s (binary search trees) that store values 1…n? For example,Given n = 3, there are a total of 5 unique BST’s. 题意： 给定一个整数n，计算可以生成多少个结构不同的的BST（二分搜索树），存储值为1…n。 思路： 分析：本题其实关键是递推过程的分析，n个点中每个点都可以作为root，当 i 作为root时，小于 i 的点都只能放在其左子树中，大于 i 的点只能放在右子树中，此时只需求出左、右子树各有多少种，二者相乘即为以 i 作为root时BST的总数。 递归过程中存在大量的重复计算，会超时，从n一层层往下递归，故考虑类似于动态规划的思想，让底层的计算结果能够被重复利用，故用一个数组存储中间计算结果（即 1~n-1 对应的BST数目），这样只需双层循环即可. 解题思路： 学数据结构的时候，曾学过不同构的二叉树的种数为卡特兰数，其通项公式如下： 123//卡特兰数通项公式 C0 = 1;Cn+1 = Ci*Cn-i(i=0到n的所有乘积的和) 从求解子问题的角度来看本题： 选取一个结点为根，就把结点切成左右子树 以这个结点为根的可行二叉树数量就是左右子树可行二叉树数量的乘积 所以总的数量是将以所有结点为根的可行结果累加起来。也就是上述公式。具体解法：从C2开始求解，直到Cn，求解过的数依次存储在数组中，以备求解其后的元素使用。若使用递归，求解速度较慢。 时间上每次求解i个结点的二叉查找树数量的需要一个i步的循环，总体要求n次，所以总时间复杂度是O(1+2+…+n)=O(n^2)。空间上需要一个数组来维护，并且需要前i个的所有信息，所以是O(n)。 12345678910111213141516class Solution &#123;public: int numTrees(int n) &#123; vector&lt;int&gt; res(n+1,0); res[0] = 1; res[1] = 1; for (int i =2;i&lt;=n;i++)//i表示树的所有节点数，从2到n &#123; for (int j = 0; j &lt; i;j++)//j表示一个树种左子树的节点个数,肯定小于此棵树的所有节点数 &#123; res[i] += res[j] * res[i - j - 1];//左子树可以构成的二叉搜索树数量*右子树可以构成的二叉搜索树数量 &#125; &#125; return res[n]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[95. Unique Binary Search Trees II]]></title>
    <url>%2F2017%2F08%2F11%2F95-Unique-Binary-Search-Trees-II%2F</url>
    <content type="text"><![CDATA[95. Unique Binary Search Trees IIGiven an integer n, generate all structurally unique BST’s (binary search trees) that store values 1…n. For example,Given n = 3, your program should return all 5 unique BST’s shown below. 题意： 给定一个整数n，生成所有结构不同的的BST（二分搜索树），存储值为1…n。 思路： 这题是 96 Unique Binary Search Trees 的延展，它已经不是让求不同构二叉树的种数，而是直接给出这些不同构的二叉树。 每一次都在一个范围内随机选取一个结点作为根。 每选取一个结点作为根，就把树切分成左右两个子树，直至该结点左右子树为空。 大致思路如上，可以看出这也是一个可以划分成子问题求解的题目，所以考点是动态规划。 但具体对于本题来说，采取的是自底向上的求解过程。 选出根结点后应该先分别求解该根的左右子树集合，也就是根的左子树有若干种，它们组成左子树集合，根的右子树有若干种，它们组成右子树集合。 然后将左右子树相互配对，每一个左子树都与所有右子树匹配，每一个右子树都与所有的左子树匹配。然后将两个子树插在根结点上。 最后，把根结点放入链表中。 由于1~n是升序列，因此建起来的树天然就是BST。 递归思想，依次选择根节点，对左右子序列再分别建树。 由于左右子序列建树的结果也可能不止一种，需要考虑所有搭配情况。 vector left代表所有valid左子树。 vector right代表所有valid右子树。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;TreeNode*&gt; generateTrees(int n) &#123; vector&lt;TreeNode*&gt; res; res = createTrees(1, n); return res; &#125; vector&lt;TreeNode*&gt; createTrees(int begin, int end) &#123; vector&lt;TreeNode*&gt; res; if (begin &gt; end) res.push_back(NULL); if (begin==end) &#123; res.push_back(new TreeNode(begin)); &#125; else &#123; for (int i = begin;i&lt;=end;i++) &#123; vector&lt;TreeNode*&gt; leftTree = createTrees(begin, i - 1);//左子树集合 vector&lt;TreeNode*&gt; rightTree = createTrees(i+1, end);//右子树集合 for (int l = 0;l&lt;leftTree.size();l++) &#123; for (int r = 0;r&lt;rightTree.size();r++) &#123; TreeNode* root = new TreeNode(i);//根据本层i创建根节点 root-&gt;left = leftTree[l]; root-&gt;right = rightTree[r]; res.push_back(root); &#125; &#125; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[94. Binary Tree Inorder Traversal]]></title>
    <url>%2F2017%2F08%2F11%2F94-Binary-Tree-Inorder-Traversal%2F</url>
    <content type="text"><![CDATA[94. Binary Tree Inorder TraversalGiven a binary tree, return the inorder traversal of its nodes’ values. For example :Given binary tree[1, null, 2, 3], 1 \ 2 / 3return[1, 3, 2] 题意： 给定一个二叉树，实现二叉树的中序遍历的节点值。 思路： 方法一： 非递归实现。 12345678910111213141516171819202122232425262728293031struct TreeNode &#123; int val; TreeNode *left, *right; TreeNode(int x) :val(x), left(NULL), right(NULL) &#123;&#125;&#125;;//非递归实现vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; vals; stack&lt;TreeNode*&gt; s; if (!root) &#123; return vals; &#125; TreeNode *temp = root; while (temp||s.empty()) &#123; if (temp) &#123; s.push(temp); temp = temp-&gt;left; &#125; else &#123; temp = s.top(); vals.push_back(temp-&gt;val); s.pop(); temp = temp-&gt;right; &#125; &#125; return vals;&#125; 方法二： 递归实现。 12345678910111213class Solution&#123; vector&lt;int&gt; res; public: void inOrderTraversal(TreeNode *root) &#123; if (root==NULL) &#123; return; &#125; inOrderTraversal(root-&gt;left);//递归调用，中序遍历左子树 res.push_back(root-&gt;val);//输出数据 inOrderTraversal(root-&gt;right); //递归调用，中序遍历右子树 &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[93. Restore IP Addresses]]></title>
    <url>%2F2017%2F08%2F11%2F93-Restore-IP-Addresses%2F</url>
    <content type="text"><![CDATA[93. Restore IP AddressesGiven a string containing only digits, restore it by returning all possible valid IP address combinations. For example:Given “25525511135”, return [“255.255.11.135”, “255.255.111.35”]. (Order does not matter) 题意： 给定一个只包含数字的字符串，返回所有可能的有效IP地址组合。 思路： 方法一： IP地址的三种分类：A类地址：10.0.0.0～10.255.255.255 B类地址：172.16.0.0～172.31.255.255 C类地址：192.168.0.0～192.168.255.255 这道题的主要思路是分治，将问题的规模不断缩小。回溯中好多的题目都是使用这个思想来解题的。IP地址被三个”.”分割成了4个部分，这里我把每一个部分叫做一个段，依次为第0段，第1段，第2段，第3段。 下面以25525511135为例来分析。考虑第0段可能的取值，由于每一个段可以包含1位，2位或3位，那么第0段可能的取值是： 2 25 255 第0段取值以后后面的字符串需要被分割成3段，那么后面的字符能否被分割成3段呢？ 第0段取上面的值后，剩余的部分依次为： 5525511135 ，字符串的长度为10，而3段最长也只能为9，所以第0段取2时没有对应的有效ip地址。 525511135 ，这里字符串的长度为9，即这个字符串还可能被分割成有效的3段。 25511135 ，这里字符串的长度为8，即这个字符串还可能被分割成有效的3段。 然后再对525511135和25511135求分割成3段的方法。这里问题规模就缩小了。需要被分割的段由4段变成了3了，字符串的长度也变短了。递归退出的条件是遍历到字符串尾端并且字符串被分割成了4段。 几点注意的地方： 1. 如果一个段包含3个字符，那么这三个字符不能大于”255”,这是ip地址的基本知识 2. 如果一个字符包括2个或3个字符，它的第一个字符不能为0，即在验证字符串是否是数字的时候，要注意0的情况，001，010，03都是非法的。所以，如果第一位取出来是0，那么我们就判断字符串是否是&quot;0&quot;，不是的情况都是非法的 3. 取字符串的时候，注意位数不够的问题，不仅&lt;4, 而且&lt;s.length() 4. 注意截取子串substring的范围 5. 不能忘记IP地址里面的 &quot;.&quot; 6. 到第4个Part的时候我们就可以整体验证剩下的所有字符串（因为第4个Part最后一定要取到结尾才是正确的字符串） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; vector&lt;string&gt; res; if (s.size()==0||s.size()&gt;12||s.size()&lt;4) &#123; return res; &#125; getIpAddress(s, "", res, 0); return res; &#125; void getIpAddress(string s, string temp, vector&lt;string&gt; &amp;res, int count) &#123; if (count==3) &#123; if (isValidIp(s)) &#123; res.push_back(temp + s); return; &#125; else return; &#125; for (int i = 1;i&lt;4&amp;&amp;i&lt;s.size();i++)//少限制条件i&lt;s.size()特例 Last executed input : "1111" &#123; string str = s.substr(0, i); if (isValidIp(str))//递归回溯前先判断，进行剪枝 &#123; getIpAddress(s.substr(i), temp + str + '.', res, count + 1); &#125; &#125; &#125; bool isValidIp(string s) &#123; if (s[0]=='0')//判断首位为0的话是否合法 &#123; return s.size() == 1; &#125; else &#123; int num = atoi(s.c_str()); if (num &lt;= 255) &#123; return true; &#125; else return false; &#125; &#125;&#125;; 方法二： 循环迭代求解，三重循环，遍历三个小数点的位置，对每个位置check一下即可。 注意： stoi函数默认要求输入的参数字符串是符合int范围的[-2147483648, 2147483647]，否则会runtime error。 atoi函数则不做范围检查，若超过int范围，则显示-2147483648（溢出下界）或者2147483647（溢出上界）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; vector&lt;string&gt; res; if (s.size() == 0 || s.size() &gt; 12 || s.size() &lt; 4) &#123; return res; &#125; for (int i =0;i&lt;s.size();i++) &#123; for (int j =i+1;j&lt;s.size();j++) &#123; for (int k = j+1;k&lt;s.size()-1;k++) &#123; string str1 = s.substr(0, i + 1); string str2 = s.substr(i+1, j-i); string str3 = s.substr(j+1, k-j); string str4 = s.substr(k+1); if (isValidIp(str1)&amp;&amp;isValidIp(str2)&amp;&amp;isValidIp(str3)&amp;&amp;isValidIp(str4)) &#123; string str = str1 + "." + str2 + "." + str3 + "." + str4; res.push_back(str); &#125; &#125; &#125; &#125; return res; &#125; bool isValidIp(string s) &#123; if (s[0] == '0') &#123; return s.size() == 1; &#125; else &#123; int num = atoi(s.c_str()); if (num &lt;= 255) &#123; return true; &#125; else return false; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[92. Reverse Linked List II]]></title>
    <url>%2F2017%2F08%2F09%2F92-Reverse-Linked-List-II%2F</url>
    <content type="text"><![CDATA[92. Reverse Linked List IIReverse a linked list from position m to n.Do it in - place and in one - pass. For example :Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. Note :Given m, n satisfy the following condition :1 ≤ m ≤ n ≤ length of list. 题意： 将一个链表从位置m到n进行反转，在原内存空间上操作链表，完成链表m到n反转。 注意： 给定的m，n满足以下条件： 1≤m≤n≤列表的长度。 思路： 方法一： 直接在查找链表的过程中进行反转链表的指定区域。 1234567891011121314151617181920212223242526272829303132333435363738394041ListNode* reverseBetween(ListNode* head, int m, int n) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return head; &#125; if (m == n) &#123; return head; &#125; ListNode *endHead = NULL; ListNode *vPre = NULL; ListNode *v = head; ListNode *endReverse = NULL; int tempM = m; while ((tempM -1)) &#123; endHead = v; v = v-&gt;next; tempM--; &#125; endReverse = v; vPre = v; v = v-&gt;next; for (int i = m+1;i&lt;=n;i++) &#123; ListNode *vNext = v-&gt;next; v-&gt;next = vPre; vPre = v; v = vNext; &#125; endReverse-&gt;next = v; if (endHead) &#123; endHead-&gt;next = vPre; &#125; else &#123; head = vPre; &#125; return head;&#125; 方法二： 分为三段，把中间的一段进行反转,利用递归进行反转单链表的实现函数，效率不太高。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758ListNode* reverseList(ListNode* head)&#123; if (head==NULL||head-&gt;next==NULL) &#123; return head; &#125; ListNode *p = head-&gt;next; ListNode *q = reverseList(p); head-&gt;next = NULL; p-&gt;next = head; return q;&#125;//分为三段，把中间的一段进行反转ListNode* reverseBetween(ListNode* head, int m, int n) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return head; &#125; if (m==n) &#123; return head; &#125; ListNode *mPointer = head; ListNode *nPointer = head; ListNode *mPre = NULL; ListNode *nLater = NULL; while ((m-1)) &#123; mPre = mPointer; mPointer = mPointer-&gt;next; m--; &#125; while ((n - 1)) &#123; nPointer = nPointer-&gt;next; n--; &#125; if (nPointer-&gt;next!=NULL) &#123; nLater = nPointer-&gt;next; nPointer-&gt;next = NULL;//一定要设为NULL &#125; ListNode *mHead = reverseList(mPointer); if (mPre!= NULL) &#123; mPre-&gt;next = mHead; &#125; else &#123; head = nPointer; &#125; while (mHead-&gt;next!=NULL//找反转后的中间段的尾节点 &#123; mHead = mHead-&gt;next; &#125; mHead-&gt;next = nLater; return head;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[90. Subsets II]]></title>
    <url>%2F2017%2F08%2F09%2F90-Subsets-II%2F</url>
    <content type="text"><![CDATA[90. Subsets IIGiven a collection of integers that might contain duplicates, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,2], a solution is:[ [2], [1], [1,2,2], [2,2], [1,2], []] 题意： 给定一个整数集合可能包含重复的数组元素，返回所有可能的子集。注意：解决方案集不能包含重复子集。 思路： 同78.Subsets思路类似，也是通过回溯递归法实现，但是不同点是此处给的数组集合是包含重复元素的，但是结果姐不能出现重复的结果集，所以要想办法去重。 第一种去重的方法是首先对原数组进行排序，然后通过进入下层递归的地方进行判断，i==index的时候是新的一层递归的开始，所以有相同元素也没事，所以可以直接放入，当i!=index的时候是在此层前进的另外一种情况，所以要进一步判断i所对应的元素是否和i-1一样，如果一样则不能放到素组中，因为数组已经经过排序整理，再放进去肯定会出现重复的子集合。 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; tempRes; int sizes = nums.size(); sort(nums.begin(), nums.end());//先排序 backtracking(nums, tempRes, 0, sizes); return res; &#125; void backtracking(vector&lt;int&gt;&amp; nums, vector&lt;int&gt; tempRes, int index, int sizes) &#123; //注意此处没有判断子集大小，因为所有子集都要查找出来，所以不需要加上额外的判断子集的大小 res.push_back(tempRes); for (int i = index; i &lt; sizes; i++) &#123; if (i==index||nums[i]!=nums[i-1])//i==index的时候是新的一层递归的开始，所以可以直接放入，当i!=index的时候是在此层前进的另外一种情况，所以要进一步判断i所对应的元素是否和i-1一样，如果一样则不能放到素组中，因为数组已经经过排序整理 &#123; tempRes.push_back(nums[i]); backtracking(nums, tempRes, i + 1, sizes); tempRes.pop_back(); &#125; &#125; &#125;&#125;; 第二种去重的方法是直接了利用C++的set集合的特性，set集合中不能出现重复元素，当插入已经存在的元素的时候会插入不成功，所以借助set集合去重，但是效率低一些，不像方法一进行剪枝，此方法会多运算重复元素循环递归构造子集的过程，提高时间复杂度。 1234567891011121314151617181920212223242526272829303132class Solution3 &#123;public: set&lt;vector&lt;int&gt;&gt; res;//利用set集合去重，并没有剪枝，减少循环递归次数 vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; tempRes; int sizes = nums.size(); sort(nums.begin(), nums.end()); for (int step = 0; step &lt;= sizes; step++) &#123; backtracking(nums, tempRes, step, sizes, 0); &#125; vector&lt;vector&lt;int&gt;&gt; result; for (auto r : res) &#123; result.push_back(r); &#125; return result; &#125; void backtracking(vector&lt;int&gt;&amp; nums, vector&lt;int&gt; tempRes, int k, int sizes, int index) &#123; if (k == 0) &#123; res.insert(tempRes); return; &#125; for (int i = index; i &lt;= sizes - k; i++) &#123; tempRes.push_back(nums[i]); backtracking(nums, tempRes, k - 1, sizes, i + 1); tempRes.pop_back(); &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[89. Gray Code]]></title>
    <url>%2F2017%2F08%2F09%2F89-Gray-Code%2F</url>
    <content type="text"><![CDATA[89. Gray CodeThe gray code is a binary numeral system where two successive values differ in only one bit.Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. For example, given n = 2, return [0,1,3,2]. Its gray code sequence is: 00 - 001 - 111 - 310 - 2 Note:For a given n, a gray code sequence is not uniquely defined.For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that. 题意： 格雷码是一个二进制数字系统，其中两个连续的值只在一个位上有所不同。给定一个非负整数n代表代码中的比特总数，打印格雷码序列。格雷码序列必须从0开始。 思路： n+1位格雷码的集合 = n位格雷码集合(顺序)加前缀0 + n位格雷码集合(逆序)加前缀1。 1234567891011121314151617//非递归的迭代实现class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; res(1,0); for (int i = 1;i&lt;=n;i++) &#123; int sizes = res.size(); for (int j = sizes-1; j &gt;= 0; j--) &#123; int val = res[j] | 1 &lt;&lt; (i-1);//表示i位要使1往左移动i-1位，可以和逆序的i-1位的格雷码进行异或，其实就是实现计算n+1为格雷码时的n位格雷码集合(逆序)加前缀1 res.push_back(val); &#125; &#125; return res; &#125; &#125;; 1234567891011121314151617181920212223//递归实现class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; res; backtracking(res, n); return res; &#125; void backtracking(vector&lt;int&gt; &amp;res, int n) &#123; if (n==0) &#123; res.push_back(0); return; &#125; backtracking(res, n - 1); int sizes = res.size(); for (int i = sizes-1;i&gt;=0;i--) &#123; int val = res[i] | (1 &lt;&lt; n - 1); res.push_back(val); &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[88. Merge Sorted Array]]></title>
    <url>%2F2017%2F08%2F09%2F88-Merge-Sorted-Array%2F</url>
    <content type="text"><![CDATA[88. Merge Sorted ArrayGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 题意： 给定两个有序整数数组nums1和nums2，合并成一nums2和nums1，合并后也为排序数组。 注意： 可以认为nums1有足够的空间（尺寸大于或等于m + n）能够放下nums2的附加元素。元素在nums1和nums2初始化个数分别是m和n。 思路： 方法一： 从后往前在num1中放入元素，不借助辅助数组，一个索引指针tar记录m+n的位置，即合并后元素的末尾位置，然后从前往后遍历nums1和nums2，把其中打的元素直接放到tar处，然后相应数组索引指针减一，直到nums1和nums2的索引指针都为0，切记注意当nums1的索引指针先为0，而num2的索引指针不为0，那么最后一定要继续遍历num2，将其合并到num1中。 12345678910111213141516171819202122232425262728class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; if (m == 0) &#123; nums1 = nums2; &#125; if (n == 0) &#123; return; &#125; int tar = m + n - 1; int p1 = m - 1, p2 = n - 1; while (p2 &gt;= 0 &amp;&amp; p1 &gt;= 0) &#123; if (nums1[p1] &lt; nums2[p2]) &#123; nums1[tar--] = nums2[p2--]; &#125; else nums1[tar--] = nums1[p1--]; &#125; while (p2 &gt;= 0) &#123; nums1[tar--] = nums2[p2--]; &#125; &#125;&#125;; 方法二： 从前往后遍历两个数组，一边遍历一边合并到临时数组中，这个方法需要申请额外的内存空间，代码思路类似归排序的归并过程。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; if (m == 0) &#123; nums1 = nums2; &#125; if (n == 0) &#123; return; &#125; vector&lt;int&gt; tempNums1; int p1 = 0, p2 = 0; while (p1 &lt; m&amp;&amp;p2 &lt; n) &#123; while (p1 &lt; m&amp;&amp;nums1[p1] &lt;= nums2[p2]) &#123; tempNums1.push_back(nums1[p1]); p1++; &#125; while (p2 &lt; n&amp;&amp;nums2[p2] &lt;= nums1[p1]) &#123; tempNums1.push_back(nums2[p2]); p2++; &#125; &#125; while (p1 &lt; m) &#123; tempNums1.push_back(nums1[p1]); p1++; &#125; while (p2 &lt; n) &#123; tempNums1.push_back(nums2[p2]); p2++; &#125; for (int i = 0; i &lt; tempNums1.size(); i++) &#123; nums1[i] = tempNums1[i]; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[87. Scramble String]]></title>
    <url>%2F2017%2F08%2F09%2F87-Scramble-String%2F</url>
    <content type="text"><![CDATA[87. Scramble StringGiven a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.Below is one possible representation of s1 = “great”: To scramble the string, we may choose any non-leaf node and swap its two children. For example, if we choose the node “gr” and swap its two children, it produces a scrambled string “rgeat”. We say that “rgeat” is a scrambled string of “great”. Similarly, if we continue to swap the children of nodes “eat” and “at”, it produces a scrambled string “rgtae”. We say that “rgtae” is a scrambled string of “great”.Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. 题意： 给定一个字符串S1，我们可以将其表示为一个二叉树划分为两个非空的子字符串递归。 Scramble String，我们可以选择任何非叶节点并交换它的两个孩子。 思路： 方法一： 这道题的要求是判断两个字符串是否是Scramble String。如果两个字符串是Scramble String，则其长度必然相等。而且，在某位置切开s1，则s1左侧与s2左侧相同数量的子串为Scramble String，并且s1右侧与s2右侧相同数量的子串为Scramble String；或者s1左侧与s2右侧相同数量的子串为Scramble String，并且s1右侧与s2左侧相同数量的子串为Scramble String。思路有了，就可以通过递归调用遍历每组分割点了。其中a1和b1分别表示s1中以a1开始b1结束的子串，a2和b2分别表示s2中以a2开始b2结束的子串。 利用递归的思想,有三种情况需要考虑： 如果两个substring相等的话，则为true 如果两个substring中间某一个点，左边的substrings为scramble string，同时右边的substrings也为scramble string，则为true 如果两个substring中间某一个点，s1左边的substring和s2右边的substring为scramble string, 同时s1右边substring和s2左边的substring也为scramble string，则为true 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool isScramble(string s1, string s2) &#123; if (s1==s2) &#123; return true; &#125; if (s1.size()!=s2.size()) &#123; return false; &#125; vector&lt;int&gt; hash(26, 0); // 剪枝，如果子串中的字符不同，则必然不是Scramble String，不用再进行分割处理了 for (int i = 0;i&lt;s1.size();i++)//此处利用计数法判断两个字符串中的字符是否是都相等的 &#123; hash[s1[i] - 'a']++; hash[s2[i] - 'a']--; &#125; for (int i = 0; i &lt; 26; i++) &#123; if (hash[i] != 0)//只要有一个元素不为0，说明就有字符不相同 return false; &#125; for (int len =1;len&lt;s1.size();len++) &#123; if ( isScramble(s1.substr(0,len),s2.substr(0,len))&amp;&amp;isScramble(s1.substr(len),s2.substr(len)) || isScramble(s1.substr(0, len), s2.substr(s1.size()-len)) &amp;&amp; isScramble(s1.substr(len), s2.substr(0,s1.size()-len)) ) &#123; return true; &#125; &#125; return false; &#125;&#125;; 方法二： 利用动态规划的思想解题，这其实是一道三维动态规划的题目，我们提出维护量res[i][j][n]，其中i是s1的起始字符，j是s2的起始字符，而n是当前的字符串长度，res[i][j][len]表示的是以i和j分别为s1和s2起点的长度为len的字符串是不是互为scramble。 有了维护量我们接下来看看递推式，也就是怎么根据历史信息来得到res[i][j][len]。判断这个是不是满足，其实我们首先是把当前s1[i…i+len-1]字符串劈一刀分成两部分，然后分两种情况： 第一种是左边和s2[j…j+len-1]左边部分是不是scramble，以及右边和s2[j…j+len-1]右边部分是不是scramble； 第二种情况是左边和s2[j…j+len-1]右边部分是不是scramble，以及右边和s2[j…j+len-1]左边部分是不是scramble。 如果以上两种情况有一种成立，说明s1[i…i+len-1]和s2[j…j+len-1]是scramble的。而对于判断这些左右部分是不是scramble我们是有历史信息的，因为长度小于n的所有情况我们都在前面求解过了（也就是长度是最外层循环）。 上面说的是劈一刀的情况，对于s1[i…i+len-1]我们有len-1种劈法，在这些劈法中只要有一种成立，那么两个串就是scramble的。 总结起来递推式是res[i][j][len] ||= (res[i][j][k]&amp;&amp;res[i+k][j+k][len-k] || res[i][j+len-k][k]&amp;&amp;res[i+k][j][len-k]) 对于所有1&lt;=k&lt;len，也就是对于所有len-1种劈法的结果求或运算。因为信息都是计算过的，对于每种劈法只需要常量操作即可完成，因此求解递推式是需要O(len)（因为len-1种劈法）。 如此总时间复杂度因为是三维动态规划，需要三层循环，加上每一步需要线行时间求解递推式，所以是O(n^4)。虽然已经比较高了，但是至少不是指数量级的，动态规划还是有很大有事的，空间复杂度是O(n^3) 维护变量dp[i][j][len]，其中i是s1的起始字符，j是s2的起始字符，而n是当前的字符串长度，表示的是以i和j分别为s1和s2起点的长度为len的字符串是不是互为Scramble String。 递推公式也是前面的思路：dp[i][j][len] ||= (dp[i][j][k]&amp;&amp;dp[i+k][j+k][len-k] || dp[i][j+len-k][k]&amp;&amp;dp[i+k][j][len-k])。和方法一不同之处就是把前面的结果都记录下来，根据前面的结果集去计算当前结果，并不像一中用递归计算，这是动态规划的显著特征，用空间换时间，用已经计算的值来求当前值，减少计算时间复杂度。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: bool isScramble(string s1, string s2) &#123; if (s1 == s2) &#123; return true; &#125; int s1Len = s1.size(); int s2Len = s2.size(); if (s1.size() != s2.size()) &#123; return false; &#125; vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt; dp(s1Len, vector&lt;vector&lt;bool&gt;&gt;(s1Len, vector&lt;bool&gt;(s1Len + 1, false))); for (int i = 0;i&lt;s1Len;i++) &#123; for (int j = 0;j&lt;s2Len;j++) &#123; dp[i][j][1] = (s1[i] == s2[i]); &#125; &#125; for (int len = 2;len&lt;=s1Len;len++)//截取串的长度 &#123; for (int i = 0; i &lt;= s1Len - len; i++) &#123; for (int j = 0; j &lt;= s2Len-len; j++) &#123; for (int k = 1;k&lt;=len;k++)//k是一个串的左右分隔点 &#123; dp[i][j][k] = dp[i][j][k] || dp[i][j][k] &amp;&amp; dp[i + k][j + k][len-k] || dp[i][j + len - k][k] &amp;&amp; dp[i + len - k][j][k]; &#125; &#125; &#125; &#125; return dp[0][0][s1Len]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[86. Partition List]]></title>
    <url>%2F2017%2F08%2F09%2F86-Partition-List%2F</url>
    <content type="text"><![CDATA[86. Partition ListGiven a linked list and a value x, partition(划分) it such that all nodes less than x come before nodes greater than or equal to x. You should preserve（保持） the original（原始的） relative（相对的） order of the nodes in each of the two partitions. For example,Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5. 题意： 给定一个链表和一个值x，通过x划分链表中所有节点，使链表前面的节点小于X，后面的节点大于或等于x，要保持原始的相对在一个分区的节点顺序。 思路： 首先创建两个单链表的头结点，分别用来指向小于x的单链表，和大于等于x的单链表，最后把后者连接到前者的单链表上，这样原单链表的相对顺序也不会改变。 注意–第二个链表的末尾要置为NULL。 123456789101112131415161718192021222324252627282930ListNode* partition(ListNode* head, int x) &#123; if (head==NULL) &#123; return NULL; &#125; ListNode *p = head; ListNode tempHead1(-1); ListNode *temp1 = &amp;tempHead1; ListNode tempHead2(-1); ListNode *temp2 = &amp;tempHead2; while (p!=NULL) &#123; if (p-&gt;val&lt;x) &#123; temp1-&gt;next = p; temp1 = temp1-&gt;next; &#125; if (p-&gt;val &gt;= x) &#123; temp2-&gt;next = p; temp2 = temp2-&gt;next; &#125; p = p-&gt;next; &#125; temp2-&gt;next = NULL;//不置为空的话有可能还指向原链表中的元素，当和第一个链表连接起来的时候回造成环的出现，导致错误 temp1-&gt;next = tempHead2.next; tempHead2.next = NULL; //delete(&amp;tempHead2); return tempHead1.next;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[85. Maximal Rectangle]]></title>
    <url>%2F2017%2F08%2F09%2F85-Maximal-Rectangle%2F</url>
    <content type="text"><![CDATA[85. Maximal RectangleGiven a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all ones and return its area. 题意： 给定一个二维二进制矩阵，填充0和1，找到由1围成的最大矩形，并返回它的面积。 思路：方法一： 基于84-Largest-Rectangle-in-Histogram的思想，假设把矩阵沿着某一行分开，然后把分开的行作为底面，将自底面往上的矩阵看成一个直方图（histogram）。直方图的中每个项的高度就是从底面行开始往上1的数量。根据84-Largest-Rectangle-in-Histogram就可以求出当前行作为矩阵下边缘的一个最大矩阵。接下来如果对每一行都做一次Largest Rectangle in Histogram，从其中选出最大的矩阵，那么它就是整个矩阵中面积最大的子矩阵。 如何计算某一行为底面时直方图的高度呢？如果重新计算，那么每次需要的计算数量就是当前行数乘以列数。然而会发现一些动态规划的踪迹，如果知道上一行直方图的高度，就只需要看新加进来的行（底面）上对应的列元素是不是0，如果是，则高度是0，否则则是上一行直方图的高度加1。利用历史信息，就可以在线行时间内完成对高度的更新。由于Largest Rectangle in Histogram的算法复杂度是O(n)。所以完成对一行为底边的矩阵求解复杂度是O(n+n)=O(n)。接下来对每一行都做一次，那么算法总时间复杂度是O(m*n)。 时间复杂度：O(mn) 空间复杂度：O(n) 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: int largestRectangleInHistogram(vector&lt;int&gt; &amp;heights) &#123; stack&lt;int&gt; s; int res = 0; //heights.push_back(0); if (heights.size()==0) &#123; return res; &#125; int i = 0; while (i &lt; heights.size()) &#123; if (s.empty() || heights[s.top()]&lt;=heights[i]) &#123; s.push(i++); &#125; else &#123; int t = s.top(); s.pop(); res = max(res, heights[t] * (s.empty() ? i : i - s.top() - 1)); &#125; &#125; return res; &#125; int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if (matrix.size()==0 || matrix[0].size()==0) &#123; return 0; &#125; int res = 0; vector&lt;int&gt; heights(matrix[0].size()+1, 0);//这个地方heights多加一列0，所以直方图计算中不用再添加数组末尾0，可以完成所有直方图列组成面积的计算 for (int i = 0;i&lt;matrix.size();i++) &#123; for (int j = 0; j &lt; matrix[i].size(); j++) &#123; heights[j] = (matrix[i][j] == '0' ? 0 : heights[j] + 1); &#125; res = max(res, largestRectangleInHistogram(heights)); &#125; return res; &#125;&#125;; 方法二： 动态规划思想，思路同样是从第一行开始一行一行地处理，使[i, j]处最大子矩阵的面积是(right(i, j)-left(i, j))*height(i, j)。其中height统计当前位置及往上’1’的数量；left和right是高度是当前点的height值得左右边界，即是以当前点为中心，以height为高度向两边扩散的左右边界。 递推公式如下：left(i, j) = max(left(i-1, j), cur_left);right(i, j) = min(right(i-1, j), cur_right);height(i, j) = height(i-1, j) + 1, if matrix[i][j]==’1’;height(i, j) = 0, if matrix[i][j]==’0’.其中cur_left和cur_right的值由当前行决定，如果当前位置是’1’，则cur_left和cur_right都不变；如果当前位置是’0’，则cur_left就为当前位置的右侧，cur_right就为当前位置（因为左闭右开）。时间复杂度：O(mn)空间复杂度：O(n) 1234567891011121314151617181920212223242526272829303132333435//此法不太理解class Solution &#123;public: int maximalRectangle(vector&lt;vector&lt;char&gt; &gt; &amp;matrix) &#123; if (matrix.size()==0 || matrix[0].size()==0) &#123; return 0; &#125; //left和right是高度是当前点的height值得左右边界，即是以当前点为中心，以height为高度向两边扩散的左右边界。 int m = matrix.size(), n = matrix[0].size(); vector&lt;int&gt; height(n, 0); vector&lt;int&gt; left(n, 0);//记录上面几行元素左侧最大高度 vector&lt;int&gt; right(n, n);//记录上面几行元素右侧最大高度 int res = 0; for (int i =0;i&lt;m;i++) &#123; int cur_left = 0, cur_right = n; for (int j = 0;j&lt;n;j++) &#123; height[j] = matrix[i][j] == '1' ? height[j] + 1 : 0; left[j] = matrix[i][j] == '1' ? max(left[j], cur_left) : 0; cur_left = matrix[i][j] == '1' ? cur_left : j+1; &#125; for (int j = n-1;j&gt;=0;j--) &#123; right[j] = matrix[i][j] == '1' ? min(right[j], cur_right) : n; cur_right = matrix[i][j] == '1' ? cur_right : j; &#125; for (int j = 0; j &lt; n; ++j) res = max(res, (right[j] - left[j]) * height[j]); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[84. Largest Rectangle in Histogram]]></title>
    <url>%2F2017%2F08%2F08%2F84-Largest-Rectangle-in-Histogram%2F</url>
    <content type="text"><![CDATA[84. Largest Rectangle in HistogramGiven n non - negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2, 1, 5, 6, 2, 3].The largest rectangle is shown in the shaded area, which has area = 10 unit. For example,Given heights = [2, 1, 5, 6, 2, 3],return 10. 题意： 给定n个非负整数表示直方图的条形高度，每个条的宽度为1，找到直方图中最大矩形的面积。 思路： 方法一： 1、如果已知height数组是升序 比如1, 2, 5, 7, 8 那么就是(1 5) vs. (2 4) vs. (5 3) vs. (7 2) vs. (8 1) 也就是max(height[i] (size - i)) 2、使用栈的目的就是构造这样的升序序列，按照以上方法求解。 但是height本身不一定是升序的，应该怎样构建栈？ 比如2, 1, 5, 6, 2, 3 （1）2进栈。s = { 2 }, result = 0 （2）1比2小，不满足升序条件，因此将2弹出，并记录当前结果为2 1 = 2。 将2替换为1重新进栈。s = { 1,1 }, result = 2 （3）5比1大，满足升序条件，进栈。s = { 1,1,5 }, result = 2 （4）6比5大，满足升序条件，进栈。s = { 1,1,5,6 }, result = 2 （5）2比6小，不满足升序条件，因此将6弹出，并记录当前结果为6 1 = 6。s = { 1,1,5 }, result = 6 2比5小，不满足升序条件，因此将5弹出，并记录当前结果为5 2 = 10（因为已经弹出的5, 6是升序的）。s = { 1,1 }, result = 10 2比1大，将弹出的5, 6替换为2重新进栈。s = { 1,1,2,2,2 }, result = 10 （6）3比2大，满足升序条件，进栈。s = { 1,1,2,2,2,3 }, result = 10 栈构建完成，满足升序条件，因此按照升序处理办法得到上述的max(height[i] (size - i)) = max{ 3 1, 2 2, 2 3, 2 4, 1 5, 1 6 } = 8 &lt; 10 综上所述，result = 10 12345678910111213141516171819202122232425262728293031323334int largestRectangleArea(vector&lt;int&gt;&amp; heights)&#123; int res = 0; stack&lt;int&gt; s; for (auto val : heights) &#123; if (s.empty() || s.top()&lt;= val) &#123; s.push(val); &#125; else &#123; int count = 0; while (!s.empty()&amp;&amp;s.top()&gt;val)//通过栈构造递增序列，然后求最大面积 &#123; count++; res = max(res, s.top()*count); s.pop(); &#125; while (count) &#123; s.push(val); count--; &#125; s.push(val); &#125; &#125; int dis = 1; while (!s.empty()) &#123; res = max(res,s.top()*dis++); s.pop(); &#125; return res;&#125; 方法二： 思路同方法一，也是通过栈来狗仔递增柱状图序列，但是此法的巧妙之处不是用栈来存在柱状图数组中的值，而是存储柱状图数组的索引。 （1）当遍历的当前元素比栈顶元素大或者相等的时候，直接把其索引入栈 （2）当遍历的当前元素比栈顶元素小的时候，弹出栈顶索引，计算弹出的索引（其实是栈顶索引，记录弹出索引是为了去元素值，栈顶元素索引 - 当前遍历索引 - 1）和当前遍历到的那个小的索引差值，然后减一，刚刚好得到所有比弹出元素大，而且比当前遍历元素大的元素个数，然后计算出面积值 12345678910111213141516171819202122232425262728293031int largestRectangleArea(vector&lt;int&gt; &amp;height) &#123; height.push_back(0); stack&lt;int&gt; s; int maxRrea=0; int i = 0; while (i&lt;height.size()) &#123; if (s.empty() || height[s.top()] &lt;= height[i]) &#123; s.push(i++);//放入当前元素索引 &#125; else &#123; int tempArea = 0; int index = s.top();//因为当前元素比栈顶索引所对应元素小，所以弹出栈顶索引 s.pop(); if (s.empty())//弹出栈顶要判断是否为空，如果为空，说明index所指向元素比以前元素都小，所以可以直接height[index] * i，i表示所有height[index]高度可以组成面积的柱方图个数 &#123; tempArea = height[index] * i; maxRrea = maxRrea &gt; tempArea ? maxRrea : tempArea; &#125; else//不为空的话就要通过现在栈顶元素索引和i来求height[index]高度可以组成面积的柱方图个数 &#123; tempArea = height[index] *(i - s.top() - 1); maxRrea = maxRrea &gt; tempArea ? maxRrea : tempArea; &#125; &#125; &#125; return maxRrea;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[83. Remove Duplicates from Sorted List]]></title>
    <url>%2F2017%2F08%2F08%2F83-Remove-Duplicates-from-Sorted-List%2F</url>
    <content type="text"><![CDATA[83. Remove Duplicates from Sorted ListGiven a sorted linked list, delete all duplicates such that each element appear only once. For example,Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 题意： 给一个排序链表，删除重复元素，使每个元素值出现一次，注意每个元素出现一次，并不是把重复的元素都删除掉，而是要保留一个元素在原链表中。 思路： 解法同82. Remove Duplicates from Sorted List II，但是在删除的过程中不能全部把相同的元素都删除掉，要留一个元素在链表中。这种能保留一个元素的有相对简单些，相等的话直接删除其后面的元素即可，不等后移链表指针。 1234567891011121314151617ListNode* deleteDuplicates(ListNode* head) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return head; &#125; ListNode *p = head; while (p-&gt;next!=NULL) &#123; if (p-&gt;val==p-&gt;next-&gt;val) &#123; p-&gt;next = p-&gt;next-&gt;next;//如果相等，p-&gt;next直接指向 p-&gt;next-&gt;next元素，可以为空 &#125; else &#123; p = p-&gt;next; &#125; &#125; return head;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[82. Remove Duplicates from Sorted List II]]></title>
    <url>%2F2017%2F08%2F08%2F82-Remove-Duplicates-from-Sorted-List-II%2F</url>
    <content type="text"><![CDATA[82. Remove Duplicates from Sorted List IIGiven a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. For example,Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3. 题意： 给一个有序链表，在原链表中删除重复的元素，留下单一元素。 思路： 方法一： 遍历链表的过程中删除重复元素，此法是找到相同的段，然后一起删除，也就是说通过计数数组中相同元素的个数，然后直接删除一整段。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950struct ListNode&#123; int val; ListNode *next; ListNode(int x) :val(x), next(NULL) &#123;&#125;&#125;;ListNode* deleteDuplicates(ListNode* head) &#123; if (head==NULL||head-&gt;next==NULL) &#123; return head; &#125; ListNode deleteHead(-1);//建立临时头结点 ListNode *pPre = &amp;deleteHead; pPre-&gt;next = head; ListNode *p = deleteHead.next; int counts = 1;//用于记录一段相同元素的个数 while (p-&gt;next!=NULL) &#123; ListNode *pNext = p-&gt;next; if (p-&gt;val==pNext-&gt;val) &#123; counts++; p = p-&gt;next; &#125; else &#123; if (counts&gt;1)//大于一有相同元素，直接通过pPre和pNext指针删除相同断 &#123; ListNode *tempHead = NULL; tempHead = pPre-&gt;next; pPre-&gt;next = pNext; p-&gt;next = NULL; delete(tempHead); p = pNext; counts = 1; &#125; else &#123; pPre = pPre-&gt;next; p = p-&gt;next; &#125; &#125; &#125; if (counts&gt;1) &#123; pPre-&gt;next = NULL; &#125; return deleteHead.next;&#125; 方法二： 遍历链表的过程中删除重复元素，此法是找到一个相等的就删除一个，直到不等。 123456789101112131415161718192021222324252627282930313233ListNode* deleteDuplicates(ListNode* head) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return head; &#125; ListNode deleteHead(-1); ListNode *pPre = &amp;deleteHead; pPre-&gt;next = head; ListNode *p = deleteHead.next; while (p!=NULL&amp;&amp;p-&gt;next!=NULL) &#123; ListNode *pNext = p-&gt;next; if (p-&gt;val==pNext-&gt;val) &#123; int val = p-&gt;val; while (p!=NULL&amp;&amp;p-&gt;val == val) &#123; pPre-&gt;next = pNext; p = pNext; if (pNext!=NULL) &#123; pNext = pNext-&gt;next; &#125; &#125; &#125; else &#123; pPre = pPre-&gt;next; p = p-&gt;next; &#125; &#125; return deleteHead.next;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[81. Search in Rotated Sorted Array II]]></title>
    <url>%2F2017%2F08%2F07%2F81-Search-in-Rotated-Sorted-Array-II%2F</url>
    <content type="text"><![CDATA[81. Search in Rotated Sorted Array IIFollow up for “Search in Rotated Sorted Array”: What if duplicates are allowed? Would this affect the run-time complexity? How and why? Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).Write a function to determine if a given target is in the array.The array may contain duplicates. 题意： 33. Search in Rotated Sorted Array的变形，就是对一个按升序排序的数组通过预先未知的某个旋转轴进行旋转，给定一个搜索的目标值。如果在数组中找到，返回true，否则返回false，但是数组中出现重复的元素。 思路： 解题方法类似33. Search in Rotated Sorted Array，但是有重复元素的存在，会造成左侧不是递增的状态，即num[l]&lt;=num[mid]时，此时nums[mid]==nums[l],但是中间的值比二者都小，所以不递增，在进行二分查找确定递增区间，缩小查找范围的时候，一定先判断中间元素是否和两侧的元素相等，如果相等且不等于目标元素，则要移动相应的指针，再进行判断进行区间的划分。 出现重复的时候，因为重复的次数我们无从得知，原数组旋转折叠的位置我们也无从得知，所以最后折叠后的状态我们也就无从得知，所以我们无法去按着33. Search in Rotated Sorted Array的判断标准去判断哪部分有序，设想一种情形1，1, 1，2，1,1,1，恰好左中右都是1,这时我们 ++左下标，–右下标，为什么这样我们不会将这个值跳过呢？ 就是说，凭什么我们说除却这两个位置，在两者之间就一定还存在这个值？当然能，因为我们进入的条件是左中右相等，所以我们可以把首尾的值都略过，进行下一次循环。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int len = nums.size(); if (len == 0) return false; int l = 0, r = len - 1; while (l &lt;= r)//可能只存在一个元素 &#123; int mid = (l + r) / 2; if (nums[mid] == target) &#123; return true; &#125; // the only difference from the first one, trickly case, just updat left and right if ((nums[l] == nums[mid]) &amp;&amp; (nums[r] == nums[mid])) &#123; ++l; --r; &#125;//如果左中右都相等，则左右指针向中间靠拢 else if (nums[l] &lt;= nums[mid])//此处认为，只要不是左中右都相等，只和左侧相等，是可以划分区间 &#123; if (target &gt;= nums[l] &amp;&amp; target &lt; nums[mid]) &#123; r = mid - 1; &#125; else l = mid + 1; &#125; else &#123; if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[r]) &#123; l = mid + 1; &#125; else r = mid - 1; &#125; &#125; return false; &#125;&#125;; 另外一种去掉相等重复元素思路的代码。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int len = nums.size(); if (len == 0) return false; int l = 0, r = len - 1; while (l&lt;=r) &#123; int mid = (l + r) / 2; if (nums[mid]==target) &#123; return true; &#125; if (nums[l] &lt; nums[mid])//没有判断nums[l] == nums[mid]，而是作为一个分支 &#123; if (target &gt;= nums[l] &amp;&amp; target &lt; nums[mid]) &#123; r = mid - 1; &#125; else l = mid + 1; &#125; else if (nums[l] &gt; nums[mid]) &#123; if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[r]) &#123; l = mid + 1; &#125; else r = mid - 1; &#125; else l++;//这里只根据nums[l] == nums[mid]来让l++，所以可能多几次循环遍历，但思路明确 &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[80. Remove Duplicates from Sorted Array II]]></title>
    <url>%2F2017%2F08%2F07%2F80-Remove-Duplicates-from-Sorted-Array-II%2F</url>
    <content type="text"><![CDATA[80. Remove Duplicates from Sorted Array IIFollow up for “Remove Duplicates”:What if duplicates are allowed at most twice? For example,Given sorted array nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn’t matter what you leave beyond the new length. 题意： 紧接着26. Remove Duplicates from Sorted Array,只保留一个重复的元素的题，此题也是删除数组重复元素，但是重复元素最多允许出现两次。 思路： 26. Remove Duplicates from Sorted Array中只保留一个重复的元素，所以j从1开始，依次判读取的那个元素是否和j-1的元素是否相等，现在是两个重复的元素，应该j从2开始，比较j与j-1和j-2是否相等，26. Remove Duplicates from Sorted Array标志位从1开始，此题应该从2开始。 1234567891011121314151617181920class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if (len &lt;=2) &#123; return len; &#125; int last = 2;//注意标志位的起始点，也就是后面不重复元素要放到前面覆盖重复元素的点 for (int j =2; j &lt; len; j++) &#123; if (nums[j] != nums[last - 2]||nums[j]!=nums[last-1]) &#123; nums[last] = nums[j]; last++; &#125; &#125; return last; &#125;&#125;; 引申： 当可以重复3个、4个、、、、、n个呢，唯一的不同点就是标志位的选取有变换，当前元素和标志位之前元素比较各个数有变化，其他都是相同的，所以由公共的代码解法，适应任意多的重复元素个数。 123456789101112131415161718class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; return allMethod(nums,2); &#125; int allMethod(vector&lt;int&gt;&amp; nums,int multiply)&#123;//第二个参数为排序数组中留下的重复元素的个数 int len = nums.size(); if(len&lt;=multiply) return len; int tail = multiply; for(int i = multiply;i&lt;len;i++) &#123; if(nums[i]!=nums[tail-multiply])//此处优化之和前multiply个元素的第一个元素相比较，只要不相等，就可以覆盖tail所指向的元素，然后tail++，因为数组是递增有序的 nums[tail++] = nums[i]; &#125; return tail; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[79. Word Search]]></title>
    <url>%2F2017%2F08%2F07%2F79-Word-Search%2F</url>
    <content type="text"><![CDATA[79. Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example,Given board =[ [‘A’,’B’,’C’,’E’], [‘S’,’F’,’C’,’S’], [‘A’,’D’,’E’,’E’]] word = “ABCCED”, -&gt; returns true,word = “SEE”, -&gt; returns true,word = “ABCB”, -&gt; returns false. 题意： 给定一个2D面板和一个单词，查找这个单词是否存在于面板中。 单词可以由相邻单元格的字母构成，相邻的单元格是水平或垂直相邻的单元格。同一个字母单元不能超过一次使用。 思路： 方法一： 也是典型的递归回溯，深度优先遍历的题目，但是因为同一个字母单元不能超过一次使用，所以要有标记矩阵标记此元素是否可以访问，从上下左右四个方向进行DFS。需要注意的就是访问一个字母后visited标识1，当DFS调用返回后，如果还没有找完，应该让visited置0，并返回false。 注意理解的带返回值的终止递归回溯算法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/****************************************************************************************************************下面递归回溯算法思路清晰，但是效率不是很高You are here! Your runtime beats 7.52% of cpp submissions.87 / 87 test cases passed.Status: AcceptedRuntime: 309 ms****************************************************************************************************************/class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if (word.size() == 0) return true; int rowLen = board.size(); int colLen = board[0].size(); if (rowLen == 0 || colLen == 0) return false; vector&lt;vector&lt;int&gt;&gt; flag(rowLen, vector&lt;int&gt;(colLen, 0)); //string tempStr = ""; bool res = false; for (int i = 0; i &lt; rowLen; i++) &#123; for (int j = 0; j &lt; colLen; j++) &#123; if (board[i][j] == word[0] &amp;&amp; !res) &#123; if (backtrcaking(board, flag, word, 0, i, j)) return true; &#125; &#125; &#125; return false; &#125; bool backtrcaking(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;vector&lt;int&gt;&gt; visited, string word, int wordIndex, int rowIndex, int colIndex) &#123; if (wordIndex == word.size()-1) &#123; return true; &#125; int rowLen = board.size(); int colLen = board[0].size(); visited[rowIndex][colIndex] = 1; if (colIndex + 1 &lt; colLen&amp;&amp;!visited[rowIndex][colIndex+1] &amp;&amp;word[wordIndex+1] == board[rowIndex][colIndex+1] ) &#123; if (backtrcaking(board, visited, word, wordIndex + 1, rowIndex, colIndex + 1)) &#123; return true; &#125; &#125; if (rowIndex + 1 &lt; rowLen &amp;&amp; !visited[rowIndex+1][colIndex] &amp;&amp; word[wordIndex + 1] == board[rowIndex+1][colIndex]) &#123; if (backtrcaking(board, visited, word, wordIndex + 1, rowIndex + 1, colIndex)) &#123; return true; &#125; &#125; if (colIndex - 1 &gt;= 0 &amp;&amp; !visited[rowIndex][colIndex -1] &amp;&amp; word[wordIndex + 1] == board[rowIndex][colIndex - 1]) &#123; if (backtrcaking(board, visited, word, wordIndex + 1, rowIndex, colIndex - 1)) &#123; return true; &#125; &#125; if (rowIndex - 1 &gt;= 0 &amp;&amp; !visited[rowIndex-1][colIndex] &amp;&amp; word[wordIndex + 1] == board[rowIndex-1][colIndex]) &#123; if (backtrcaking(board, visited, word, wordIndex + 1, rowIndex - 1, colIndex)) &#123; return true; &#125; &#125; visited[rowIndex][colIndex] = 0; return false; &#125;&#125;; 方法二： 递归回溯法，此法一是省去标记数组，减少空间复杂度，二是递归回溯函数内部递归结束条件控制的很好，所以能提高效率，值得学习的好方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if (word.size() == 0) return true; int rowLen = board.size(); int colLen = board[0].size(); if (rowLen == 0 || colLen == 0) return false; for (int i = 0; i &lt; rowLen; i++) &#123; for (int j = 0; j &lt; colLen; j++) &#123; if (board[i][j] == word[0])//第一个单词元素满足，才能进行下面的深度优先遍历 &#123; if (backtrcaking(board, word, 0, i, j))//带返回值的回溯递归函数，利用返回值控制循环和递归 return true; &#125; &#125; &#125; return false; &#125; bool backtrcaking(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, int wordIndex, int rowIndex, int colIndex) &#123; if (wordIndex == word.size()) &#123; return true; &#125; int rowLen = board.size(); int colLen = board[0].size(); if (rowIndex&gt;=rowLen||rowIndex&lt;0||colIndex&gt;=colLen||colIndex&lt;0)//此处优先判断索引条件，减少递归层次 &#123; return false; &#125; char c = board[rowIndex][colIndex]; if (c ==word[wordIndex])//此处优先比较面板元素值是否和单词元素相等，避免下面递归操作，减少循环递归层次 &#123; board[rowIndex][colIndex] = '#';//通过把遍历过的元素设置为‘#’，来避免使用标记数组 if (backtrcaking(board, word, wordIndex + 1, rowIndex, colIndex + 1)) &#123; return true; &#125; if (backtrcaking(board, word, wordIndex + 1, rowIndex + 1, colIndex)) &#123; return true; &#125; if (backtrcaking(board, word, wordIndex + 1, rowIndex, colIndex - 1)) &#123; return true; &#125; if (backtrcaking(board, word, wordIndex + 1, rowIndex - 1, colIndex)) &#123; return true; &#125; board[rowIndex][colIndex] = c; &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[78. Subsets]]></title>
    <url>%2F2017%2F08%2F06%2F78-Subsets%2F</url>
    <content type="text"><![CDATA[78. SubsetsGiven a set of distinct integers, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,3], a solution is:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 题意： 给出一组不同的整数集合，返回所有可能的子集。 注意：结果集不能包含重复子集。 思路： 方法一： 穷举不同元素个数的所有子集集合，符合递归回溯思想，穷举所有结果，控制递归结束条件为子集元素个数。 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; tempRes; int sizes = nums.size(); for (int step = 0;step&lt;=sizes;step++) &#123; backtracking(nums,tempRes, step, sizes,0); &#125; return res; &#125; void backtracking(vector&lt;int&gt;&amp; nums,vector&lt;int&gt; tempRes, int k, int sizes,int index) &#123; if (k==0) &#123; res.push_back(tempRes); return; &#125; for (int i = index;i&lt;=sizes-k;i++)//i = index表明不能有重复元素，直接取集合的下一个元素 &#123; tempRes.push_back(nums[i]); backtracking(nums, tempRes, k - 1, sizes, i + 1);//每放进去一个元素，子集元素个数减一，即k-1 tempRes.pop_back(); &#125; &#125;&#125;; 方法二： 循环迭代穷举不同元素个数的所有子集集合。 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res(1,vector&lt;int&gt;()); sort(nums.begin(), nums.end());//先对集合进行升序排序 int sizes = nums.size(); for (int i = 0; i &lt; sizes; i++) &#123; int n = res.size(); for (int j = 0;j&lt;n;j++) &#123; res.push_back(res[j]); res.back().push_back(nums[i]); &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[77. Combinations]]></title>
    <url>%2F2017%2F08%2F05%2F77-Combinations%2F</url>
    <content type="text"><![CDATA[77. CombinationsGiven two integers n and k, return all possible combinations of k numbers out of 1 … n. For example,If n = 4 and k = 2, a solution is:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 题意： 给定两个整数n和k，从1到n的所有数中返回k个数的所有可能组合。即从n个树种取出k个数，找出所有的取出可能。 思路： 方法一： 穷举出所有的可能，能想到用回溯递归法，找到所有满足条件的结果，不满足递归回溯，满足放入结果集，进行下一轮递归。 1234567891011121314151617181920212223242526272829/****************************************************************************************************************You are here! Your runtime beats 9.26% of cpp submissions.27 / 27 test cases passed.Status: AcceptedRuntime: 496 ms此法的时间复杂度过高，因为for循环中的递归循环次数控制太过宽泛，造成循环次数过多，时间复杂度过高。****************************************************************************************************************/class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;int&gt; tempRes; backtracking(tempRes, 1,0, k, n);//从1到n return res; &#125; void backtracking(vector&lt;int&gt; tempRes, int index,int counts, int k, int n) &#123; if (counts==k)//找到k个数，满足条件，返回结果集 &#123; res.push_back(tempRes); return; &#125; for (int i = index;i&lt;=n;i++) &#123; tempRes.push_back(i); backtracking(tempRes, i + 1, counts + 1, k, n); tempRes.pop_back(); &#125; &#125;&#125;; 方法二： 也是回溯递归法，但是此法代码效率高，效率高的主要原因就是方法一的递归循环中的控制条件考虑的不够细，不够到位，没有利用k这个元素个数来限制和降低循环次数。 12345678910111213141516171819202122232425262728/****************************************************************************************************************You are here! Your runtime beats 67.65% of cpp submissions.27 / 27 test cases passed.Status: AcceptedRuntime: 103 ms****************************************************************************************************************/class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;int&gt; tempRes; backtracking(tempRes, 1, k, n); return res; &#125; void backtracking(vector&lt;int&gt; tempRes, int index, int k, int n) &#123; if (0 == k)//k为0说明k个元素全部取到 &#123; res.push_back(tempRes); return; &#125; for (int i = index; i &lt;= n-k+1; i++)//k是要查找的元素个数，要保证找到k个元素，i肯定要小于n-k+1,即n个元素后面出去k个后的最大的元素 &#123; tempRes.push_back(i); backtracking(tempRes, i + 1, k-1, n);//此处是k-1,每递归下一层，所要取的元素个数都会较少1个，for循环的次数就会通过k改变而改变 tempRes.pop_back(); &#125; &#125;&#125;; 方法三： 和方法二相同，但是不是往vector中push_back()和pop_back()元素，利用数组下标索引，覆盖相应索引对应元素，减少vector的push_back()和pop_back()元素的时间消耗。所以此法代码效率由高一些。 1234567891011121314151617181920212223242526272829/****************************************************************************************************************You are here! Your runtime beats 92.37% of cpp submissions.27 / 27 test cases passed.Status: AcceptedRuntime: 69 ms****************************************************************************************************************/class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;int&gt; tempRes; tempRes.resize(k);//设置数组大小，根据k进行设置大小，可以根据k值来变化索引值 backtracking(tempRes, 1, k, n); return res; &#125; void backtracking(vector&lt;int&gt; tempRes, int index, int k, int n) &#123; if (0 == k) &#123; res.push_back(tempRes); return; &#125; for (int i = index; i &lt;= n - k + 1; i++)//k是要查找的元素个数，要保证找到k个元素，i肯定要小于n-k+1,即n个元素后面出去k个后的最大的元素 &#123; tempRes[tempRes.size() - k] = i;//直接根据索引进行覆盖，完成本层元素值的存储，当返回上一层的时候，k值变换，又可以对应不同的索引值，进行值的覆盖，减少push_back()和pop_back()操作的时间消耗 backtracking(tempRes, i + 1, k - 1, n); //tempRes.pop_back(); &#125; &#125;&#125;; 方法四： 非递归回溯法实现，即通过循环迭代法，但是效率不是很好。 12345678910111213141516171819202122232425262728293031323334/****************************************************************************************************************You are here! Your runtime beats 32.68% of cpp submissions.27 / 27 test cases passed.Status: AcceptedRuntime: 129 ms这是一种迭代非递归的方法实现，但是还是没有方法三的效率高****************************************************************************************************************/class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tempRes(k,0); int i = 0; while (i &gt;= 0&amp;&amp;tempRes[0]&lt;=n-k+1) &#123; tempRes[i]++; if (tempRes[i]&gt;n) &#123; i--; &#125; else if (i == k-1) &#123; res.push_back(tempRes); &#125; else &#123; i++; tempRes[i] = tempRes[i - 1]; &#125; &#125; return res; &#125; &#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[76. Minimum Window Substring]]></title>
    <url>%2F2017%2F08%2F04%2F76-Minimum-Window-Substring%2F</url>
    <content type="text"><![CDATA[76. Minimum Window SubstringGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). For example,S = “ADOBECODEBANC”T = “ABC”Minimum window is “BANC”. Note:If there is no such window in S that covers all characters in T, return the empty string “”.If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S. 题意： 给定一个字符串S和一个字符串T，找到S中的最小窗口，该窗口包含T中的所有字符。 思路： 方法一： 这道题的要求是在给定的字符串S中找到最小的窗口使其完全包含字符串T中所有字符，如果不存在，则返回空串””。和Longest Substring Without Repeating Characters及Substring with Concatenation of All Words类似的思路，使用l和r两个指针维护子串，用Hash表记录T字串中出现的字符。S中，每次循环r右移1位，然后判断r右移之后所指向的字符是否在Hash表中出现过：如果出现过，则表示在T中。此时通过计数器cnt判断T中字符是否 “”都”” 出现过，如果是，则记录l和r之间子串长度，并与最短长度比较。然后逐步右移l并在Hash表中删除l指向的字符直到计数器cnt小于T中字符数量。 注意由于T中同一字符的数量可能减到负值，因此需要2重判断：先判断是否出现此字符，在判断此字符出现的具体数量。 时间复杂度：O(l1+l2)（l1和l2分别为字符串S和T的长度） 空间复杂度：O(l2) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: string minWindow(string s, string t) &#123; string res = ""; unordered_map&lt;char, int&gt; hash; for (int i = 0; i&lt;t.size(); i++) &#123; hash[t[i]]++; &#125; int countT = 0, left = 0, right = 0, minLeft = 0, minSize = INT_MAX; //hash里面键所对应的值是在left到right之间所有出现过的是t中元素的值，每出现一个对应的值减一，可能出现负值是因为left到right之间包好的t中元素个数多余t中要匹配的个数，所以当left向右移动（countT--的时候），只有值刚好等于0的时候count记录的才是t中元素个数。 //关键点就是countT是记录的窗体中有几个目标字符，用其来控制缩小窗体，而hash中值得总数是窗体中所有目标值得个数。 for (;right&lt;s.size();right++) &#123; if (hash.count(s[right])) &#123; hash[s[right]]--; if (hash[s[right]]&gt;=0) &#123; countT++; &#125; while (countT == t.size()) &#123; if (right - left + 1 &lt; minSize) &#123; minLeft = left; minSize = right - left + 1; &#125; if (hash.count(s[left])) &#123; hash[s[left]]++; if (hash[s[left]] &gt; 0) &#123; countT--; &#125; &#125; left++; &#125; &#125; &#125; if (minSize&gt;s.size()) &#123; return res; &#125; res = s.substr(minLeft, minSize); return res; &#125;&#125;; 方法二： 思路类似方法一，但是没有利用map容器，使用数组来完成相应字符与其数量的映射，由于大小写字母的ASCII码不大于128，因此开辟两个数组存储信息。needFind数组存储T字符串每个字符出现次数。例如：needFind[‘A’]=5意为T中A出现5次。Found数组存储S字符串在[begin,end]窗口内每个字符出现次数。 算法核心思想如下： 在保证[begin,end]窗口包含T中所有字符的条件下，延伸end，收缩begin。 进行一次扫描后，记录符合条件的最小窗口(end-begin+1)表示的字符串。 使用count记录剩余“有效”字符数，当count达到0时，即可说明[begin,end]包含了T。 注意：“有效”的意思是指，当前延伸得到的S[end]字符，使得[begin,end]更进一步包含T，而不是重复劳动。 比如说，T=”a”, [begin,end]已经包含”a”,再延伸得到”aa”，只是无效操作，并没有使得[begin,end]更接近T,有效字符数仍为1. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: string minWindow(string S, string T) &#123; int begin = 0; int end = 0; int minbegin = 0; int minend = 0; int minSize = INT_MAX; vector&lt;int&gt; needFind(128, 0); vector&lt;int&gt; Found(128, 0); for(int i = 0; i &lt; T.size(); i ++) needFind[T[i]] ++; Found[S[0]] ++; int count = T.size(); if(needFind[S[0]] &gt;= Found[S[0]]) count --; while(true) &#123; if(count == 0) &#123;//shrink begin while(Found[S[begin]] &gt; needFind[S[begin]]) &#123; Found[S[begin]] --; begin ++; &#125; int size = end-begin+1; if(size &lt; minSize) &#123; minbegin = begin; minend = end; minSize = size; &#125; &#125; if(end &lt; S.size()) &#123; end ++; Found[S[end]] ++; if(needFind[S[end]] &gt;= Found[S[end]]) count --; &#125; else break; &#125; if(minSize != INT_MAX) return S.substr(minbegin, minSize); else return ""; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[75. Sort Colors]]></title>
    <url>%2F2017%2F08%2F04%2F75-Sort-Colors%2F</url>
    <content type="text"><![CDATA[75. Sort ColorsGiven an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note:You are not suppose to use the library’s sort function for this problem. 题意： 给定一个包含红，白，蓝且长度为n的数组，将数组元素进行分类使同颜色的元素相邻，并按照红、白、蓝的顺序进行排序。 用整数0，1和2分别代表红，白，蓝。 思路： 方法一： 利用计数排序，分别用三个变量countRed、countWhilte、countBlue来记录三种颜色各有几个。 123456789101112131415161718192021222324252627282930void sortColors(vector&lt;int&gt;&amp; nums) &#123; int countRed=0, countWhilte=0, countBlue=0; for (int i=0;i&lt;nums.size();i++) &#123; if (nums[i] == 0) &#123; countRed++; &#125; else if (nums[i] == 1) &#123; countWhilte++; &#125; else countBlue++; &#125; for (int i = 0; i &lt; nums.size(); i++) &#123; if (i &gt;= 0 &amp;&amp; i &lt; countRed) &#123; nums[i] = 0; &#125; else if (i &gt;= countRed&amp;&amp;i &lt; countRed + countWhilte) &#123; nums[i] = 1; &#125; else nums[i] = 2; &#125;&#125; 方法二： 自己实现快速排序。 123456789101112131415161718192021222324252627282930313233343536//1、获取中点值，划分块int getPartition(vector&lt;int&gt; &amp;array, int low, int height) &#123; int valKey = array[low]; while (low&lt;height) &#123; //必须先从height处开始比较，因为valKey记录的是第一个低位的值，放高位比低位小时，直接覆盖低位。 while (low&lt;height&amp;&amp;array[height]&gt;=valKey) &#123; height--; &#125; array[low] = array[height];//直接是覆盖，不是交换 while (low&lt;height&amp;&amp;array[low]&lt;=valKey) &#123; low++; &#125; //swap(array[low], array[height])//直接是覆盖，不是交换; array[height] = array[low]; &#125; array[low] = valKey; return low;&#125;void quickSort(vector&lt;int&gt; &amp;array, int low, int height) &#123; if (low&lt;height) &#123; int partition = getPartition(array, low, height); quickSort(array, low, partition-1); quickSort(array, partition + 1, height); &#125;&#125;void sortColors(vector&lt;int&gt; &amp;nums) &#123; if (nums.empty()) &#123; return; &#125; quickSort(nums, 0, nums.size() - 1);&#125; 方法三： 利用三个指针low、mid、heigh，通过移动三个指针和交换指针所指向元素的值，low指针左边都保证是0(红色)，low指针和mid指针之间保证是1(白色)，heigh指针右面都保证是2(蓝色)。 1234567891011121314151617181920212223242526272829void sortColors(vector&lt;int&gt; &amp;nums) &#123; if (nums.empty()) &#123; return; &#125; int low = 0; int mid = 0; int heigh = nums.size() - 1; while (mid&lt;=heigh) &#123; switch (nums[mid]) &#123; case 0: swap(nums[low], nums[mid]); mid++; low++; break; case 1: mid++; break; case 2: swap(nums[mid], nums[heigh]); heigh--; break; default: break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[74. Search a 2D Matrix]]></title>
    <url>%2F2017%2F08%2F04%2F74-Search-a-2D-Matrix%2F</url>
    <content type="text"><![CDATA[74. Search a 2D MatrixWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. For example,Consider the following matrix:[ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]Given target = 3, return true. 题意： 编写一个有效的算法，在m×n矩阵中搜索一个值。这个矩阵具有以下属性： 每行中的整数从左到右排序。 每一行的第一个整数大于前一行的最后一个整数。 思路： 二分查找，因为是按行排序好的二维数组，所以直接把二维数组看做一维数组，一次二分查找搞定。 n m 的矩阵m可以转化为一个一维数组 =&gt; matrix[x][y] =&gt; a[x m + y] 一维数组转化为n * m的矩阵m =&gt; a[x] =&gt;matrix[x / m][x % m]; 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int m = matrix.size(); if (m == 0) &#123; return false; &#125; int n = matrix[0].size(); if (n == 0) &#123; return false; &#125; int allNum = m*n; int l = 0, r = allNum - 1; while (l &lt;= r) &#123; int midCol = (l + r) / 2; if (target &lt; matrix[midCol / n][midCol%n])//把二维数组转化为一维数组，这种找下标索引的（行索引==索引/列数，列索引==索引%列数）方法及其好，需记忆 &#123; r = midCol - 1; &#125; else if (target &gt; matrix[midCol / n][midCol%n]) &#123; l = midCol + 1; &#125; else return true; &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[73. Set Matrix Zeroes]]></title>
    <url>%2F2017%2F08%2F04%2F73-Set-Matrix-Zeroes%2F</url>
    <content type="text"><![CDATA[73. Set Matrix ZeroesGiven a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place. Follow up:Did you use extra space?A straight forward solution using O(mn) space is probably a bad idea.A simple improvement uses O(m + n) space, but still not the best solution.Could you devise a constant space solution? 题意： 给定一个m×n矩阵，如果一个元素为0，则将整个行和列设置为0。在原内存空间上完成。 思路： 利用第一行和第一列做为标志行，先进行遍历，如果存在0，设置标志，最后第一行第一列全部置为0，然后遍历除去第一行和第一列的数组元素，当元素为0时，那么这个元素所在的第一行和第一列最后肯定也置为0，所以直接把元素所在行和列的第一个元素置为0，因为遍历是从第二行和第二列开始的，所以第一行的置0的状态并不影响最后转换的数组状态。 思路的主要点就是利用第一行和第一列做为0元素的标志,重点就是一直到最后才能改变第一行和第一列是否全为0的状态。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int m = matrix.size(); if (m == 0) &#123; return; &#125; int n = matrix[0].size(); if (n == 0) &#123; return; &#125; int firstRowFlag = 0, firstColFlag = 0; for (int i =0;i&lt;m;i++) &#123; if (matrix[i][0]==0) &#123; firstColFlag = 1; break; &#125; &#125; for (int j = 0;j&lt;n;j++) &#123; if (matrix[0][j]==0) &#123; firstRowFlag = 1; break; &#125; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; if (matrix[i][j]==0) &#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; //下面的写法是根据首行和首列的元素为0然后把对应的行列置为0，这是大错特错，因为首行首列的第一个元素nums[0][0]==0可能为零，这样下面方法根据第一个元素把首行先置为0，会造成首行不该为零的元素置为0，当再遍历列是根据第一行就会出错。 //所以应该根据遍历[1-m][1-n]中元素，然后去看此元素对应的第一行或第一列是否为0，为零的话直接把此元素置为0，因为第一行或第一列是为0表明以前此元素所在的行或者列出现过0,此元素应该置为0。 /*for (int i = 0; i &lt; m; i++) &#123; if (matrix[i][0] == 0) &#123; for (int j = 1; j &lt; n; j++) &#123; matrix[i][j] = 0; &#125; &#125; &#125; printf("********************\n"); for (auto r : matrix) &#123; for (auto c : r) &#123; printf("%4d", c); &#125; printf("\n"); &#125; for (int j = 0; j &lt; n; j++) &#123; if (matrix[0][j] == 0) &#123; for (int i = 1; i &lt; m; i++) &#123; matrix[i][j] = 0; &#125; &#125; &#125; printf("********************\n"); for (auto r : matrix) &#123; for (auto c : r) &#123; printf("%4d", c); &#125; printf("\n"); &#125;*/ //正确写法，根据遍历的元素确定元素是否为0 for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; if (matrix[i][0] == 0||matrix[0][j]==0) &#123; matrix[i][j] = 0; &#125; &#125; &#125; if (firstRowFlag) &#123; for (int j = 0; j &lt; n; j++) &#123; matrix[0][j] = 0; &#125; &#125; if (firstColFlag) &#123; for (int i = 0; i &lt; m; i++) &#123; matrix[i][0] = 0; &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[72. Edit Distance]]></title>
    <url>%2F2017%2F07%2F31%2F72-Edit-Distance%2F</url>
    <content type="text"><![CDATA[72. Edit DistanceGiven two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.) You have the following 3 operations permitted on a word:a) Insert a characterb) Delete a characterc) Replace a character 题意： 给定两个单词word1 word2和，找到从word1转换到word2需要转换到的最小步数。（每一次操作算为1步。） 有以下3个字所允许的操作： a）插入字符 b）删除字符 c）替换字符 思路： 本题是典型的适合使用动态规划的题目。如果要计算单词”INTENTION”和单词”EXECUTION”之间的编辑距离，首先，把这个问题简单化。把上面两个单词简化为长度为1的两个单词I和E。 1) 如果要“I”变化为”E”，可以把”I”替换为”E” 2) 如果要“I”变化为空串” “，可以把”I”删除，从而形成”” 3) 如果要空串“ ”变化为”E”，可以把”E”插入，从而形成E 上面三种变化分别表示替换，删除，插入这三种基本操作。 接下来，定义一个表达式D(i,j)。它表示从第1个字单词的第0位至第i位形成的子串和第2个单词的第0位至第j位形成的子串的编辑距离。 显然，可以计算出动态规划的初始表达式，如下: D(i,0) = i D(0,j) = j 然后，考虑动态规划的状态转移方程式，如下: 上面的状态转移方程的含义是，D(i,j)的值，要么是D(i-1, j)的操作完成之后删除一个字符(第1个单词的第i个字符)，要么是D(i, j-1)的操作完成之后增加一个字符(第2个单词的第j个字符)，要么是D(i-1, j-1)的操作完成之后替换一个字符(如果第1个单词的第i个字符和第2个单词的第j个字符不等)，或者是D(i-1, j-1)的操作完成之后什么也不做(如果第1个单词的第i个字符和第2个单词的第j个字符相等)。其中，下图定义删除，插入，替换的操作步数分别为一步，一步，两步。 以第一个单词”INTENTION”和第二个单词”EXECUTION”为例，看下面的图 注意在此题中，把插入，删除，替换全部定义为一步操作。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int minDistance(string word1, string word2) &#123; int word1Size = word1.size(); int word2Size = word2.size(); vector &lt;vector&lt;int&gt;&gt; dp(word1Size + 1, vector&lt;int&gt;(word2Size+1, 0)); for (int i = 0;i&lt;word1Size+1;i++) &#123; dp[i][0] = i; &#125; for (int j = 0; j &lt; word2Size + 1; j++) &#123; dp[0][j] = j; &#125; for (int i = 1;i&lt;word1Size+1;i++) &#123; for (int j = 1;j&lt;word2Size+1;j++) &#123; if (word1[i - 1] == word2[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1]; &#125; else dp[i][j] = dp[i - 1][j - 1] + 1; int tempDp = min(dp[i - 1][j] + 1,dp[i][j-1]+1); dp[i][j] = min(dp[i][j], tempDp); &#125; &#125; /* for (int i = 0; i &lt; word1Size + 1; i++) &#123; for (int j = 0; j &lt; word2Size + 1; j++) &#123; cout &lt;&lt; dp[i][j] &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return dp[word1Size][word2Size]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[71. Simplify Path]]></title>
    <url>%2F2017%2F07%2F31%2F71-Simplify-Path%2F</url>
    <content type="text"><![CDATA[71. Simplify PathGiven an absolute path for a file(Unix - style), simplify it. For example,path = “/home/“, = &gt; “/home”path = “/a/./b/../../c/“, = &gt; “/c” 题意： 给定一个文件的绝对路径（UNIX样式），简化它，也就是通过一系列转换后，最后所在目录的路径。 思路： 这道题的要求是简化一个Unix风格下的文件的绝对路径。 字符串处理，由于”..”是返回上级目录（如果是根目录则不处理），因此可以考虑用栈记录路径名，以便于处理。需要注意几个细节： 重复连续出现的’/‘，只按1个处理，即跳过重复连续出现的’/‘； 如果路径名是”.”，则不处理； 如果路径名是”..”，则需要弹栈，如果栈为空，则不做处理； 如果路径名为其他字符串，入栈。 最后，再逐个取出栈中元素（即已保存的路径名），用’/‘分隔并连接起来，不过要注意顺序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//此法是通过string的find_first_of方法查找'/'字符位置，然后截取字符串，再判断字符串的形式，是否入栈，或者出栈，或者不做任何处理class Solution &#123;public: string simplifyPath(string path) &#123; stack&lt;string&gt; s; string res = ""; size_t pos1 = path.find_first_of('/'); while (pos1!=string ::npos) &#123; size_t temp = pos1; pos1 = path.find_first_of('/',pos1+1); string tempString = ""; if (pos1 == string :: npos) &#123; tempString = path.substr(temp+1); &#125; else tempString = path.substr(temp+1,pos1-temp-1); if (tempString == "..") &#123; if(!s.empty()) s.pop(); else continue; &#125; else if(tempString == ".") &#123; continue; &#125; else if(tempString != "") &#123; s.push(tempString); &#125; &#125; if (s.empty()) &#123; res = '/'; &#125; while (!s.empty()) &#123; string val = s.top(); res = '/' + val + res; s.pop(); &#125; return res; &#125;&#125;; 12345678910111213141516171819202122232425262728293031323334//此法是通过string的下标索引，逐个遍历每个字符查找'/'字符位置，然后根据索引直接累加字符到下一个'/'字符处，得到目录字符串，再判断字符串的形式，是否入栈，或者出栈，或者不做任何处理class Solution &#123;public: string simplifyPath(string path) &#123; stack&lt;string&gt; ss; // 记录路径名 for (int i = 0; i &lt; path.size(); ) &#123; // 跳过斜线'/' while (i &lt; path.size() &amp;&amp; '/' == path[i]) ++i; // 记录路径名 string s = ""; while (i &lt; path.size() &amp;&amp; path[i] != '/') s += path[i++]; // 如果是".."则需要弹栈，否则入栈 if (".." == s &amp;&amp; !ss.empty()) ss.pop(); else if (s != "" &amp;&amp; s != "." &amp;&amp; s != "..") ss.push(s); &#125; // 如果栈为空，说明为根目录，只有斜线'/' if (ss.empty()) return "/"; // 逐个连接栈里的路径名 string s = ""; while (!ss.empty()) &#123; s = "/" + ss.top() + s; ss.pop(); &#125; return s; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[67. Add Binary]]></title>
    <url>%2F2017%2F07%2F31%2F67-Add-Binary%2F</url>
    <content type="text"><![CDATA[67. Add BinaryGiven two binary strings, return their sum (also a binary string). For example,a = “11”b = “1”Return “100”. 题意： 给定两个二进制字符串，返回它们的总和（和也是一个二进制字符串）。 思路： 类似两个大整数相加，逐位相加，然后判断是否存在进位，用一个变量保存进位值，为下一位求和做准备。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//此法比较好理解，因为二进制进位情况也就四种，所以此法没有用求余数得到进位，而是直接条件判断决定进位和本文相加后的值class Solution &#123;public: string addBinary(string a, string b) &#123; string res = ""; int aLen = a.size(); int bLen = b.size(); int len = max(aLen, bLen); a.insert(0, len - aLen, '0'); b.insert(0, len - bLen, '0'); int flag = 0; for (int i = len-1;i&gt;=0;i--) &#123; int num1 = a[i] - '0'; int num2 = b[i] - '0'; int sum = num1 + num2 + flag; if (sum == 3) &#123; res += '1'; flag = 1; &#125; else if (sum==2) &#123; res += '0'; flag = 1; &#125; else if (sum ==1) &#123; res += '1'; flag = 0; &#125; else &#123; res += '0'; flag = 0; &#125; &#125; if (flag) &#123; res += '1'; &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; 12345678910111213141516171819//此法是通用做法，根据求余数确定本位求和后的值，根据相除确定进位值，当运算进制不同时，直接更改进制基数即可class Solution &#123;public: string addBinary(string a, string b) &#123; string result = ""; int c = 0; int i = a.size() - 1; int j = b.size() - 1; while (i &gt;= 0 || j &gt;= 0 || c == 1) &#123; c += i &gt;= 0 ? a[i--] - '0' : 0; c += j &gt;= 0 ? b[j--] - '0' : 0; result = char(c % 2 + '0') + result; c /= 2; &#125; return result; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[66. Plus One]]></title>
    <url>%2F2017%2F07%2F27%2F66-Plus-One%2F</url>
    <content type="text"><![CDATA[66. Plus OneGiven a non-negative number represented as an array of digits, plus one to the number. The digits are stored such that the most significant digit is at the head of the list. 题意： 给定一个非负数，表示为一个位数数组，在这个数字上加1。 加1后的数字被存储，使得最有意义的数字在列表的头部。 思路： 此题只要理解题意就很好做，题的意思就是要求是给定一个数组表示非负整数，其高位在数组的前面，对这个整数加1。简单的大数加法，遍历数组的每位，同时处理进位，如果最后还有进位，则在数组最前面在插入1即可。 12345678910111213141516171819202122232425262728class Solution2 &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; int len = digits.size(); int remainder = 1; for (int i = len-1;i&gt;=0;i--) &#123; int val = 0; val = digits[i] + remainder; if (val == 10) &#123; remainder = 1; digits[i] = 0; &#125; else &#123; remainder = 0; digits[i] = val; &#125; &#125; if (remainder) &#123; digits.push_back(1); reverse(digits.begin(), digits.end()); &#125; return digits; &#125;&#125;; 123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; int len = digits.size(); for (int i = len - 1; i &gt;= 0; i--) &#123; if (digits[i]==9) &#123; digits[i] = 0; &#125; else &#123; ++digits[i]; return digits; &#125; &#125; digits[0] = 1; digits.push_back(0); return digits; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[64. Minimum Path Sum]]></title>
    <url>%2F2017%2F07%2F27%2F64-Minimum-Path-Sum%2F</url>
    <content type="text"><![CDATA[64. Minimum Path SumGiven a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. 题意： 给定一个充满非负数的m×n网格，从左上角到右下角找到一条路径，它沿着路径将所有数的总和最小化。 思路： 方法一： 思路同62. Unique Paths利用动态规划，但是此题在通过动态转移方程计算的时候，就是每前进一步，就计算上一步的最小值，根据之前的最小值推断出当前最小值，即局部最优构造全局最优。但是网上的好处就是没有改变原数组的值，利用新的数组来存储最小值。 12345678910111213141516171819202122232425class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(); if (m == 0) return 0; int n = grid[0].size(); if (n == 0) return 0; for (int j =1;j&lt;n;j++) &#123; grid[0][j] += grid[0][j - 1];//累加第一行从左到右行走的路径值 &#125; for (int i =1;i&lt;m;i++) &#123; grid[i][0] += grid[i - 1][0];//累加第一列从上到下行走的路径值 &#125; for (int i = 1;i&lt;m;i++) &#123; for (int j = 1;j&lt;n;j++) &#123; grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]);//状态转移方程，通过左边上上边路径值的最小值确定当前节点的路径最小值 &#125; &#125; return grid[m - 1][n - 1]; &#125;&#125;; 方法一： 思路也是动态规划，但是与方法一不同点时好处就是利用新的一维数组来存储要求元素点从上边到来的路径值，没有改变原数组的值。 1234567891011121314151617181920class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(); if (m == 0) return 0; int n = grid[0].size(); if (n == 0) return 0; vector&lt;int&gt; res(n, INT_MAX); res[0] = 0; for (int i =0;i&lt;m;i++) &#123; res[0] += grid[i][0]; for (int j =1;j&lt;n;j++) &#123; res[j] = min(res[j - 1], res[j]) + grid[i][j];//res[j-1]存储从左边到当前元素的路径值，res[j]存储的是从上边到当前元素的路径值 &#125; &#125; return res[n-1]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[63. Unique Paths II]]></title>
    <url>%2F2017%2F07%2F27%2F63-Unique-Paths-II%2F</url>
    <content type="text"><![CDATA[63. Unique Paths IIFollow up for “Unique Paths”:Now consider if some obstacles are added to the grids. How many unique paths would there be?An obstacle and empty space is marked as 1 and 0 respectively in the grid. For example,There is one obstacle in the middle of a 3x3 grid as illustrated below. 12345[ [0,0,0], [0,1,0], [0,0,0]] The total number of unique paths is 2. Note: m and n will be at most 100. 题意： 62. Unique Paths变形,现在考虑在网格中添加一些障碍物。会有多少独特的路径？ 在方格中，障碍物和空区分别标有‘1’和‘0’。 思路： 思路同62. Unique Paths](http://blog.taoaili999.cn/2017/07/27/63-Unique-Paths-II/),都是利用动态规划，不同点是要考虑出现障碍物，把有障碍物(obstacles)的地方的路径数直接设置为0，特别注意数据类型界限问题，越界会获取不到正确的数据而造成未知错误。根据障碍物出现的位置，设置辅助矩阵元素值为零主要分三种情况： 1）在矩阵第一个元素，即obstacleGrid[0][0]，这样不能到达，所以直接返回路径数为0。 2）在矩阵第一行的某个元素，即obstacleGrid[0][j]，这样第一行j列之后不能到达，第一行j列之后辅助矩阵元素直接设0。 3）在矩阵第一列的某个元素，即obstacleGrid[i][0]，这样第一列i行之后不能到达，第一列i行之后辅助矩阵元素直接设0。 4）在矩阵中某个元素，即obstacleGrid[i][j](i &gt; 0,j &gt; 0)，辅助矩阵元素直接设0。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(); if (m==0) &#123; return 0; &#125; int n = obstacleGrid[0].size(); if (n == 0) return 0; if (obstacleGrid[0][0]) &#123; return 0; &#125; vector&lt;vector&lt;double&gt;&gt; dp(m, vector&lt;double&gt;(n, 0));//这个地方如果用int类型，中间值相加的时候有可能越界，造成错误RunTime error，所以用更大的数据类型double，可以测试通过 for (int i = 0;i&lt;m;i++) &#123; if (!obstacleGrid[i][0]) &#123; dp[i][0] = 1; &#125; else break; &#125; for (int j = 1; j&lt; n; j++) &#123; if (!obstacleGrid[0][j]) &#123; dp[0][j] = 1; &#125; else break; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; if (!obstacleGrid[i][j]) &#123; dp[i][j] = dp[i][j - 1] + dp[i - 1][j]; &#125; else continue; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[62. Unique Paths]]></title>
    <url>%2F2017%2F07%2F27%2F62-Unique-Paths%2F</url>
    <content type="text"><![CDATA[62. Unique PathsA robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).How many possible unique paths are there?Above is a 3 x 7 grid. How many possible unique paths are there?Note: m and n will be at most 100. 题意： 一个机器人位于一个m*n网格的左上角（下图中标有“开始”）。机器人在坐标点方格内只能向下或向右移动。机器人正试图到达网格的右下角（下图中标有“完成”）。求有多少种可能的路径？ 思路： 动态规划，用一个辅助矩阵dp，矩阵元素值来记录到达这个单元格的所有路径条数，到达每一个单元格只能从左边或者上边到达，所以此单元格的路径数等于左边和上边单元格元素的和，所以动态转移方程：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; 1234567891011121314class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 1)); for (int i =1;i&lt;m;i++) &#123; for (int j = 1;j&lt;n;j++) &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[61. Rotate List]]></title>
    <url>%2F2017%2F07%2F26%2F61-Rotate-List%2F</url>
    <content type="text"><![CDATA[61. Rotate ListGiven a list, rotate the list to the right by k places, where k is non - negative. For example :Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL. 题意： 给定一个单链表，将单链表向右旋转k个位置，其中k是非负的，注意此处的向右旋转是循环的，旋转到投节点开始。其实就是单链表循环右移k次，每次移动一个结点。 思路： 因为可以右移就是循环移动，所以直接把单链表就是组成一个环，查找要断开的点即可。 123456789101112131415161718192021222324252627282930struct ListNode&#123; int val; ListNode *next; ListNode(int x) :val(x), next(NULL) &#123;&#125;&#125;;ListNode* rotateRight(ListNode* head, int k) &#123; if (head==NULL||head-&gt;next==NULL) &#123; return head; &#125; int length=0; ListNode *p = head; ListNode *pPre = NULL; while (p) &#123; length++; pPre = p; p = p-&gt;next; &#125; pPre-&gt;next = head; int distances = length - k % length;//k是右侧移动元素个数，总长减去得到尾指针移动步数 while (distances) &#123; pPre = pPre-&gt;next; distances--; &#125; ListNode *newHead = pPre-&gt;next; pPre-&gt;next = NULL; return newHead;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[60. Permutation Sequence]]></title>
    <url>%2F2017%2F07%2F26%2F60-Permutation-Sequence%2F</url>
    <content type="text"><![CDATA[60. Permutation SequenceThe set [1,2,3,…,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order,We get the following sequence (ie, for n = 3): “123” “132” “213” “231” “312” “321”Given n and k, return the kth permutation sequence. Note: Given n will be between 1 and 9 inclusive. 题意： 集合[ 1,2,3，…，n ]共包含n!独特的排列。可以列举和标记所有的顺序排列，给出n和k，返回n的集合中第k个排列。n在1到9之间。 思路： 思路是这样的，比如当前长度是n，我们知道每个相同的起始元素对应(n-1)!个permutation，也就是(n-1)!个permutation后会换一个起始元素。因此，只要当前的k进行(n-1)!取余，得到的数字就是当前剩余数组的index，如此就可以得到对应的元素。如此递推直到数组中没有元素结束。实现中我们要维护一个数组来记录当前的元素，每次得到一个元素加入结果数组，然后从剩余数组中移除。 假设有四位数字{1， 2， 3， 4}，那么他们能够产生的排列数是什么呢？ 12341 + &#123;2, 3, 4&#125;2 + &#123;1, 3, 4&#125;3 + &#123;1, 2, 4&#125;4 + &#123;1, 2, 3&#125; 其实就是选定第一位数字后，其他剩下的数字进行排列组合，就能求出以该数字打头的所有排列组合。想必已经能发现一些规律了，我们干脆再举一个具体的例子，比如我们现在想要找第14个数，那么由于14 = 6 + 6 + 2。因此第一个数打头的是3，然后再求{1, 2, 4}中第二个排列组合数，答案是”142”。所以最终答案就是”3142”啦。 这里有一些问题是需要我们注意的：1）构造排列数从最高位开始，当选出一个数字后，就应当把这个数字erase掉，防止后面又出现；2）我们所要求的第k个数需要在每次循环中减去对应的值；3）注意程序中的数组是从0开始的，但题目的输入是从1开始计数的。 1234567891011121314151617181920212223242526272829class Solution &#123;public: string getPermutation(int n, int k) &#123; string res; vector&lt;int&gt; permutation(n + 1, 1); //1 构造1到n的排列数组 int fac = 1; for (int i = 2; i &lt; n; i++) &#123; fac *= i; &#125; //2 构造查找最高位的字符数组 vector&lt;char&gt; vals = &#123; '1','2','3','4','5','6','7','8','9' &#125;; int level = n - 1; k--;////vals数组从0开始计数，k所以要减1 while (level &gt;= 0) &#123; int index = k / fac;//vals数组从0开始计数，k所以要减1，fac对应的是去掉最高位后后面n-1位的排列数 res += vals[index]; k %= fac; vals.erase(vals.begin() + index); if (level) fac = fac / level; level--; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[59. Spiral Matrix II]]></title>
    <url>%2F2017%2F07%2F26%2F59-Spiral-Matrix-II%2F</url>
    <content type="text"><![CDATA[59. Spiral Matrix IIGiven an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. For example,Given n = 3,You should return the following matrix: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 题意： 给定一个整数n，生成一个以1到n的平方根为螺旋顺序元素的螺旋矩阵。 思路： 主要参照54. Spiral Matrix方法二。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt;&gt; res(n,vector&lt;int&gt;(n, 0)); int l = 0, r = n - 1, u = 0, d = n - 1, k = 1; while (1) &#123; //up for (int col = l;col&lt;=r;col++) &#123; res[u][col] = k++; &#125; if (++u&gt;d) break; //right for (int row = u; row &lt;= d; row++) &#123; res[row][r] = k++; &#125; if (--r &lt; l) break; //down for (int col = r; col &gt;= l; col--) &#123; res[d][col] = k++; &#125; if (--d &lt; u) break; //left for (int row = d; row &gt;= u; row--) &#123; res[row][l] = k++; &#125; if (++l &gt; r) break; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[58. Length of Last Word]]></title>
    <url>%2F2017%2F07%2F26%2F58-Length-of-Last-Word%2F</url>
    <content type="text"><![CDATA[58. Length of Last WordGiven a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. For example,Given s = “Hello World”,return 5. 题意： 给定一个字符串s由大/小写字母和空格字符组成，返回字符串中最后一个单词的长度。如果最后一个单词不存在，返回0。 思路： 考虑特殊情况三种情况： 1.整个字符串为空时 2.字符串由无数的空格组成时 3.字符串最后以空格结尾时 12345678910111213141516171819class Solution &#123;public: int lengthOfLastWord(string s) &#123; int res = 0; if (s.empty() || s == " ") return 0; auto itr = s.find_last_of(' '); while (itr == s.size() - 1) &#123; if (itr == 0) &#123; return res; &#125; s = s.substr(0, itr); itr = s.find_last_of(' '); &#125; s = s.substr(itr + 1); return s.size(); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[57. Insert Interval]]></title>
    <url>%2F2017%2F07%2F25%2F57-Insert-Interval%2F</url>
    <content type="text"><![CDATA[57. Insert IntervalGiven a set of non - overlapping intervals, insert a new interval into the intervals(merge if necessary).You may assume that the intervals were initially sorted according to their start times. Example 1:Given intervals[1, 3], [6, 9], insert and merge[2, 5] in as[1, 5], [6, 9]. Example 2 :​ Given[1, 2], [3, 5], [6, 7], [8, 10], [12, 16], insert and merge[4, 9] in as[1, 2], [3, 10], [12, 16].​ This is because the new interval[4, 9] overlaps with[3, 5], [6, 7], [8, 10]. 题意： 给定一组不重叠的区间，在给定区间中插入一个新的区间（必要时合并）。假设区间的根据它们的开始时间排序的。注意：区间初始按开始时间排过序。 思路： 这道题的要求是给定一组非重叠且开始时间有序的间隔，在其中插入一个新的间隔。这道题可以借助56. Merge Intervals里面的代码，先将新的间隔加入到数组中，然后合并即可。时间复杂度是O(nlogn)。 事实上，也可以不排序，直接插入时间间隔，插入的时间间隔的位置可以分成三部分： a 插入位置左侧 b 插入位置（有重叠或无重叠） c 插入位置右侧 这三个部分分别处理，只有在插入位置处理可能存在的情况即可。 时间复杂度：O(n) 空间复杂度：O(n) 123456789101112131415161718192021222324252627vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; if (intervals.empty()) &#123; intervals.push_back(newInterval); return intervals; &#125; vector&lt;Interval&gt; result; int i = 0; while (i &lt; intervals.size()&amp;&amp;intervals[i].end&lt;newInterval.start) &#123; result.push_back(intervals[i]); i++; &#125; result.push_back(newInterval); while (i&lt;intervals.size()&amp;&amp;result[result.size()-1].end&gt;=intervals[i].start) &#123; result[result.size() - 1].start = min(result[result.size() - 1].start, intervals[i].start); result[result.size() - 1].end = max(result[result.size() - 1].end, intervals[i].end); i++; &#125; while (i&lt;intervals.size()) &#123; result.push_back(intervals[i]); i++; &#125; return result;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[56. Merge Intervals]]></title>
    <url>%2F2017%2F07%2F25%2F56-Merge-Intervals%2F</url>
    <content type="text"><![CDATA[56. Merge IntervalsGiven a collection of intervals, merge all overlapping intervals. For example,Given[1, 3], [2, 6], [8, 10], [15, 18],return[1, 6], [8, 10], [15, 18]. 题意： 给定一个间隔集合，合并所有重叠的区间间隔。 思路： （1）先将目标区间数组按X轴从小到大排序。例如：[2 ,3][1, 2][3, 9] -&gt;[1, 2][2, 3][3, 9] （2）扫描排序后的目标区间数组，将这些区间合并成若干个互不相交的区间。例如[2, 3][1, 2][4, 9] -&gt;[1, 3][4, 9] 这里分三种情况： a :[1, 3][2, 6] -&gt;[1, 6] 第一个区间的end大于等于第二个区间的start, 同时第二个区间的end大于第一个区间的end b :[1, 7][2, 4] -&gt;[1, 7] 第一个区间的end大于等于第二个区间的start, 同时第二个区间的end小于第一个区间的end c :[1, 2][3, 4] -&gt;[1, 2][3, 4] 第一个区间的end小于第二个区间的start 12345678910111213141516171819202122232425262728293031323334353637/*** Definition for an interval.*/struct Interval &#123; int start; int end; Interval() : start(0), end(0) &#123;&#125; Interval(int s, int e) : start(s), end(e) &#123;&#125;&#125;;class Solution&#123; vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; vector&lt;Interval&gt; result; if (intervals.size() &lt;= 1) &#123; return intervals; &#125; sort(intervals.begin(), intervals.end(), [](Interval a, Interval b) &#123;return a.start &lt; b.start; &#125;); Interval node = intervals[0]; for (int i=1;i&lt;intervals.size();i++) &#123; Interval tempNode = intervals[i]; if (node.end&lt;tempNode.start) &#123; result.push_back(node); node = tempNode; continue; &#125; else &#123; node.end = max(node.end, tempNode.end); &#125; &#125; result.push_back(node);//用于控制最后一个节点区间 return result; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[55. Jump Game]]></title>
    <url>%2F2017%2F07%2F25%2F55-Jump-Game%2F</url>
    <content type="text"><![CDATA[55. Jump GameGiven an array of non-negative integers, you are initially positioned at the first index of the array.Each element in the array represents your maximum jump length at that position.Determine if you are able to reach the last index. For example:A = [2,3,1,1,4], return true.A = [3,2,1,0,4], return false. 题意： 给定一组非负整数，首先定位在数组的第一个索引中。数组中的每个元素表示您在该位置的最大跳转长度。确定是否能够到达最后一个索引。 思路： 方法一： 用一个变量来存储这个变量所能到达的数组的最远坐标maxReach = i + nums[i]，然后遍历数组下一个元素，比较下个元素的数组索引i与maxReach的大小，如果maxReach小于i,说明最远距离不能到达最近的节点，那么肯定不能到末尾，如果maxReach大于i,说明最远距离能到达最近的节点，然后再去这个最近节点的最远到达坐标maxReach,依次查找，当maxReach大于等于len-1的时候说明一定能到数组的末尾，确实是典型的贪心算法，总是找满足条件最好的结果，然后向前推进，直到找到结果。 12345678910111213141516171819class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int maxReach = 0; for (int i =0;i&lt;len;i++) &#123; if (maxReach&lt;i) &#123; return false; &#125; if (maxReach&gt;=len-1) &#123; return true; &#125; maxReach = max(maxReach, i + nums[i]); &#125; &#125;&#125;; 方法二： 和方法一类似，也是从前往后遍历数组，但是用一个变量来保存所能走的步数相对于当前数组元素坐标索引，每次遍历一个元素代表向前走一步step–，然后获取当前元素nums[i]的值和step的最大值，确定往后还能移动的最大步数，也是典型的贪心算法，不断的更新最远步长step，然后判断是否能满足到达末尾，最后step&gt;=0肯定能走到末尾。 1234567891011121314151617class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int step = nums[0];//初始化最初能走的最远步长 for (int i = 1; i &lt; len; i++) &#123; step--; if (step&lt;0) &#123; return false; &#125; step = max(step, nums[i]); &#125; return step &gt;= 0; &#125;&#125;; 方法三： 从后往前遍历数组，判断前一个元素是否能到达它后面的元素，根据如果能到达，则往前遍历，把刚刚那个元素做为到达的目标点元素，在判断它之前的元素能否到达它，一次往前遍历，如果能走到第一个元素，说明能到达最后元素，否则不能。 1234567891011121314151617class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int dest = len - 1; int cur_pos = len - 2; while (cur_pos&gt;=0) &#123; if (cur_pos+nums[cur_pos]&gt;=dest) &#123; dest = cur_pos; &#125; cur_pos--; &#125; return dest == 0; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[54. Spiral Matrix]]></title>
    <url>%2F2017%2F07%2F25%2F54-Spiral-Matrix%2F</url>
    <content type="text"><![CDATA[54. Spiral MatrixGiven a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. For example,Given the following matrix:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]You should return [1,2,3,6,9,8,7,4,5]. 题意： 给定一个m×n元素的矩阵（m行，n列），以螺旋顺序返回矩阵的所有元素（螺旋是顺时针方向）。 思路： 方法一： 分四个不同的方向分别读取数组的值，重点是控制横坐标和纵坐标的变化，但是使用一个标记矩阵来记录已经访问过的元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; res; int m = matrix.size(); if (m==0) &#123; return res; &#125; int n = matrix[0].size(); if (n==0) &#123; return res; &#125; vector&lt;vector&lt;int&gt;&gt; flag(m, vector&lt;int&gt;(n, 0));//标记矩阵 int i = 0, j = 0; while (i&lt;m&amp;&amp;j&lt;n&amp;&amp; !flag[i][j])//只控制了i&lt;m&amp;&amp;j&lt;n条件，没能更精确控制行列坐标，所以借助标记数组标记已经访问过的元素，防止出错 &#123; //up while (j &lt; n &amp;&amp; !flag[i][j]) &#123; res.push_back(matrix[i][j]); flag[i][j] = 1; j++; &#125; j--; i++; //right while (i&lt;m&amp;&amp;!flag[i][j]) &#123; res.push_back(matrix[i][j]); flag[i][j] = 1; i++; &#125; i--; j--; //down while (j &gt;= 0 &amp;&amp; !flag[i][j]) &#123; res.push_back(matrix[i][j]); flag[i][j] = 1; j--; &#125; j++; i--; //left while (i &gt;=0 &amp;&amp; !flag[i][j]) &#123; res.push_back(matrix[i][j]); flag[i][j] = 1; i--; &#125; i++; j++; &#125; return res; &#125;&#125;; 方法二： 也是分四个不同的方向分别读取数组的值，但是此方法控制横坐标和纵坐标的变化非常精细，可以省去标记矩阵来记录已经访问过的元素，完成螺旋的遍历,思路比方法一清晰，更好实现，代码简洁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int m = matrix.size(); if (m == 0) &#123; return &#123;&#125;; &#125; int n = matrix[0].size(); if (n == 0) &#123; return &#123;&#125;; &#125; vector&lt;int&gt; res(m*n); int l = 0, r = n - 1, u = 0, d = m - 1, k = 0; while (1) &#123; // up for (int col = l;col&lt;=r;col++) &#123; res[k++] = matrix[l][col]; &#125; if(++u&gt;d) break; //right for (int row = u; row &lt;= d; row++) &#123; res[k++] = matrix[row][r]; &#125; if (--r &lt; l) break; //down for (int col = r; col &gt;=l; col--) &#123; res[k++] = matrix[d][col]; &#125; if (--d &lt; u) break; //left for (int row = d; row &gt;= u; row--) &#123; res[k++] = matrix[row][l]; &#125; if (++l &gt; r) break; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[53. Maximum Subarray]]></title>
    <url>%2F2017%2F07%2F25%2F53-Maximum-Subarray%2F</url>
    <content type="text"><![CDATA[53. Maximum SubarrayFind the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. More practice:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. 题意： 在数组中找到连续子数组（子数组至少包含一个数字），使连续子数组的和最大。 如果您已经解决了O（n）的解决方案，请尝试使用分而治之的方法编写另一个解决方案，这种解法更好。 思路： 保留一个求和值，一个结果值，求和值小于零时直接置为0，结果值不断和求和值不断比较求出最大值。 12345678910111213141516171819202122232425262728class Solution &#123;public: //For example, given the array [-2,1,-3,4,-1,2,1,-5,4], //the contiguous subarray [4,-1,2,1] has the largest sum = 6. int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int res = INT_MIN; int len = nums.size(); if (len == 0) &#123; return 0; &#125; if (len == 1) &#123; return nums[0]; &#125; int maxVal = 0; for (int i = 0; i &lt; len; i++) &#123; maxVal += nums[i]; res = max(maxVal, res); if (maxVal &lt; 0) &#123; maxVal = 0; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[52. N-Queens II]]></title>
    <url>%2F2017%2F07%2F24%2F52-N-Queens-II%2F</url>
    <content type="text"><![CDATA[52. N - Queens IIFollow up for N-Queens problem. Now, instead outputting board configurations, return the total number of distinct solutions. 题意： 跟进的N皇后问题。现在，N皇后的输出板配置，返回不同解决方案的总数。 思路： 此题其实和51. N - Queens是同一个题，不同的地方是51. N - Queens是求所有的结果集返回，此题要求的是求得结果集的个数，也有三种方法，具体思路见51. N - Queens。 方法一： 递归回溯，同51. N - Queens方法一。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int totalNQueens(int n) &#123; vector&lt;int&gt; check(n, 0); int counts = 0;//用来记录结果集的个数 placeQueens(counts, check, 0, n); return counts; &#125; void placeQueens(int &amp;counts, vector&lt;int&gt; check,int row, int n) &#123; if (row&gt;n-1) &#123; counts++; return; &#125; for (int j = 0;j&lt;n;j++) &#123; if (placeIsValid(check,row,j)) &#123; check[row] = j; placeQueens(counts, check, row + 1, n); &#125; &#125; &#125; int placeIsValid(vector&lt;int&gt; check, int row, int col) &#123; for (int i = 0; i &lt; row; i++) &#123; if (check[i]==col||abs(check[i]-col)==abs(i-row)) &#123; return 0; &#125; &#125; return 1; &#125;&#125;; 方法二： 非递归实现，同51. N - Queens方法二。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution3 &#123;public: int totalNQueens(int n) &#123; vector&lt;int&gt; check(n, INT_MIN); int counts = 0; int i = 0, j = 0; while (i&lt;n) &#123; while (j&lt;n) &#123; if (placeIsValid(check,i,j)) &#123; check[i] = j; j = 0;//第i行放置皇后以后，需要继续探测下一行的皇后位置，所以此处将j清零，从下一行的第0列开始逐列探测 !!!!!!!!!!!!!!!!! break; &#125; else &#123; j++; &#125; &#125; if (check[i]==INT_MIN) &#123; if (i==0) &#123; break; &#125; else &#123; i--; j = check[i] + 1; check[i] = INT_MIN; continue; &#125; &#125; if (i == n-1) &#123; counts++; j = check[i] + 1; check[i] = INT_MIN; continue; &#125; i++; &#125; return counts; &#125; int placeIsValid(vector&lt;int&gt; check, int row, int col) &#123; for (int i = 0; i &lt; row; i++) &#123; if (check[i] == col || abs(check[i] - col) == abs(i - row)) &#123; return 0; &#125; &#125; return 1; &#125;&#125;; 方法三： 递归回溯位运算实现，同51. N - Queens方法三。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: int counts = 0; int upperLimit = 1; int totalNQueens(int n) &#123; upperLimit = (upperLimit &lt;&lt; n) - 1; placeQueens(0, 0, 0); return counts; &#125; void placeQueens(int row, int lXie, int rXie) &#123; if (row==upperLimit)//row是记录每一行的列位置皇后，当等于upperLimit最大限制的时候说明找到一个满足条件的皇后矩阵 &#123; counts++; return; &#125; //~按位取反 ^按位异或 int pos = upperLimit&amp;~(row | lXie | rXie);//获取此时行的所有可插入皇后的位置 while (pos)//pos不为0说明肯定有位置可以放皇后 &#123; //这个地方思想是按位取反加1，然后为了取到最右面的1必须与原pos相与，如果按自己下面的想法没有相与，导致出错 //int p = pos; //p = ~p + 1;//先确定能放在此行的最右面的皇后的位置p //可以改为形式1 int p = pos &amp; (~pos + 1); // 拷贝pos最右边为1的bit，其余bit置0 // 也就是取得可以放皇后的最右边的列 //可以改为形式2 /*pos &amp; -pos 的意思就是取最右边的 1 再组成二进制数，相当于 pos &amp;（~pos + 1），因为取反以后刚好所有数都是相反的（怎么听着像废话），再加 1 ，就是改变最低位，如果低位的几个数都是1，加的这个 1 就会进上去，一直进到 0 ，在做与运算就和原数对应的 1 重合了。举例可以说明： 原数 0 0 0 0 1 0 0 0 原数 0 1 0 1 0 0 1 1 取反 1 1 1 1 0 1 1 1 取反 1 0 1 0 1 1 0 0 加1 1 1 1 1 1 0 0 0 加1 1 0 1 0 1 1 0 1 与运算 0 0 0 0 1 0 0 0 and 0 0 0 0 0 0 0 1 其中呢，这个取反再加 1 就是补码，and 运算 与负数，就是按位和补码与运算。*/ //long p = pos &amp; -pos; //p记录的是可以放皇后的最右面的一个 // 将pos最右边为1的bit清零 // 也就是为获取下一次的最右可用列使用做准备， // 程序将来会回溯到这个位置继续试探 pos -= p; //去掉最右面一个选取的位置，进行递归判断下一个最右面皇后的位置 placeQueens(row + p, (lXie + p) &lt;&lt; 1, (rXie + p) &gt;&gt; 1); &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51. N-Queens]]></title>
    <url>%2F2017%2F07%2F22%2F51-N-Queens%2F</url>
    <content type="text"><![CDATA[51. N - QueensThe n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.Given an integer n, return all distinct solutions to the n-queens puzzle.Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively. For example,There exist two distinct solutions to the 4-queens puzzle:[ [“.Q..”, // Solution 1 “…Q”, “Q…”, “..Q.”], [“..Q.”, // Solution 2 Q…”, “…Q”, “.Q..”]] 题意： n皇后难题的问题是将n个皇后放在在n×n棋盘，没有任何两个皇后互相攻击。给定一个整数n，返回所有不同的解决n皇后问题的解。每个解决方案包含一个独特的N皇后的位置板配置，分别用“Q”和“.”都表明一个皇后和一个空的空间。 思路： 求解N皇后问题是算法中回溯法应用的一个经典案例, 回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。 在现实中，有很多问题往往需要我们把其所有可能穷举出来，然后从中找出满足某种要求的可能或最优的情况，从而得到整个问题的解。回溯算法就是解决这种问题的“通用算法”，有“万能算法”之称。N皇后问题在N增大时就是这样一个解空间很大的问题，所以比较适合用这种方法求解。这也是N皇后问题的传统解法。 12345678910111213141516171819下面是算法的高级伪码描述，这里用一个N*N的矩阵来存储棋盘： 1) 算法开始, 清空棋盘，当前行设为第一行，当前列设为第一列 2) 在当前行，当前列的位置上判断是否满足条件(即保证经过这一点的行,列与斜线上都没有两个皇后)，若不满足，跳到第4步 3) 在当前位置上满足条件的情形： 在当前位置放一个皇后，若当前行是最后一行，记录一个解； 若当前行不是最后一行，当前行设为下一行, 当前列设为当前行的第一个待测位置； 若当前行是最后一行，当前列不是最后一列，当前列设为下一列； 若当前行是最后一行，当前列是最后一列，回溯，即清空当前行及以下各行的棋盘，然后，当前行设为上一行，当前列设为当前行的下一个待测位置； 以上返回到第2步 4) 在当前位置上不满足条件的情形： 若当前列不是最后一列，当前列设为下一列，返回到第2步; 若当前列是最后一列了，回溯，即，若当前行已经是第一行了，算法退出，否则，清空当前行及以下各行的棋盘，然后，当前行设为上一行，当前列设为当前行的下一个待测位置，返回到第2步; 算法的基本原理是上面这个样子，但不同的是用的数据结构不同，检查某个位置是否满足条件的方法也不同。为了提高效率，有各种优化策略，如多线程，多分配内存表示棋盘等。 在具体解决该问题时，可以将其拆分为几个小问题。首先就是在棋盘上如何判断两个皇后是否能够相互攻击，使用一个一维数组来存储棋盘，在某个位置上是否有皇后可以相互攻击的判断也很简单。具体细节如下： 把棋盘存储为一个N维数组a[N]，数组中第i个元素的值代表第i行的皇后位置，这样便可以把问题的空间规模压缩为一维O(N)，在判断是否冲突时也很简单，首先每行只有一个皇后，且在数组中只占据一个元素的位置，行冲突就不存在了，其次是列冲突，判断一下是否有a[i]与当前要放置皇后的列j相等即可。至于斜线冲突，通过观察可以发现所有在斜线上冲突的皇后的位置都有规律即它们所在的行列互减的绝对值相等，即| row – i | = | col – a[i] | 。这样某个位置是否可以放置皇后的问题已经解决。 123456789101112131415161718 //下面要解决的是使用何种方法来找到所有的N皇后的解。上面说过该问题是回溯法的经典应用，所以可以使用回溯法来解决该问题，具体实现也有两个途径，递归和非递归。递归方法较为简单，大致思想如下：void queen(int row)&#123; if (n == row) //如果已经找到结果，则打印结果 print_result(); else &#123; for (k=0 to N) &#123; //试探第row行每一个列 if (can_place(row, k) &#123; place(row, k); //放置皇后 queen(row + 1); //继续探测下一行 &#125; &#125; &#125;&#125;//该方法由于在探测第i行后，如果找到一个可以放置皇后的位置j后，则会递归探测下一行，结束后则会继续探测i行j+1列，故可以找到所有的N皇后的解。 方法一： 递归实现，主要思路如上述思路所述。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/****************************************************************************************************************You are here! Your runtime beats 18.30% of cpp submissions.9 / 9 test cases passed.Status: AcceptedRuntime: 32 ms****************************************************************************************************************/class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;vector&lt;string&gt;&gt; res; /* *使用一个一维数组表示皇后的位置 * 其中数组的下标表示皇后所在的行 * 数组元素的值表示皇后所在的列 * 这样设计的棋盘，所有皇后必定不在同一行，于是行冲突就不存在了 */ vector&lt;int&gt; check(n, 0); placeQueens(res, check, 0, n); return res; &#125; void placeQueens(vector&lt;vector&lt;string&gt;&gt; &amp;res,vector&lt;int&gt; check, int row,int n) &#123; if (row&gt;n-1) &#123; string rowStr(n, '.'); vector&lt;string&gt; tempQueens(n, rowStr); for (int i = 0;i&lt;n;i++) &#123; tempQueens[i][check[i]] = 'Q'; &#125; res.push_back(tempQueens); return; &#125; for (int j = 0; j &lt; n; j++)//控制每一行的列 &#123; if (checkPlace(row,j,check))//通过本行是否可以放皇后做为控制回溯的条件 &#123; check[row] = j; placeQueens(res, check, row + 1, n);//当前行找到合适解，递归进行下一行寻找皇后位置的解 &#125; &#125; &#125; int checkPlace(int row, int col,vector&lt;int&gt; check) &#123;//检测第row行，第col列是否可以放皇后 for (int i = 0;i&lt;row;i++) &#123; if (check[i]==col||abs(check[i]-col)==abs(row-i)) &#123; return 0; &#125; &#125; return 1; &#125;&#125;; 方法二： 一般来说递归的效率比较差，下面重点讨论一下该问题的非递归实现。非递归方法的一个重要问题时何时回溯及如何回溯的问题。程序首先对N行中的每一行进行探测，寻找该行中可以放置皇后的位置，具体方法是对该行的每一列进行探测，看是否可以放置皇后，如果可以，则在该列放置一个皇后，然后继续探测下一行的皇后位置。如果已经探测完所有的列都没有找到可以放置皇后的列，此时就应该回溯，把上一行皇后的位置往后移一列，如果上一行皇后移动后也找不到位置，则继续回溯直至某一行找到皇后的位置或回溯到第一行，如果第一行皇后也无法找到可以放置皇后的位置，则说明已经找到所有的解程序终止。如果该行已经是最后一行，则探测完该行后，如果找到放置皇后的位置，则说明找到一个结果，打印出来。但是此时并不能再此处结束程序，因为我们要找的是所有N皇后问题所有的解，此时应该清除该行的皇后，从当前放置皇后列数的下一列继续探测。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/****************************************************************************************************************You are here! Your runtime beats 18.30% of cpp submissions.9 / 9 test cases passed.Status: AcceptedRuntime: 32 ms****************************************************************************************************************/class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;vector&lt;string&gt;&gt; res; /* *使用一个一维数组表示皇后的位置 * 其中数组的下标表示皇后所在的行 * 数组元素的值表示皇后所在的列 * 这样设计的棋盘，所有皇后必定不在同一行，于是行冲突就不存在了 */ vector&lt;int&gt; check(n, INT_MIN); int i = 0, j = 0; while (i&lt;n) &#123; while (j&lt;n)// 对i行的每一列进行探测，看是否可以放置皇后 &#123; if (checkPlace(check,i,j))//该位置可以放置皇后 &#123; check[i] = j;//第i行放置皇后 j = 0;//第i行放置皇后以后，需要继续探测下一行的皇后位置，所以此处将j清零，从下一行的第0列开始逐列探测 break; &#125; else &#123; j++;//继续探测下一列 &#125; &#125; if (check[i]==INT_MIN)//第i行没有找到可以放置皇后的位置 &#123; if (i==0) // 回溯到第一行，仍然无法找到可以放置皇后的位置，则说明已经找到所有的解，程序终止 &#123; break; &#125; else //没有找到可以放置皇后的列，此时就应该回溯 &#123; i--; j = check[i] + 1;//把上一行皇后的位置往后移一列 check[i] = INT_MIN;//把上一行皇后的位置清除，重新探测 continue; &#125; &#125; if (i==n-1) //最后一行找到了一个皇后位置，说明找到一个结果，打印出来 &#123; string rowStr(n, '.'); vector&lt;string&gt; tempQueens(n, rowStr); for (int i = 0; i &lt; n; i++) &#123; tempQueens[i][check[i]] = 'Q'; &#125; res.push_back(tempQueens); //不能在此处结束程序，因为我们要找的是N皇后问题的所有解，此时应该清除该行的皇后，从当前放置皇后列数的下一列继续探测。 j = check[i] + 1;//从最后一行放置皇后列数的下一列继续探测 check[i] = INT_MIN;//清除最后一行的皇后位置 continue; &#125; i++; //继续探测下一行的皇后位置 &#125; return res; &#125; int checkPlace(vector&lt;int&gt; check,int row, int col) &#123; for (int i =0;i&lt;row;i++) &#123; if (check[i]==col||abs(check[i]-col)==abs(i-row)) &#123; return 0; &#125; &#125; return 1; &#125;&#125;; 方法三： 递归实现，主要思路如上述思路所述，但是此方法是利用位运算之间的关系来判断皇后放的位置，效率高(但是自己也不太理解)。 1234567891011121314151617181920212223242526272829303132333435363738394041/***************************************************************************************************************You are here! Your runtime beats 48.15% of cpp submissions.9 / 9 test cases passed.Status: AcceptedRuntime: 9 ms****************************************************************************************************************/class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; res; int upperLimit = 1; vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n)&#123; upperLimit = (upperLimit &lt;&lt; n) - 1; vector&lt;string&gt; tempRes(n, string(n, '.')); placeQueens(0, 0, 0,tempRes,0); return res; &#125; void placeQueens(int row, int lXie, int rXie,vector&lt;string&gt; tempRes,int lineNum) &#123; if (row==upperLimit) &#123; res.push_back(tempRes); return; &#125; int n = tempRes.size(); int pos = upperLimit&amp;~(row | lXie | rXie); while (pos) &#123; int p = pos&amp;-pos; int tempP = p; int counts = 0; while (tempP) &#123; tempP = tempP &gt;&gt; 1; counts++; &#125; tempRes[lineNum][n - counts] = 'Q'; pos -= p; placeQueens(row + p, (lXie + p) &lt;&lt; 1, (rXie + p) &gt;&gt; 1, tempRes,lineNum+1); tempRes[lineNum][n - counts] = '.'; &#125; &#125;&#125;; ###]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[49. Group Anagrams]]></title>
    <url>%2F2017%2F07%2F22%2F49-Group-Anagrams%2F</url>
    <content type="text"><![CDATA[49. Group AnagramsGiven an array of strings, group anagrams together. For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],Return : [ [“ate”, “eat”, “tea”], [“nat”, “tan”], [“bat”]​ ]Note: All inputs will be in lower - case. 题意： 给定一个字符串数组，把字符相同的字符串放在一起。所有的输入都是小写字母。 思路： 主要是利用hash映射表来判断含有相同字符的字符串，但是字符串中的字符顺序不同，所以要对每个string字符转进行字典排序，由于对单词排序时，题目已经限定了单词只可能是26个小写字母组成的，所以可以使用计数排序，进一步加快算法的速度（排序部分速度从O(nlogn)变为O(n)）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; vector&lt;vector&lt;string&gt;&gt; res; if (strs.empty()) &#123; return res; &#125; map&lt;string, vector&lt;string&gt;&gt; hash; sort(strs.begin(), strs.end()); for (int i = 0;i&lt;strs.size();i++) &#123; string t = strs[i]; t = sortStr(t);//像后面Internet上一样，利用计数排序提高效率 if (hash.count(t)) &#123; hash[t].push_back(strs[i]); &#125; else &#123; vector&lt;string&gt; tempS; tempS.push_back(strs[i]); hash.insert(make_pair(t, tempS)); &#125; &#125; for (auto tr : hash) &#123; res.push_back(tr.second); &#125; return res; &#125; string sortStr(string s)//计数排序，提高排序效率 &#123; vector&lt;int&gt; counts(26,0); for (auto c : s) &#123; ++counts[c - 'a']; &#125; string res=""; for (int i = 0;i&lt;26;i++) &#123; while (counts[i]) &#123; res += (i + 'a'); counts[i]--; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[48. Rotate Image]]></title>
    <url>%2F2017%2F07%2F21%2F48-Rotate-Image%2F</url>
    <content type="text"><![CDATA[48. Rotate ImageYou are given an n x n 2D matrix representing an image.Rotate the image by 90 degrees (clockwise). Follow up: Could you do this in-place? 题意： 给定一个表示图像的n×n矩阵。将图像旋转90度（顺时针方向）。在常量空间复杂度下实现。 思路： 把n*n的矩阵按顺时针方向旋转90度，第一行变为最后一列，第二行变为倒数第二列。。。。。依次类推，所以旋转规律就是先按对角线反转，把除了对角线外的所有元素的从行变到相应的列，这样对称翻转后行原来相对顺序到列会成为逆序，所以按行反转就可得到旋转矩阵。 代码的主要难点就是要弄清楚行列坐标的控制条件。 例子： 1234567891011121314151617181920212223242526 // 顺时针反转 // 先进上下中轴进行行行交换, 再进行关于左上到右下对角线对称轴进行交换 * 1 2 3 7 8 9 7 4 1 * 4 5 6 =&gt; 4 5 6 =&gt; 8 5 2 * 7 8 9 1 2 3 9 6 3void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; reverse(matrix.begin(), matrix.end()); for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = i + 1; j &lt; matrix[i].size(); ++j) swap(matrix[i][j], matrix[j][i]); &#125;&#125; // 逆时针反转 // 先进左右中轴进行列列交换, 再进行关于左上到右下对角线对称轴进行交换 * 1 2 3 3 2 1 3 6 9 * 4 5 6 =&gt; 6 5 4 =&gt; 2 5 8 * 7 8 9 9 8 7 1 4 7 void anti_rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; for (auto vi : matrix) reverse(vi.begin(), vi.end()); for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = i + 1; j &lt; matrix[i].size(); ++j) swap(matrix[i][j], matrix[j][i]); &#125;&#125; 12345678910111213141516171819class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); for (int i =0;i&lt;n;i++)//先进行关于左下到右上的对角线对称轴进行交换 &#123; for (int j = 0; j &lt; n-i-1; j++) &#123; swap(matrix[i][j], matrix[n - 1 - j][n - 1 - i]); &#125; &#125; int mid = n / 2; for (int i = 0; i &lt; mid; i++)//再进行关于上下行中轴进行交换 &#123; for (int j = 0; j &lt; n; j++) &#123; swap(matrix[i][j], matrix[n - 1 - i][j]); &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[47. Permutations II]]></title>
    <url>%2F2017%2F07%2F21%2F47-Permutations-II%2F</url>
    <content type="text"><![CDATA[47. Permutations IIGiven a collection of numbers that might contain duplicates, return all possible unique permutations. For example,[1,1,2] have the following unique permutations:[ [1,1,2], [1,2,1], [2,1,1]] 题意： 方法一： 意思同46. Permutations，不同的就是给定的数组集合是有重复元素出现的，但是结果集中不能出现重复的结果排列。 思路： 递归回溯法，先把给定集合排序，然后在递归回溯的过程中，当遍历同一层的元素的时候要比较元素是否相等，相等要进行剪枝，因为同一层相同元素出现并入结果集中肯定会出现重复结果组合。 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end());//先进行排序，便于剪枝 int sizes = nums.size(); backtracting(nums, 0, sizes); return res; &#125; void backtracting(vector&lt;int&gt; nums, int index, int sizes) &#123; if (index==sizes) &#123; res.push_back(nums); return; &#125; for (int i = index; i &lt; sizes; i++) &#123; if (i != index&amp;&amp;nums[i] == nums[index])//同层出现相同元素，直接跳过遍历下一个元素，i!=index说明i和index所指向的元素位于同一层 &#123; continue; &#125; swap(nums[i], nums[index]); backtracting(nums, index + 1, sizes); &#125; &#125;&#125;; 方法二： 直接利用C++的STL函数库next_permutation()函数，函数详情next_permutation() 。 12345678910111213class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); res.push_back(nums); while (next_permutation(nums.begin(),nums.end())) &#123; res.push_back(nums); &#125; return res; &#125;&#125;; Java Code：12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; if (null == nums) &#123; return new ArrayList(); &#125; int len = nums.length; if (len == 0) &#123; return new ArrayList(); &#125; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); List&lt;Integer&gt; elements = new ArrayList(); int[] flag = new int[len]; nextPermutations(nums, flag, elements, res); return res; &#125; public void nextPermutations(int[] nums, int[] flag, List&lt;Integer&gt; elements, List&lt;List&lt;Integer&gt;&gt; res) &#123; if (elements.size() == nums.length) &#123; res.add(elements); return; &#125; for (int i = 0;i &lt; nums.length;i++) &#123; if (flag[i] == 0) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; flag[i - 1] == 1) &#123; continue; &#125; flag[i] = 1; List&lt;Integer&gt; tmpElements = new ArrayList(elements); tmpElements.add(nums[i]); nextPermutations(nums, flag, tmpElements, res); flag[i] = 0; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[46. Permutations]]></title>
    <url>%2F2017%2F07%2F20%2F46-Permutations%2F</url>
    <content type="text"><![CDATA[46. PermutationsGiven a collection of distinct numbers, return all possible permutations. For example,[1,2,3] have the following permutations:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 题意： 给定一组不同的数字，求出所有可能的排列，也就是求出一个数组的序列的全排列。 思路： 方法一： 这个题的主要解决办法就是递归回溯法，每递归一层，取数列中的一个元素，当满足原素组大小时，得到一个结果组合，放入结果集中，然后回溯上一层，继续下一个组合。注意点就是每次递归下一层的时候，一定要把上面已经遍历过的元素在flag标记数组中进行标记，防止下一层再选中此元素，出现重复元素，返回上一层切记清除标记数组中的标记值。 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res;//结果集 vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); vector&lt;int&gt; flag(len, 0);//标记数组 vector&lt;int&gt; tempRes; backtrackingPermute(nums, tempRes, flag, 0,len); return res; &#125; void backtrackingPermute(vector&lt;int&gt; &amp;nums, vector&lt;int&gt; tempRes,vector&lt;int&gt; flag, int index,int sizes) &#123; if (index==sizes) &#123; res.push_back(tempRes); return; &#125; for (int i = 0;i&lt;sizes;i++) &#123; if (!flag[i])//没有被标记的元素才能放入组合数组中，进行递归下一层 &#123; flag[i] = 1;//添加标记 tempRes.push_back(nums[i]); backtrackingPermute(nums, tempRes, flag, index + 1, sizes); tempRes.pop_back(); flag[i] = 0;//清除标记 &#125; &#125; &#125;&#125;; 方法二： 递归回溯法，与方法一不同的地方是不使用标记数组，递归函数内部的for循环的起始索引是上层的index值，在循环内部进行两次swap交换操作，在递归前的交换可以得到一种递归结果，地递归后交换，可以使序列返回到 i 所在层的递归前状态，这样交转的方式，也能穷举出所有的元素排列组合。 123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); backtrackingPremute(nums, 0, len); return res; &#125; void backtrackingPremute(vector&lt;int&gt; &amp;nums, int index, int sizes) &#123; if (index == sizes) &#123; res.push_back(nums); &#125; for (int i = index;i&lt;sizes;i++)//索引从index开始遍历 &#123; swap(nums[i], nums[index]);//递归前交换 backtrackingPremute(nums, index + 1, sizes); swap(nums[i], nums[index]);//递归后交换 &#125; &#125;&#125;; 方法三： 直接利用C++的STL函数库next_permutation()函数，函数详情next_permutation() 。 1234567891011121314class Solution3 &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end(),greater&lt;int&gt;());//先对原数组排序 res.push_back(nums); while (next_permutation(nums.begin(),nums.end(),greater&lt;int&gt;())) &#123; res.push_back(nums); &#125; return res; &#125;&#125;; Java Code：1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; if (null == nums) &#123; return new ArrayList(); &#125; int len = nums.length; if (len == 0) &#123; return new ArrayList(); &#125; int[] flag = new int[len]; List&lt;Integer&gt; resElement = new ArrayList(); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); nextPermutations(nums, flag, 0, resElement, res); return res; &#125; public void nextPermutations(int[] nums, int[] flag, int n, List&lt;Integer&gt; resElement, List&lt;List&lt;Integer&gt;&gt; res) &#123; if (n == nums.length) &#123; res.add(resElement); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (flag[i] == 0) &#123; flag[i] = 1; List&lt;Integer&gt; tmpResElement = new ArrayList(resElement); tmpResElement.add(nums[i]); nextPermutations(nums, flag, n + 1, tmpResElement, res); flag[i] = 0; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[43. Multiply Strings]]></title>
    <url>%2F2017%2F07%2F20%2F43-Multiply-Strings%2F</url>
    <content type="text"><![CDATA[43. Multiply StringsGiven two numbers represented as strings, return multiplication of the numbers as a string. Note: The numbers can be arbitrarily large and are non-negative. Converting the input string to integer is NOT allowed. You should NOT use internal library such as BigInteger. 题意： 给定两个数值用string类型表示，返回这个两个数字的乘积，返回值也用string类型表示。 注意： 这些数字可以是任意大的，但不是负数。 不允许将输入字符串转换为整数。 你不应该使用内部类型如BigInteger。 思路： 按照乘法的基本运算规律，把每一位的乘积累加和计算出来以后，再对每一位考虑进位问题。这道题的要求是计算大数乘法。其中大数是以字符串的形式表示，任意大，非负，返回结果以字符串形式。 假设两个整数的长度分别为了l1和l2，则其最后结果长度为l1+l2（最后有进位）或者l1+l2-1（最后没有有进位）。因此，可以先用长度为l1+l2的数组记录结果，最后再转成字符串。 进行乘法的时候，先把各个位的相乘结果对应累加起来，即第1个整数的第i位（低位到高位）和第2个整数的第j位（低位到高位）相乘的结果应该存放在数组的i+j位。然后再统一处理进位。然后再统一处理进位。最后再将数组转成字符串前，需要跳过前面的零。如果结果只有0，则只返回0。 时间复杂度：O(l1l2)（l1和l2分别为两个整数长度） 空间复杂度：O(l1+l2) 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: string multiply(string num1, string num2) &#123; string res = ""; int num1Len = num1.size(); int num2Len = num2.size(); if (num1Len == 0 || num2Len == 0) &#123; return res; &#125; if (num1 == "0" || num2 == "0") return "0"; vector&lt;int&gt; bitSum(num1Len + num2Len, 0); for (int i =0;i&lt;num2Len;i++) &#123; for (int j = 0;j&lt;num1Len;j++)//第二个字符串的第i位乘第一个字符串的0~j位，结果放到i+j位置，并累加 &#123; bitSum[i + j] += (num1[num1Len - j - 1] - '0')*(num2[num2Len - i - 1] - '0'); &#125; &#125; for (int i = 0,c=0;i&lt;bitSum.size();i++)//处理进位 &#123; int num = bitSum[i] + c; bitSum[i] = num % 10; c = num / 10; &#125; for (int i = bitSum.size()-1; i&gt;=0; i--)//转换为字符串 &#123; res += (bitSum[i]+'0'); &#125; int index = 0; for (;index&lt;res.size()-1;index++)//去除字符串前置0 &#123; if (res[index]=='0') &#123; continue; &#125; else break; &#125; return res.substr(index); &#125;&#125;; Java Code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public String multiply(String num1, String num2) &#123; if (null == num1 || null == num2) &#123; return ""; &#125; int len1 = num1.length(); int len2 = num2.length(); if (len1 == 0 || len2 == 0) &#123; return ""; &#125; int resLen = len1 + len2; int[] resArray = new int[resLen]; for (int i = 0; i &lt; len2; i++) &#123; int v2 = num2.charAt(len2 - i - 1) - '0'; for (int j = 0; j &lt; len1; j++) &#123; int v1 = num1.charAt(len1 - j - 1) - '0'; resArray[i + j] += v2 * v1; &#125; &#125; if ("0".equals(num1) || "0".equals(num2)) &#123; return "0"; &#125; int carry = 0; for (int k = 0; k &lt; resLen; k++) &#123; int bitSum = carry + resArray[k]; resArray[k] = bitSum % 10; carry = bitSum / 10; &#125; StringBuilder builder = new StringBuilder(); int tail = resLen - 1; while (tail &gt;= 0) &#123; if (resArray[tail] != 0) &#123; break; &#125; tail--; &#125; while (tail &gt;= 0) &#123; builder.append(resArray[tail]); tail--; &#125; return builder.toString(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[42. Trapping Rain Water]]></title>
    <url>%2F2017%2F07%2F20%2F42-Trapping-Rain-Water%2F</url>
    <content type="text"><![CDATA[42. Trapping Rain Water(hasDone)Given n non - negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. For example,Given[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1], return 6.The above elevation map is represented by array[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1].In this case, 6 units of rain water(blue section) are being trapped. 题意： 假设n个非负整数代表一个海拔图，每个条的宽度为1，计算它能在雨后捕获多少水。具体捕水例子见上图。 思路： 主要是抓住存水的条件，当元素的右侧元素比其小的时候，说明左侧有可能存水，只要后面存在大于等于此元素的元素值，所以从左往右遍历，一次查找可能存水的区域，叠加，但是还有种情况就是从左到右遍历完成后，最右侧剩余一段都小于某个元素值的区域段，这个时候没有把此区域存水的值叠加进去，所以需要对剩余的元素进行从右往左遍历，一次叠加存水值。 其中主要的判断条件 就是找到往后遍历的比第一个元素大的值，这个时候肯定会存水。 1234567891011121314151617181920212223242526272829303132333435int trap(vector&lt;int&gt;&amp; height) &#123; vector&lt;int&gt; preHeightVal; int sum = 0; for(int i = 0; i&lt;height.size();i++)&#123;//从前往后遍历 if(preHeightVal.empty() || height[i]&lt;preHeightVal[0])&#123; preHeightVal.push_back(height[i]); &#125; else &#123; while (!preHeightVal.empty()) &#123; sum += (preHeightVal[0] - preHeightVal.back()); preHeightVal.erase(preHeightVal.end() - 1); &#125; preHeightVal.push_back(height[i]); &#125; &#125; vector&lt;int&gt; lastHeightVal; for(int i = preHeightVal.size()-1;i&gt;=0;i--)//如果preHeightVal.size()不为零，说明还剩余元素小于preHeightVal的第一个元素，但是有可能存水，从后往前遍历 &#123; if(lastHeightVal.empty() || preHeightVal[i]&lt;lastHeightVal[0])&#123;//从后往前遍历 lastHeightVal.push_back(preHeightVal[i]); &#125; else&#123; while(!lastHeightVal.empty()) &#123; sum += (lastHeightVal[0] - lastHeightVal.back()); lastHeightVal.erase(lastHeightVal.end()-1); &#125; lastHeightVal.push_back(preHeightVal[i]); &#125; &#125; return sum;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[40. Combination Sum II]]></title>
    <url>%2F2017%2F07%2F19%2F40-Combination-Sum-II%2F</url>
    <content type="text"><![CDATA[40. Combination Sum II Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.Each number in C may only be used once in the combination. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, A solution set is:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 题意： 题意同39. Combination Sum,不同点就是，给定的数组元素含有重复元素值,而且每个元素在组合数组中只能出现一次。 思路： 思路同39. Combination Sum,不同点就是，因为数组元素含有重复元素值，所以再递归的过程中，要进行判断，跳过重复元素。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;int&gt; sumNum; sort(candidates.begin(), candidates.end()); backtracking(candidates, target, 0, 0, sumNum); return res; &#125; void backtracking(vector&lt;int&gt; candidates, int target, int index, int sum, vector&lt;int&gt; sumNum) &#123; if (sum == target) &#123; res.push_back(sumNum); return; &#125; else &#123; for (int i = index; i &lt; candidates.size(); i++) &#123; if (sum + candidates[i] &gt; target)//已经排序，可以剪枝 &#123; break; &#125; if (i==index||candidates[i]!=candidates[i-1])//此处剪枝去除重复的元素，index是控制同一层元素，当i!=index得时候，肯定是同一层往后找同层元素，此时进行判断是否相等可以把重复元素去掉，因为已经排过序了 &#123; sumNum.push_back(candidates[i]); backtracking(candidates, target, i + 1, sum + candidates[i], sumNum);//此处索引i + 1取下一个元素，防止数组中一个元素取多次 sumNum.pop_back(); &#125; &#125; &#125; &#125;&#125;; Java Code：123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; if (null == candidates) &#123; return new ArrayList(); &#125; int len = candidates.length; if (len == 0) &#123; return new ArrayList(); &#125; Arrays.sort(candidates); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); List&lt;Integer&gt; sumElements = new ArrayList(); getCombinations(candidates, target, 0, 0, sumElements, res); return res; &#125; public void getCombinations(int[] candidates, int target, int index, int sum, List&lt;Integer&gt; sumElements, List&lt;List&lt;Integer&gt;&gt; res)&#123; if (sum == target) &#123; res.add(sumElements); return; &#125; for (int i = index; i &lt; candidates.length; i++) &#123; if(i != index &amp;&amp; candidates[i] == candidates[i - 1]) &#123; continue; &#125; if (sum + candidates[i] &gt; target) &#123; break; &#125; List&lt;Integer&gt; tmpSumElements = new ArrayList(sumElements); tmpSumElements.add(candidates[i]); getCombinations(candidates, target, i + 1, sum + candidates[i], tmpSumElements, res); &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[39. Combination Sum]]></title>
    <url>%2F2017%2F07%2F19%2F39-Combination-Sum%2F</url>
    <content type="text"><![CDATA[39. Combination SumGiven a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.The same repeated number may be chosen from C unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is:[ [7], [2, 2, 3]] 题意： 给定一组候选数字（C），数组中没有重复元素，和一个目标数（T），在C中找出所有唯一的组合，其中候选数总和为T。同样的重复数可以从C无限次数选择。 思路： 主要是通过递归回溯来进行元素组合的查找，每次递归下一层，判断所取元素的和与目标值是否相等，相等则是一个结果，因为一个元素可以重复取，所以每次递归下层，数组的索引不用前进1，而且在递归回溯开始前先对数组进行排序，便于后面条件判断的剪枝，减少递归层数，提高效率。 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; sumNum;//记录组合元素 sort(candidates.begin(), candidates.end());//先排序，便于剪枝，减少递归层数 backtracking(candidates, target, 0, 0, sumNum, res); return res; &#125; void backtracking(vector&lt;int&gt; candidates, int target, int index, int sum, vector&lt;int&gt; sumNum, vector&lt;vector&lt;int&gt;&gt; &amp;res) &#123; if (sum == target) &#123; res.push_back(sumNum); return; &#125; else &#123; for (int i = index; i &lt; candidates.size(); i++) &#123; if (sum + candidates[i]&gt;target)//已经排序，可以剪枝 &#123; break; &#125; sumNum.push_back(candidates[i]); backtracking(candidates, target, i, sum + candidates[i], sumNum, res); sumNum.pop_back(); &#125; &#125; &#125;&#125;; Java Code：1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; if (null == candidates) &#123; return new ArrayList(); &#125; int len = candidates.length; if (0 == len) &#123; return new ArrayList(); &#125; Arrays.sort(candidates); List&lt;Integer&gt; sumElements = new ArrayList(); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); getCombinations(candidates, 0, 0, target, sumElements, res); return res; &#125; public void getCombinations(int[] candidates, int index, int sum, int target, List&lt;Integer&gt; sumElements, List&lt;List&lt;Integer&gt;&gt; res) &#123; if (sum == target) &#123; res.add(sumElements); return; &#125; for (int i = index; i &lt; candidates.length; i++) &#123; if (sum + candidates[i] &gt; target) &#123; break; &#125; List&lt;Integer&gt; tmpSumElements = new ArrayList(sumElements);//直接在进入下一层的时候复制结果集，减少退出下一层递归时删除元素操作，而且往结果集里面添加的也是创建的结果组合副本 tmpSumElements.add(candidates[i]); getCombinations(candidates, i, sum + candidates[i], target, tmpSumElements, res); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; if (null == candidates) &#123; return new ArrayList(); &#125; int len = candidates.length; if (0 == len) &#123; return new ArrayList(); &#125; Arrays.sort(candidates); List&lt;Integer&gt; sumElements = new ArrayList(); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); getCombinations(candidates, 0, 0, target, sumElements, res); return res; &#125; public void getCombinations(int[] candidates, int index, int sum, int target, List&lt;Integer&gt; sumElements, List&lt;List&lt;Integer&gt;&gt; res) &#123; if (sum == target) &#123; res.add(sumElements.stream().collect(Collectors.toList()));//res内存的是sumElements的地址，后面删除会影响结果集，所以要从新构建一个新的组合结果放到结果集里面 return; &#125; for (int i = index; i &lt; candidates.length; i++) &#123; if (sum + candidates[i] &gt; target) &#123; break; &#125; sumElements.add(candidates[i]); getCombinations(candidates, i, sum + candidates[i], target, sumElements, res); sumElements.remove(Integer.valueOf(candidates[i]));//通过对象删除 &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[38. Count and Say]]></title>
    <url>%2F2017%2F07%2F19%2F38-Count-and-Say%2F</url>
    <content type="text"><![CDATA[38. Count and SayThe count-and-say sequence is the sequence of integers beginning as follows:1, 11, 21, 1211, 111221, … 1 is read off as “one 1” or 11.11 is read off as “two 1s” or 21.21 is read off as “one 2, then one 1” or 1211. Given an integer n, generate the nth sequence.Note: The sequence of integers will be represented as a string. 题意： 计数和说序列是整数序列，如下所示： 1, 11, 21, 1211, 111221, … 也就是说： n = 11 n = 211 n = 321 n = 41211 n = 5111221 …………… 每个n所对应的序列值，是通过n-1对应序列相同元素个数和此元素组合构成的。 思路： 如题意所述，n=1时输出字符串1；n=2时，数上次字符串中的数值个数，因为上次字符串有1个1，所以输出11；n=3时，由于上次字符是11，有2个1，所以输出21；n=4时，由于上次字符串是21，有1个2和1个1，所以输出1211。依次类推，可以直接递归实现。 1234567891011121314151617181920212223242526class Solution &#123;public: string countAndSay(int n) &#123; if (n==1) &#123; return "1"; &#125; string s = countAndSay(n - 1); string res = ""; int size = s.size(); char flag = s[0]; int count = 0,pos = 0; while (pos&lt;size) &#123; while(pos&lt;size&amp;&amp;s[pos]==flag) &#123; count++; pos++; &#125; res += (to_string(count) + flag); count = 0; flag = s[pos]; &#125; return res; &#125;&#125;; 非递归实现： 123456789101112131415161718192021class Solution &#123;public: string countAndSay(int n) &#123; string curr_str = "1"; //n为1的时候，字符串为1 for (int i = 0; i &lt; n - 1; i++) &#123; //对n-2序列的计数，就可以得到n-1的序列值（从零开始，n-1序列即使n的序列值） string buffer; for (int j = 0; j &lt; curr_str.size(); j++) &#123; int cnt = 0; char ch = curr_str[j]; while (j &lt; curr_str.size() &amp;&amp; curr_str[j] == ch) &#123; j++; cnt++; &#125; buffer += (to_string(cnt) + ch); j--; &#125; curr_str = buffer; // Update curr_str &#125; return curr_str; &#125;&#125;; Java Code：123456789101112131415161718192021222324252627class Solution &#123; public String countAndSay(int n) &#123; if (n == 1) &#123; return String.valueOf(1); &#125; String preStr = countAndSay(n - 1); int len = preStr.length(); int count = 0; int i = 0; char flag = preStr.charAt(0); StringBuilder builder = new StringBuilder(); while (i &lt; len) &#123; while (i &lt; len &amp;&amp; preStr.charAt(i) == flag) &#123; count++; i++; &#125; builder.append(count).append(flag); if (i &gt;= len) &#123; break; &#125; flag = preStr.charAt(i); count = 0; &#125; return builder.toString(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[37. Sudoku Solver]]></title>
    <url>%2F2017%2F07%2F18%2F37-Sudoku-Solver%2F</url>
    <content type="text"><![CDATA[37. Sudoku SolverWrite a program to solve a Sudoku puzzle by filling the empty cells.Empty cells are indicated by the character ‘.’.You may assume that there will be only one unique solution.A sudoku puzzle……and its solution numbers marked in red. 题意： 编写一个程序，通过填充空单元格来解决数独难题。 空单元格用字符’.’表示。 可以假设仅有一种解决方法。具体填充实例看上图，规则参照36-Valid-Sudoku。 思路： 首先创建三个二维素组，rowIsValid[ i ][ n ]记录第 i 行，第n（1~9）个值已经出现，colIsValid[ j ][ n ]记录第 j 列，第n（1~9）个值已经出现，subboardIsValid[ b ][ n ]记录第 b 个小九宫格，第n（1~9）个值已经出现。 然后遍历九宫格面板，依次标记上述三个数组，来进行设置已经出现1~9的值的标志位。 当标记数组填充完毕后，进行递归搜索，从0到80，即九宫格的81个元素，进行递归填充，每次填充元素的时候都要从1到9九个数字进行选取判断，如果三个标记数组中都没有出现此元素，则可以选取此元素，然后标记 此元素在三个标记数组中出现，最后递归填充下一个元素，如果成功不进行回溯，一直填充下去，如果不成功，要进行回溯，并且清除标记数组中的值，重新选取元素值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution &#123;private: int rowIsValid[9][10] = &#123;&#123;0&#125;&#125;;//行元素标记数组 int colIsValid[9][10] = &#123;&#123;0&#125;&#125;;//列元素标记数组 int subboardIsValid[9][10] = &#123;&#123;0&#125;&#125;;//小九宫格块元素标记数组public: void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; for (int i =0;i&lt;9;i++) &#123; for (int j = 0;j&lt;9;j++) &#123; if (board[i][j]!='.') &#123; fill(i, j, board[i][j] - '0'); &#125; &#125; &#125; solve(board, 0);//三个标记数组填充完成，进行填充空白格 &#125; bool solve(vector&lt;vector&lt;char&gt;&gt;&amp; board, int index)//递归回溯，填充1~9数字元素 &#123; if (index&gt;80) &#123; return true; &#125; int row = index / 9; int col = index - 9*row; if (board[row][col]!='.')//单元格不为空，直接进行填充下一个单元格 &#123; return solve(board, index + 1); &#125; for (int val =1;val&lt;10;val++) &#123; if (isValid(row,col,val))//判断填充空白格的元素是否有效 &#123; board[row][col] = val+'0'; fill(row, col, val);//空白格填充后完成三个标记数组的标记 if (solve(board,index+1))//回溯点，下一个元素填充满足的话向下层递归，不满足向上层回溯 &#123; return true; &#125; clear(row, col, val);//回溯空白格填充不满足条件，清除三个标记数组的标记 &#125; &#125; board[row][col] = '.'; return false; &#125; void fill(int row, int col, int val)//填充三个标记数组标记 &#123; rowIsValid[row][val] = 1; colIsValid[col][val] = 1; subboardIsValid[(row / 3) * 3 + col / 3][val] = 1; &#125; void clear(int row, int col, int val)//清除三个标记数组标记 &#123; rowIsValid[row][val] = 0; colIsValid[col][val] = 0; subboardIsValid[(row / 3) * 3 + col / 3][val] = 0; &#125; bool isValid(int row, int col, int val)//判读元素填充后是否是可行元素 &#123; if (rowIsValid[row][val] == 0 &amp;&amp; colIsValid[col][val] == 0 &amp;&amp; subboardIsValid[(row / 3) * 3 + col / 3][val] == 0) &#123; return true; &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[36. Valid Sudoku]]></title>
    <url>%2F2017%2F07%2F18%2F36-Valid-Sudoku%2F</url>
    <content type="text"><![CDATA[36. Valid SudokuDetermine if a Sudoku is valid, according to : Sudoku Puzzles - The Rules.The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’. `A partially filled sudoku which is valid. Note : A valid Sudoku board(partially filled) is not necessarily solvable.Only the filled cells need to be validated. 题意： 确定给出的九宫格是否一个有效的数独，数独谜题的根据：规则。数独板可能是部分元素填充，没填充的元素用字符“.”代替。 注意 ：一个有效的数独板（部分填充）不一定是可解的，只需要验证填充的单元格是否有效。 思路： 注意到题目中说的,只要当前已经填充的数字是合法的就可以,不一定要这个数独是有解。因此只需要判断9*9网格的每一行、每一列、9个小九宫格是否合法。即如果在每一行、每一列、每个9个小九宫格内，某个数字重复出现了，当前数独就是不合法的。 其中一种简单方法就是把行、列、九宫格、分三个两重循环来分别判断是否合法。 其实只需要一个两重循环即可，在双重循环时，我们默认了第一重循环表示矩阵的行、第二重循环表示矩阵的列。可以换一种思路： 在检测行是否合法时，i 表示矩阵的行，j 表示矩阵的列。 检测列是否合法时，i 表示矩阵的列，j 表示矩阵的行。 检测九宫格是否合法时，i 表示九宫格的标号，j 表示九宫格里的每个元素（只是我们需要根据i、j定位相应的元素到原来的矩阵：第 i 个九宫格里面的第 j 个元素在原矩阵的第 3(i/3) + j/3 行，第 3\(i%3) + j%3）列，“/” 表示整数除法）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; vector&lt;int&gt; rowValid(10, 0); vector&lt;int&gt; colValid(10, 0); vector&lt;int&gt; boardValid(10, 0); for (int i=0;i&lt;9;i++) &#123; for (int j =0;j&lt;9;j++) &#123; if (board[i][j]!='.'&amp;&amp;board[i][j] - '0' &gt;= 1&amp;&amp; board[i][j] - '0' &lt;= 9) &#123; //判断行是否存在相同的元素 if (rowValid[board[i][j] - '0'] == 1) &#123; return false; &#125; else rowValid[board[i][j] - '0'] = 1; &#125; if (board[j][i]!='.'&amp;&amp;board[j][i] - '0' &gt;= 1&amp;&amp; board[j][i] - '0' &lt;= 9) &#123; //判断列是否存在相同的元素 if (colValid[board[j][i]-'0'] == 1) &#123; return false; &#125; else colValid[board[j][i]-'0'] = 1; &#125; if (board[i/3*3 + j/3][(i%3)*3 + j%3]!='.'&amp;&amp;board[i/3*3 + j/3][(i%3)*3 + j%3] - '0' &gt;= 1&amp;&amp; board[i/3*3 + j/3][(i%3)*3 + j%3] - '0' &lt;= 9) &#123; //判断区域是否存在相同的元素,i表示第几个区域，j表示区域内的第几个元素,根据i和j确定在board中的元素 if (boardValid[board[i/3*3 + j/3][(i%3)*3 + j%3]-'0'] == 1) &#123; return false; &#125; else boardValid[board[i/3*3 + j/3][(i%3)*3 + j%3]-'0'] = 1; &#125; &#125; for (int n =0;n&lt;10;n++) &#123; rowValid[n] = 0; colValid[n] = 0; boardValid[n] = 0; &#125; &#125; return true; &#125;&#125;; Java Code：12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; if (null == board) &#123; return false; &#125; for (int i = 0; i &lt; 9; i++) &#123; int[] rowCheck = new int[10]; int[] colCheck = new int[10]; int[] boxCheck = new int[10]; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] != '.') &#123; int rowNum = board[i][j] - '0'; if (rowNum &gt;= 1 &amp;&amp; rowNum &lt;= 9) &#123; if (rowCheck[rowNum] == 1) &#123; System.out.println("row"); return false; &#125; else &#123; rowCheck[rowNum] = 1; &#125; &#125; &#125; if (board[j][i] != '.') &#123; int colNum = board[j][i] - '0'; if (colNum &gt;= 1 &amp;&amp; colNum &lt;= 9) &#123; if (colCheck[colNum] == 1) &#123; System.out.println("col"); return false; &#125; else &#123; colCheck[colNum] = 1; &#125; &#125; &#125; if (board[(i / 3) * 3 + j / 3][(i % 3) * 3 + j % 3] != '.') &#123; int boxNum = board[(i / 3) * 3 + j / 3][(i % 3) * 3 + j % 3] - '0'; if (boxNum &gt;= 1 &amp;&amp; boxNum &lt;= 9) &#123; if (boxCheck[boxNum] == 1) &#123; return false; &#125; else &#123; boxCheck[boxNum] = 1; &#125; &#125; &#125; &#125; &#125; return true; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[35. Search Insert Position]]></title>
    <url>%2F2017%2F07%2F18%2F35-Search-Insert-Position%2F</url>
    <content type="text"><![CDATA[35. Search Insert PositionGiven a sorted array and a target value, return the index if the target is found.If not, return the index where it would be if it were inserted in order.You may assume no duplicates in the array. Here are few examples. [1, 3, 5, 6], 5 → 2 [1, 3, 5, 6], 2 → 1 [1, 3, 5, 6], 7 → 4 [1, 3, 5, 6], 0 → 0 题意： 给定一个排序数组和一个目标元素值，如果目标元素值在数组中，返回数组中的索引，如果不在数组中，返回其插入数组中的位置，并且插入后数组还是有序的。 思路： 方法一： 直接利用迭代器进行遍历数组。 1234567891011121314151617int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; ::iterator it = nums.begin(); int count = 0; while (*it &lt;= target) &#123; if (*it == target) &#123; return count; &#125; ++it; ++count; if (it == nums.end()) &#123; nums.insert(it, target); return count; &#125; &#125; nums.insert(it, target); return count;&#125; 方法一： 利用折半查找。 12345678910111213141516171819202122int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); if (target &gt; nums[n - 1]) &#123; nums.push_back(target); return n; &#125; int low, high, mid; low = 0; high = n - 1; while(low&lt;=high)&#123; mid = (low + high) / 2; if (nums[mid] == target) &#123; return mid; &#125; if (nums[mid] &gt; target) high = mid - 1; if (nums[mid] &lt; target) low = mid + 1; &#125; nums.insert(nums.begin() + low, target); return low;&#125; Java Code：1234567891011121314151617181920212223242526272829class Solution &#123; public int searchInsert(int[] nums, int target) &#123; if (null == nums) &#123; return 0; &#125; int len = nums.length; if (len == 0) &#123; return 0; &#125; int left = 0; int right = len - 1; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (target == nums[mid]) &#123; return mid; &#125; if (target &lt; nums[mid]) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[34. Search for a Range]]></title>
    <url>%2F2017%2F07%2F18%2F34-Search-for-a-Range%2F</url>
    <content type="text"><![CDATA[34. Search for a RangeGiven an array of integers sorted in ascending order, find the starting and ending position of a given target value.Your algorithm’s runtime complexity must be in the order of O(log n).If the target is not found in the array, return [-1, -1]. For example,Given [5, 7, 7, 8, 8, 10] and target value 8,return [3, 4]. 题意： 给定一个按升序排序的整数数组，查找给定目标值的开始位置和结束位置。算法的运行时复杂性必须是O（log n）。如果数组中找不到目标，则返回[ -1，- 1 ]。 思路： 方法一： 直接利用二分查找，找到指定的元素索引，因为是有序的非递减数组，所以相等的元素一定相邻，直接以此索引为中心，左右扩展，找到元素的起始位置和结束位置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res = &#123; -1,-1 &#125;; int len = nums.size(); if (len == 0) return res; int targetIndex = binarySearchIndex(nums, target); if (targetIndex==-1) &#123; return res; &#125; int targetLeft = targetIndex, targetRight = targetIndex; while (targetLeft&gt;=0) &#123; if (nums[targetLeft] == target) &#123; res[0] = targetLeft; targetLeft--; &#125; else break; &#125; while (targetRight &lt; len) &#123; if (nums[targetRight] == target) &#123; res[1] = targetRight; targetRight++; &#125; else break; &#125; return res; &#125; int binarySearchIndex(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size()-1;//二分查找这个坐标的选取很重要，一定要指向要查找的第一个元素和最后一个元素！！！！！ while (l&lt;=r)//当元素出现的位置只有l==r才能确定时，比如[1,2]找2，一定会出现l==r，所以由上面左右坐标确定后，一定注意此处要有相等！！！！！！ &#123; int mid = (l + r) / 2; if (nums[mid] == target) return mid; if (target &lt; nums[mid]) r = mid - 1; if (target &gt; nums[mid]) l = mid + 1; &#125; return -1; &#125;&#125;; 方法二： 直接利用C++的STL函数库equal_range()，函数详情equal_range()。 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res = &#123; -1,-1 &#125;; int len = nums.size(); if (len == 0) return res; pair&lt;vector&lt;int&gt;::iterator, vector&lt;int&gt;::iterator&gt; bound; bound = equal_range(nums.begin(), nums.end(), target); if (bound.first==nums.end()||*bound.first!=target) &#123; return res; &#125; res[0] = bound.first - nums.begin(); res[1] = bound.second - nums.begin()-1; return res; &#125;&#125;; 方法三： 直接利用C++的STL函数库lower_bound() 和upper_bound()函数，函数详情lower_bound和upper_bound()。 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res = &#123; -1,-1 &#125;; int len = nums.size(); if (len == 0) return res; int low,up; low = lower_bound(nums.begin(), nums.end(), target) - nums.begin(); if (low==len||nums[low] != target) return res; up = upper_bound(nums.begin(), nums.end(), target) - nums.begin() - 1; res[0] = low; res[1] = up; return res; &#125;&#125;; Java Code：12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int[] res = new int[]&#123;-1,-1&#125;; if (null == nums) &#123; return res; &#125; int len = nums.length; if (len == 0) &#123; return res; &#125; int left = 0; int right = len - 1; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (nums[mid] == target) &#123; int l = mid - 1; int r = mid + 1; while (l &gt;= 0 &amp;&amp; nums[l] == target) &#123; l--; &#125; while (r &lt; len &amp;&amp; nums[r] == target) &#123; r++; &#125; return new int[]&#123;++l, --r&#125;; &#125; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[33. Search in Rotated Sorted Array]]></title>
    <url>%2F2017%2F07%2F18%2F33-Search-in-Rotated-Sorted-Array%2F</url>
    <content type="text"><![CDATA[33. Search in Rotated Sorted ArraySuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).You are given a target value to search. If found in the array return its index, otherwise return -1.You may assume no duplicate exists in the array. 题意： 假设一个按升序排序的数组通过预先未知的某个旋转轴进行旋转。 （即，0、1、2、4、6、7、5可能成为4、5、6、7、0、1、2）。 给定一个搜索的目标值。如果在数组中找到，返回它的索引，否则返回- 1。 假设数组中没有重复的元素。 思路： 二分查找的思路，从中间截取后一定会有一部分是有序的。左侧若有序，则右侧可能有序；左侧若无序，则右侧一定有序。判断左侧是否有序的方法是比较if (nums[left] &lt;= nums[mid])。若左侧有序，此时target&gt;nums[mid]则递归查找右侧，若target&lt;nums[mid], 则比较target 与nums[left]的值，从而决定在哪里找target。 这个思路可以画图理解更清晰，y轴代表数组的值，x轴代表值多对应的数组下标，翻转后有如下三种情况，如下图： 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int len = nums.size(); if (len == 0) return -1; int l = 0, r = len - 1; while (l &lt;= r)//l和r可能指向同一个元素 &#123; int mid = (l + r) / 2; if (nums[mid] == target) &#123; return mid; &#125; if (nums[l] &lt;= nums[mid])//l和m可能指向同一个元素 &#123; if (nums[mid] &gt; target&amp;&amp;nums[l] &lt;= target) &#123; r = mid - 1; &#125; else l = mid + 1; &#125; else &#123; if (target&gt;nums[mid]&amp;&amp;target &lt;= nums[r]) &#123; l = mid + 1; &#125; else &#123; r = mid - 1; &#125; &#125; &#125; return -1; &#125;&#125;; Java Code：12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int search(int[] nums, int target) &#123; if (null == nums) &#123; return -1; &#125; int len = nums.length; if (len == 0) &#123; return -1; &#125; int left = 0; int right = len - 1; while (left &lt;= right) &#123; int mid = (left + right) / 2; if (target == nums[mid]) &#123; return mid; &#125; if (nums[left] &lt;= nums[mid]) &#123; if (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; else &#123; if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[31. Next Permutation]]></title>
    <url>%2F2017%2F07%2F17%2F31-Next-Permutation%2F</url>
    <content type="text"><![CDATA[31. Next PermutationImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).The replacement must be in-place, do not allocate extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 题意： 实现给定数组序列的下一个排列，重新排列的数字序列比以前数字的字典序列更大。 如果这种字典序增大序列不存在，即现在给定的数组序列是最大的字典序序列，则直接按升序排序，即字典序排列最小。 思路： 方法一： 利用C++STL库中的next_permutation()函数，函数详情next_permutation()。 1234567891011class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if (len==0) &#123; return; &#125; next_permutation(nums.begin(), nums.end()); &#125;&#125;; 方法二：1234567891011121314151617181920212223241 2 3 41 2 4 31 3 2 41 3 4 2 //所有words内的单词,在left起始位置都出现，则将下标i存入结果的vector中1 4 2 31 4 3 22 1 3 42 1 4 32 3 1 42 3 4 12 4 1 32 4 3 13 1 2 4 //所有words内的单词,在left起始位置都出现，则将下标i存入结果的vector中3 1 4 23 2 1 43 2 4 13 4 1 23 4 2 14 1 2 34 1 3 24 2 1 34 2 3 14 3 1 24 3 2 1 根据上面的1 2 3 4的字母逻辑递增顺序可以得到以下规律：从后往前查找（正常顺序递增），第一个变小的位置i后的元素进行反转，然后再在反转后的元素中找到第一个比i元素大的元素进行互换，就可以得到比此排列大的一个排列。 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if (len == 0) &#123; return; &#125; int i; for (i = len-2;i&gt;=0;i--) &#123; if (nums[i]&gt;=nums[i+1]) &#123; continue; &#125; reverse(nums.begin() + i + 1, nums.end()); for (int j = i+1;j&lt;len;j++) &#123; if (nums[i]&lt;nums[j]) &#123; swap(nums[i], nums[j]); //所有words内的单词,在left起始位置都出现，则将下标i存入结果的vector中s[i], nums[j]); break; &#125; &#125; break; &#125; if (i == -1) &#123; reverse(nums.begin(), nums.end()); &#125; &#125;&#125;; Java Code：12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public void nextPermutation(int[] nums) &#123; if (null == nums) &#123; return; &#125; int len = nums.length; if (len == 0) &#123; return; &#125; int i = len - 2; while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) &#123; i--; &#125; if (i &gt;= 0) &#123; int j = len - 1; while (j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[i]) &#123; //找出第一个j指向比i指向大的元素 j--; &#125; swap(nums, i, j); &#125; reverse(nums, i + 1, len - 1); &#125; public void reverse(int[] nums,int start,int end) &#123; while (start &lt; end) &#123; swap(nums, start, end); start++; end--; &#125; &#125; public void swap(int[] nums,int i,int j) &#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public void nextPermutation(int[] nums) &#123; if (null == nums) &#123; return; &#125; int len = nums.length; if (len == 0) &#123; return; &#125; int i = 0; for (i = len - 2;i &gt;= 0;i--) &#123; if (nums[i] &gt;= nums[i + 1]) &#123; continue; &#125; reverse(nums,i + 1, len - 1); for (int j = i + 1;j &lt; len;j++) &#123; if (nums[j] &gt; nums[i]) &#123; swap(nums, i, j); break; &#125; &#125; break; &#125; //System.out.println(i); if (i == -1) &#123; reverse(nums, 0, len - 1); &#125; &#125; public void reverse(int[] nums,int start,int end) &#123; while (start &lt; end) &#123; swap(nums, start, end); start++; end--; &#125; &#125; public void swap(int[] nums,int i,int j) &#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[30. Substring with Concatenation of All Words]]></title>
    <url>%2F2017%2F07%2F17%2F30-Substring-with-Concatenation-of-All-Words%2F</url>
    <content type="text"><![CDATA[30. Substring with Concatenation of All WordsYou are given a string, s, and a list of words, words, that are all of the same length.Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. For example, given:s: “barfoothefoobarman”words : [“foo”, “bar”]You should return the indices : [0, 9].(order does not matter). 题意： 给定一个字符串S，一个单词列表L（所有单词均等长），在S中找到包含L中所有单词连续出现在S中的首位置组成的集合（单词元素顺序不考虑），注意组成的要查找子串是单词连续组成，没有字符隔断，返回符合该要求的所有子串的首位置。 思路：解决该问题的关键是理解清楚题目要求。给定一个目标字符串s，一个单词集合words。要求使得words集合中所有元素连续出现在s中的首位置组成的集合（元素顺序不考虑）。 正如所给实例，目标字符串s: “barfoothefoobarman”对比单词集合words: [“foo”, “bar”]我们发现，在pos=0 ~ 5时“barfoo”恰好匹配，则0压入结果vector；在pos=9 ~ 14时“foobar”恰好匹配，则9压入结果vector； 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; //s: "barfoothefoobarman" // words : ["foo", "bar"]public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; vector&lt;int&gt; res; unordered_map&lt;string, int&gt; hash;//记录所给words中每个单词的出现次数 for (int i = 0; i &lt; words.size(); i++) &#123; hash[words[i]]++; &#125; unordered_map&lt;string, int&gt; tempHash; int wordSize = words[0].size(); //每个单词的长度相同 int wordsNum = words.size(); int sLen = s.size();//所给匹配字符串的长度 int left = 0, right = 0; for (; left &lt; s.size() - wordSize*wordsNum + 1; left++) &#123; tempHash.clear(); for (right = 0;right&lt; wordsNum;right++) &#123; string tempS = s.substr(left + right*wordSize, wordSize);//检验当前单词是否属于words以及出现的次数是否一致 if (hash.count(tempS)) &#123; tempHash[tempS]++; if (tempHash[tempS]&gt;hash[tempS])//如果出现的次数与words不一致，则返回错误 &#123; break; &#125; &#125; else break; &#125; if (right == wordsNum) //所有words内的单词,在left起始位置都出现，则将下标i存入结果的vector中 &#123; res.push_back(left); &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[28. Implement strStr()]]></title>
    <url>%2F2017%2F07%2F12%2F28-Implement-strStr%2F</url>
    <content type="text"><![CDATA[28. Implement strStr()Implement strStr().Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. 题意： 返回在haystack中第一次出现的needle的索引，如果不存在就返回-1。 思路： 方法一： 暴力解决，从左到右遍历haystack每一个元素，查找needle第一个字符出现的位置，然后截取和needle等长的子串，比较二者是否相等，相等则找到，不等继续遍历，如果到最后还没有找到，返回-1，此法效率低。 12345678910111213141516171819202122232425262728//You are here! Your runtime beats 2.39% of cpp submissions.//73 / 73 test cases passed.//Status: Accepted//Runtime: 36 msclass Solution&#123;public: int strStr(string haystack, string needle) &#123; int index = -1; if (needle.empty()) return 0; if (haystack.empty()) return index; size_t pos = haystack.find_first_of(needle[0]); while (pos != string::npos) &#123; string tempNeedle = haystack.substr(pos, needle.size()); if (tempNeedle == needle) &#123; index = pos; break; &#125; else &#123; pos = haystack.find_first_of(needle[0], pos + 1); &#125; &#125; return index; &#125;&#125;; 方法二： 利用KMP算法，通过求next数组，完成子串和目标串的匹配，KMP算法详解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//You are here! Your runtime beats 13.13% of cpp submissions.//73 / 73 test cases passed.//Status: Accepted//Runtime: 6 msclass Solution &#123;public: //取主串第一次匹配模式串的位置 int strStr(string haystack, string needle) &#123; int haystackLen = haystack.size(); int needleLen = needle.size(); if (needleLen==0) &#123; return 0; &#125; vector&lt;int&gt; next(needleLen, 0); getNext(needle, next); int i = 0, j = 0; while (i&lt;haystackLen&amp;&amp;j&lt;needleLen) &#123; if (j==-1||haystack[i]==needle[j]) &#123; i++; j++; &#125; else &#123; j = next[j]; &#125; &#125; if (j == needleLen) &#123; return i - j; &#125; else return -1; &#125; //得到KMP算法所需要的next[]数组 void getNext(string p, vector&lt;int&gt; &amp;next) &#123; int pLen = p.size(); next[0] = -1; int k = -1; int j = 0; while (j&lt;pLen-1) &#123; if (k==-1||p[k]==p[j]) &#123; k++; j++; if (p[j] != p[k]) &#123; next[j] = k; &#125; else next[j] = next[k]; &#125; else &#123; k = next[k]; &#125; &#125; &#125;&#125;; 方法三： 利用C++的string中封装的find方法，find方法详解。 1234567891011121314//You are here! Your runtime beats 57.50% of cpp submissions.//73 / 73 test cases passed.//Status: Accepted//Runtime: 3 msclass Solution &#123;public: int strStr(string haystack, string needle) &#123; string::size_type temp = haystack.find(needle); if (temp != std::string::npos) return int(temp); else return -1; &#125;&#125;; Java Code：123456//性能好，须记住Java String中常用的APIclass Solution &#123; public int strStr(String haystack, String needle) &#123; return haystack.indexOf(needle); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int strStr(String haystack, String needle) &#123; if (null == needle) &#123; return 0; &#125; int needleLen = needle.length(); if (needleLen == 0) &#123; return 0; &#125; if (null == haystack) &#123; return -1; &#125; int hayLen = haystack.length(); if (hayLen == 0) &#123; return -1; &#125; int count = -1; for (int i = 0;i &lt; hayLen;i++) &#123; char hayChar = haystack.charAt(i); char neeChar = needle.charAt(0); if (hayChar == neeChar) &#123; int j = 1; while (j &lt; needleLen &amp;&amp; (i + j) &lt; hayLen) &#123; if (haystack.charAt(i + j) == needle.charAt(j)) &#123; j++; &#125; else &#123; break; &#125; &#125; if (j == needleLen) &#123; count = i; break; &#125; &#125; &#125; return count; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[27. Remove Element]]></title>
    <url>%2F2017%2F07%2F12%2F27-Remove-Element%2F</url>
    <content type="text"><![CDATA[27. Remove ElementGiven an array and a value, remove all instances of that value in place and return the new length.Do not allocate extra space for another array, you must do this in place with constant memory.The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example:Given input array nums = [3,2,2,3], val = 3Your function should return length = 2, with the first two elements of nums being 2. 题意： 给定一个数组和一个值，删除该值的所有实例并返回数组新长度。不要分配使用额外的数组空间，必须在常量内存空间中执行此操作。元素的顺序可以改变。特别注意不用考虑超过你返回长度的数组元素值，也就是你返回长度是多少，数组元素就有多少个，且不包含指定的元素值。 思路： 方法一： 利用数组迭代器，直接删除元素，把和目标值相等的元素直接删除。但是此方法效率低，不太符合题意。 12345678910111213141516171819202122232425262728293031323334//You are here! Your runtime beats 19.53% of cpp submissions.//113 / 113 test cases passed.//Status: Accepted//Runtime: 3 msclass Solution&#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; if (nums.size() == 0) &#123; return nums.size(); &#125; vector&lt;int&gt;::iterator itr = nums.begin()+1; vector&lt;int&gt;::iterator tempItr = nums.begin(); while (itr != nums.end()) &#123; if (*itr == val) &#123; nums.erase(itr); itr = tempItr; itr++; &#125; else &#123; itr++; tempItr++; &#125; &#125; if (nums[0]==val) &#123; nums.erase(nums.begin()); &#125; return nums.size(); &#125;&#125;; 方法二： 不一定非得把找到的元素删除掉，把要找到的元素覆盖掉就行，并不真正改变原数组的大小，这个题的关键就是根据你返回的不是要查找元素的个数cnt，那么编译器就自己取数组的前cnt个元素，所以省去了自己截取前cnt个元素为新数组的步骤。 123456789101112131415class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int cnt = 0; for (int i = 0;i&lt;nums.size();i++) &#123; if (nums[i]!=val) &#123; nums[cnt] = nums[i];//把相等的目标值元素覆盖掉 cnt++; &#125; &#125; return cnt;//直接返回除去目标元素后剩下元素的个数 &#125;&#125;; Java Code：12345678910111213141516class Solution &#123; public int removeElement(int[] nums, int val) &#123; if (null == nums) &#123; return 0; &#125; int len = nums.length; int count = 0; for (int i = 0;i &lt; len;i++) &#123; if (val != nums[i]) &#123; nums[count] = nums[i]; count++; &#125; &#125; return count; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[26. Remove Duplicates from Sorted Array]]></title>
    <url>%2F2017%2F07%2F10%2F26-Remove-Duplicates-from-Sorted-Array%2F</url>
    <content type="text"><![CDATA[26. Remove Duplicates from Sorted ArrayGiven a sorted array, remove the duplicates in place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this in place with constant memory. For example,Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length. 题意： 给定一个排序数组，删除重复的元素，使每个元素只出现一次，并返回新的长度。不要申请另一个额外的数组空间，必须在常数空间内，即在数组本身上完成去重。 返回值只需要返回不重复元素的数组元素长度即可。 思路： 利用一个前指针 i 和尾指针 count 遍历数组，当 i 所指向的元素值与相邻前一个元素相同，则直接往前移动 i 指针，当不同的时候，先移动 count 指针（因为count指针指向的值的是上一个不同值，所以先++移动），然后把 i 指向的值赋值给 count 所指向的值，最后不重复元素数组的长度即是count+1。 12345678910111213141516171819class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if (len == 0) &#123; return 0; &#125; int count = 0; for (int i =1;i&lt;len;i++) &#123; if (nums[i]!=nums[i-1]) &#123; nums[++count] = nums[i]; &#125; &#125; return count + 1; &#125;&#125;; Java Code：1234567891011121314151617181920class Solution &#123; public int removeDuplicates(int[] nums) &#123; if (null == nums) &#123; return 0; &#125; int len = nums.length; if (len &lt;= 1) &#123; return len; &#125; int slow = 0; for (int i = 1;i &lt; len;i++) &#123; if (nums[i] != nums[i - 1]) &#123;//有序数组，比较相邻元素即可知道与前面是否相等 slow++; nums[slow] = nums[i]; &#125; &#125; return slow + 1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[25. Reverse Nodes in k-Group]]></title>
    <url>%2F2017%2F07%2F10%2F25-Reverse-Nodes-in-k-Group%2F</url>
    <content type="text"><![CDATA[25. Reverse Nodes in k-GroupGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list.If the number of nodes is not a multiple of k then left - out nodes in the end should remain as it is.You may not alter the values in the nodes, only nodes itself may be changed.Only constant memory is allowed. For example, Given this linked list : 1-&gt;2-&gt;3-&gt;4-&gt;5For k = 2, you should return : 2-&gt;1-&gt;4-&gt;3-&gt;5For k = 3, you should return : 3-&gt;2-&gt;1-&gt;4-&gt;5 题意： 给定一个链表，每次反转链表k个节点组（从左侧开始数，每k个节点为一个组合，组合内节点进行反转），并返回其修改后的链表。如果节点数不是k的倍数，那么最后的链表节点应该保持不变。不能更改节点中的值，只有链表节点自身，即通过指针的改变完成k个节点内的链表节点反转，并把每一反转组组合成一个新的链表。仅允许常量内存。 思路： 方法一： 建立链表临时头结点，在不达到k的值时候进行表头插入，到达时临时头结点后移到链表尾部，然后在链表尾部完成下一组k个节点的头插法，特别注意当最后节点不足k个的时候，因为要保持原链表节点顺序，所以直接尾插法，完成最后一段链表组的插入。 123456789101112131415161718192021222324252627282930313233343536ListNode* reverseKGroup(ListNode* head, int k) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return head; &#125; ListNode *p = head; int sum = 0;//记录链表中的总共节点数 while (p) &#123; sum++; p = p-&gt;next; &#125; ListNode reverseHead(-1); ListNode *reversePointer = &amp;reverseHead; //把大于k先头插，满足k组的话把临时头结点移动到分组最后一个再进行头插，依次循环直到sum&lt;k，组成成组链表 while (sum&gt;=k)//当sum&gt;=k的时候说明后面肯定有要进行反转的链表组 &#123; ListNode *tempH = NULL; //先进行头插法 for (int i = 0; i &lt; k; i++) &#123; ListNode *pre = head; head = head-&gt;next; reversePointer-&gt;next = pre; pre-&gt;next = tempH; tempH = pre; &#125; while (reversePointer-&gt;next)//把头插法的头结点移动到链表的尾部，便于下一次头插或者尾插 &#123; reversePointer = reversePointer-&gt;next; &#125; sum -= k; &#125; reversePointer-&gt;next = head;//最后一段尾插法 return reverseHead.next;&#125; 方法二： 思路大致和方法一相同，但是把链表的反转直接抽取出来，利用递归的思想，通过断开分组与整个链表的连接，得到一个独立的分组链表，然后直接对这一个分组进行反转，翻转后添加到临时头结点后面，每个独立的k个节点分组翻转后依次进行链表尾插，直到遍历完所有链表节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//递归实现链表反转ListNode* reverseList(ListNode *head) &#123; if (head==NULL||head-&gt;next==NULL) &#123; return head; &#125; ListNode *p = head-&gt;next; ListNode *n = reverseList(p); head-&gt;next = NULL; p-&gt;next = head; return n;&#125;//对分组内节点进行反转ListNode* reverseKGroup(ListNode* head, int k) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return head; &#125; ListNode *p = head; int sum = 0; while (p) &#123; sum++; p = p-&gt;next; &#125; ListNode reverseHead(-1); ListNode *reversePointer = &amp;reverseHead; while (sum &gt;= k) &#123; ListNode *pre = head; for (int i=0;i&lt;k-1;i++) &#123; pre = pre-&gt;next;//找到断开分组的节点，便于递归反转 &#125; ListNode *tempHead = pre-&gt;next;//记录下一个分组的临时头结点 pre-&gt;next = NULL;//断开分组 auto everyHead = reverseList(head); head = tempHead; reversePointer-&gt;next = everyHead; while (reversePointer-&gt;next) &#123; reversePointer = reversePointer-&gt;next; &#125; sum -= k; &#125; reversePointer-&gt;next = head; return reverseHead.next;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[24. Swap Nodes in Pairs]]></title>
    <url>%2F2017%2F07%2F09%2F24-Swap-Nodes-in-Pairs%2F</url>
    <content type="text"><![CDATA[24. Swap Nodes in PairsGiven a linked list, swap every two adjacent nodes and return its head. For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space.You may not modify the values in the list, only nodes itself can be changed. 题意： 给一个单向链表，交换两个相邻节点，并且返回链表头结点。算法要求线性空间复杂度，并且不能只是交换节点的变量值，而是交换两个节点本身。 思路： 方法一： 主要是构造临时头结点，因为LeetCode中构造的链表是不带头结点的，自己构造头结点可以完成一边遍历链表，一边交换两个相邻节点，关键就是利用三个指针分别记录三个节点，temp记录要反转的两个节点的前一个节点，p指向要反转的前一个节点，q指向后一个，这样一边往前遍历，一边改变next指针的指向。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode tempHead(-1); tempHead.next = head; if (head==NULL||head-&gt;next==NULL) &#123; return head; &#125; ListNode *p, *q,*temp; temp = &amp;tempHead; p = tempHead.next; q = p-&gt;next; while (q != NULL&amp;&amp;p!=NULL) &#123; p-&gt;next = q-&gt;next; q-&gt;next = p; temp-&gt;next = q; temp = p; p = p-&gt;next; if(p) q = p-&gt;next; &#125; return tempHead.next; &#125;&#125;; 方法二： 主要是利用递归，上层指向节点值得指针记录的都是递归前链表节点的位置，就是前一个节点位置指针，进入下一层函数的返回值是后面已经交换的两个链表节点的首节点，或者是最后一个节点节点指针。然后改变next指针，完成相邻节点的交换。 1234567891011121314151617181920/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if (head == NULL) return NULL; if (head-&gt;next == NULL) return head; ListNode* temp = head-&gt;next; head-&gt;next = swapPairs(temp-&gt;next); temp-&gt;next = head; return temp; &#125;&#125;; 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if (null == head) &#123; return head; &#125; ListNode tmpHead = new ListNode(-1); ListNode tmp = tmpHead; tmpHead.next = head; ListNode cur = head; while (null != cur &amp;&amp; null != cur.next) &#123; ListNode p = cur.next; tmp.next = p; cur.next = p.next; p.next = cur; tmp = cur; cur = cur.next; &#125; return tmpHead.next; &#125;&#125; Java Code：123456789101112131415161718class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if (null == head) &#123; return null; &#125; if (null == head.next) &#123; return head; &#125; ListNode tmp = head.next; head.next = swapPairs(tmp.next); tmp.next = head; return tmp; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23. Merge k Sorted Lists]]></title>
    <url>%2F2017%2F07%2F08%2F23-Merge-k-Sorted-Lists%2F</url>
    <content type="text"><![CDATA[23. Merge k Sorted ListsMerge k sorted linked lists and return it as one sorted list.Analyze and describe its complexity. 题意： 合并K个排序的链表并将其返回为一个排序列表，并分析其复杂性。 思路： 方法一： 直接利用暴力解决的办法，首先利用两个有序链表的合并算法21. Merge Two Sorted Lists，然后依次遍历k个有序链表，返回合并后的排序链表，但是时间复杂度极高，效率很低。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//运行时间过高,You are here! Your runtime beats 3.58% of cppsubmissions.//两个有序链表合并ListNode* mergeList(ListNode *l1, ListNode *l2) &#123; ListNode newHead(-1); ListNode *p = &amp;newHead; while (l1!=NULL&amp;&amp;l2!=NULL) &#123; if (l1-&gt;val&lt;l2-&gt;val) &#123; p-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; p-&gt;next = l2; l2 = l2-&gt;next; &#125; p = p-&gt;next; &#125; while (l1) &#123; p-&gt;next = l1; l1 = l1-&gt;next; p = p-&gt;next; &#125; while (l2) &#123; p-&gt;next = l2; l2 = l2-&gt;next; p = p-&gt;next; &#125; return newHead.next;&#125;//遍历k个链表数组ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; int n = lists.size(); if (n==0) &#123; return NULL; &#125; ListNode *newHead = NULL; for (int i = 0; i &lt; n; i++) &#123; newHead = mergeList(lists[i],newHead); &#125; return newHead;&#125; 方法二： 利用堆排序的思想，将每个链表的表头元素取出来，建立一个小顶堆，因为k个链表中都排好序了，因此每次取堆顶的元素就是k个链表中的最小值，可以将其合并到合并链表中，再将这个元素的指针指向的下一个元素也加入到堆中，再调整堆，取出堆顶，合并链表。。。。以此类推，直到堆为空时，链表合并完毕。 建堆的时间复杂度是k/2logk, 每次取出堆顶再加入元素的复杂度是logk,假设每条链表平均有n个元素，则一共有nk-k次。因此总的时间复杂度为O(nklogk)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899 // 使用堆排序, // 1. 选出每个链表的头来插入小顶堆中， // 2. 再把堆顶接入合并链表中， // 3. 被选出的指针后移再加入小顶堆中,回到2 // 4. 最后所有链表都为空时，返回合并链表的头指针 //You are here! Your runtime beats 40.40% of cppsubmissions.class Solution&#123; //1、建立小顶堆 void creatHeap(vector&lt;ListNode*&gt; &amp;heap) &#123; for (int i = heap.size()/2-1;i&gt;=0;i--) &#123; downElement(heap, i); &#125; &#125; //2、下沉元素： //（1）当传递的是最后一个非叶子节点的索引时（从最后一个非叶子节点开始，将每个父节点都调整为最小堆），是建立最小堆。 //（2）当传递的是堆的第一个元素时（即完全二叉树的根节点向下沉，是进行堆排序输出最小节点后，继续生成最小堆），堆排序过程中生成最小堆。 void downElement(vector&lt;ListNode*&gt; &amp;heap,int elementIndex) &#123; int min = 0; int index = elementIndex; while (2*index+1&lt;heap.size())//存在左孩子节点 &#123; min = 2 * index + 1; if (2*index+2&lt;heap.size())//存在右孩子节点 &#123; if (heap[2 * index + 2]-&gt;val&lt;heap[min]-&gt;val)//确定最小孩子节点索引 &#123; min = 2 * index + 2; &#125; &#125; if (heap[index]-&gt;val&lt;heap[min]-&gt;val)//如果根节点小于最小孩子节点，此子树已经是最小堆，直接结束 &#123; break; &#125; else &#123; swap(heap[index], heap[min]);//上移最小孩子节点 index = min;//孩子节点索引做为根节点继续遍历 &#125; &#125; &#125; //3、堆的首元素弹出 ListNode* popHeap(vector&lt;ListNode*&gt; &amp;heap) &#123; auto temp = heap[0]; swap(heap[0], heap[heap.size() - 1]); heap.pop_back(); downElement(heap, 0); return temp; &#125; //4、堆中添加元素 void pushHeap(vector&lt;ListNode*&gt; &amp;heap,ListNode *p) &#123; heap.push_back(p); //1、主要这个地方重新建堆造成runtime低 // creatHeap(heap); //2、效率也不是很高 /*int child = heap.size(); int parent = child / 2; while (parent) &#123; if (heap[child-1]-&gt;val&lt;heap[parent-1]-&gt;val) &#123; swap(heap[child-1], heap[parent-1]); &#125; child = parent; parent = child / 2; &#125;*/ //3、效率相对高 for (int child = heap.size(), parent = child / 2; parent; child--, parent = child / 2) &#123; if (heap[child - 1]-&gt;val &lt; heap[parent - 1]-&gt;val) //判断新加入的元素是否比根节点小，如果小要进行下沉、替换 &#123; swap(heap[child - 1], heap[parent - 1]); &#125; &#125; &#125; ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; vector&lt;ListNode*&gt; heap; for (int i = 0; i != lists.size(); i++) &#123; if (lists[i]) heap.push_back(lists[i]); &#125; if (heap.empty()) &#123; return NULL; &#125; ListNode newHead(-1); ListNode *p = &amp;newHead; creatHeap(heap); while (!heap.empty()) &#123; ListNode *minHeap = popHeap(heap); p-&gt;next = minHeap; p = p-&gt;next; auto next = minHeap-&gt;next; if (next) pushHeap(heap,next); //creatHeap(heap);//这种重新再次构建最小堆会超时 &#125; return newHead.next; &#125;&#125;; Java Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */ //自己实现小顶堆，思想借鉴PriorityQueue源码class Solution &#123; private ListNode[] minHeap = null; private int size = 0; public ListNode mergeKLists(ListNode[] lists) &#123; if (null == lists) &#123; return null; &#125; int len = lists.length; if (len == 0) &#123; return null; &#125; minHeap = new ListNode[len]; for (int i = 0; i &lt; len;i++) &#123; if (null != lists[i]) &#123; minHeap[size] = lists[i]; size++; &#125; &#125; if (size == 0) &#123; return null; &#125; heapify(); ListNode head = new ListNode(-1); ListNode p = head; while (size &gt; 0) &#123; ListNode minNode = poll(); p.next = minNode; minNode = minNode.next; p = p.next; p.next = null; if (null != minNode) &#123; offer(minNode); &#125; &#125; return head.next; &#125; public void heapify() &#123; for (int i = (size &gt;&gt;&gt; 1) - 1;i &gt;= 0;i--) &#123; siftDown(i, minHeap[i]); &#125; &#125; public void siftDown(int index, ListNode node) &#123; int half = size &gt;&gt;&gt; 1; while (index &lt; half) &#123; int min = (index &lt;&lt; 1) + 1; ListNode child = minHeap[min]; int right = min + 1; if (right &lt; size &amp;&amp; minHeap[right].val &lt; child.val) &#123; child = minHeap[min = right]; &#125; if (child.val &gt;= node.val) &#123; break; &#125; minHeap[index] = child; index = min; &#125; minHeap[index] = node; &#125; public void siftUp(int index, ListNode node) &#123; while (index &gt; 0) &#123; int parent = (index - 1) &gt;&gt;&gt; 1; if (minHeap[parent].val &lt;= node.val) &#123; break; &#125; minHeap[index] = minHeap[parent]; index = parent; &#125; minHeap[index] = node; &#125; public ListNode poll() &#123; if (size == 0) &#123; return null; &#125; ListNode minNode = minHeap[0]; int last = --size; ListNode lastNode = minHeap[last]; minHeap[last] = null; if (last != 0) &#123; siftDown(0, lastNode); &#125; return minNode; &#125; public void offer(ListNode node) &#123; if (size == 0) &#123; minHeap[0] = node; size++; return; &#125; minHeap[size] = node; siftUp(size, node); size++; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//直接使用Java自带的优先队列PriorityQueueclass Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (null == lists) &#123; return null; &#125; int len = lists.length; if (len == 0) &#123; return null; &#125; List&lt;ListNode&gt; minHeap = new ArrayList(); for (int i = 0; i &lt; len;i++) &#123; if (null != lists[i]) &#123; minHeap.add(lists[i]); &#125; &#125; if (minHeap.size() == 0) &#123; return null; &#125; PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue(minHeap.size(), new Comparator&lt;ListNode&gt;() &#123; @Override public int compare(ListNode node1, ListNode node2) &#123; if (node1.val &gt; node2.val) &#123; return 1; &#125; else if (node1.val &lt; node2.val) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; &#125;); queue.addAll(minHeap); ListNode head = new ListNode(-1); ListNode p = head; while (queue.size() &gt; 0) &#123; ListNode minNode = queue.poll(); p.next = minNode; minNode = minNode.next; p = p.next; p.next = null; if (null != minNode) &#123; queue.offer(minNode); &#125; &#125; return head.next; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[22. Generate Parentheses]]></title>
    <url>%2F2017%2F07%2F07%2F22-Generate-Parentheses%2F</url>
    <content type="text"><![CDATA[22. Generate ParenthesesGiven n pairs of parentheses, write a function to generate all combinations of well - formed parentheses. For example, given n = 3, a solution set is :“((()))”, “(()())”, “(())()”, “()(())”, “()()()” 题意： 给定n对括号，编写一个函数来生成圆括号的所有组合。 思路： 首先确定递归终止的条件，当n == 0的时候，说明没有括号对，直接返回空字符串，当n == 1的时候，说明只有一个括号对，那么组合的情况也就有一种()，直接返回即可，单n &gt;= 2的时候进行递归运算，每次递归下一层去计算n - 1个括号对所产生的括号组合情况，当递归返回的时候，遍历返回的所有组合对，为每一种的组合情况都加入一个括号对“()”,这个括号对的位置是n - 1个括号对字符串的任何一个位置，这样就能把n个括号对的所有情况都遍历罗列出来。 特别注意重复的括号对字符串，要用set容器进行过滤。 12345678910111213141516171819202122232425//利用递归进行求解，要以后用树的思想求解vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; res; if (n == 0) res.push_back(""); if (n == 1) &#123; res.push_back("()"); &#125; else &#123; vector&lt;string&gt; pre_vec = generateParenthesis(n - 1); set&lt;string&gt; filter_set;//过滤重复的字符串 int sizes = pre_vec.size(); for (int i = 0; i &lt; sizes; ++i) &#123; string temp_str = pre_vec[i]; for (int j = 0; j &lt; temp_str.size(); j++) &#123; string now_str = temp_str.substr(0, j) + "()" + temp_str.substr(j, temp_str.size()); filter_set.insert(now_str); &#125; &#125; for (auto &amp;r : filter_set) &#123; res.push_back(r); &#125; &#125; return res;&#125; Java Code：1234567891011121314151617181920212223242526class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList(); if (n == 0) &#123; return res; &#125; if (n == 1) &#123; res.add("()"); return res; &#125; List&lt;String&gt; preParenthesis = generateParenthesis(n - 1); int size = preParenthesis.size(); for (int i = 0;i &lt; size;i++) &#123; String tmp = preParenthesis.get(i); for (int j = 0;j &lt; tmp.length();j++) &#123; String tmpRes = new StringBuilder(tmp.substring(0, j)) .append("()").append(tmp.substring(j, tmp.length())).toString(); res.add(tmpRes); &#125; &#125; return res.stream().distinct().collect(Collectors.toList()); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[21. Merge Two Sorted Lists]]></title>
    <url>%2F2017%2F07%2F06%2F21-Merge-Two-Sorted-Lists%2F</url>
    <content type="text"><![CDATA[21. Merge Two Sorted ListsMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 题意： 合并两个排序链表为一个链表，合并后链表是有序链表。 思路：12345678910111213141516171819202122232425262728293031struct ListNode&#123; int val; ListNode *next; ListNode(int x) :val(x), next(NULL) &#123;&#125;&#125;;//切记:是合并两个不同的有序单链表为一个有序单链表ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode *p1, *p2,*tempHead,*pc; pc =tempHead = l1; p1 = l1-&gt;next; p2 = l2-&gt;next; while (p1&amp;&amp;p2) &#123; if (p1-&gt;val&lt;=p2-&gt;val) &#123; pc-&gt;next = p1; pc = pc-&gt;next; p1 = p1-&gt;next; &#125; else &#123; pc-&gt;next = p2; pc = pc-&gt;next; p2 = p2-&gt;next; &#125; &#125; pc-&gt;next = p1 ? p1 : p2; return tempHead;&#125; Java Code：1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; ListNode head = new ListNode(-1); ListNode tmp = head; while (l1 != null &amp;&amp; l2 != null) &#123; int val1 = l1.val; int val2 = l2.val; if (val1 &lt;= val2) &#123; tmp.next = l1; l1 = l1.next; &#125; else &#123; tmp.next = l2; l2 = l2.next; &#125; tmp = tmp.next; &#125; if (l1 == null) &#123; tmp.next = l2; &#125; else &#123; tmp.next = l1; &#125; return head.next; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20. Valid Parentheses]]></title>
    <url>%2F2017%2F07%2F05%2F20-Valid-Parentheses%2F</url>
    <content type="text"><![CDATA[20. Valid ParenthesesGiven a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not. 题意： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 思路： 此题的做法主要是利用栈的特性，当是 ‘(‘, {‘, ‘[‘ 的时候直接入栈，当是’)’,’}’, ‘]’ 的时候判断当前栈顶元素是否和右括号匹配，如果正常匹配则弹出，不匹配遍历下一个下一个字符，最后判断栈大小是否为空，为空则说明匹配正确有效。 1234567891011121314151617181920212223class Solution &#123;public: bool isValid(string s) &#123; if (s.empty()) return false; stack&lt;char&gt; st; for (auto res : s) &#123; if (res == ')'&amp;&amp;!st.empty()&amp;&amp;st.top() == '(') st.pop(); else if (res == '&#125;'&amp;&amp;!st.empty()&amp;&amp;st.top() == '&#123;') st.pop(); else if (res == ']'&amp;&amp;!st.empty()&amp;&amp;st.top() == '[') st.pop(); else st.push(res); &#125; if (st.empty()) return true; else return false; &#125;&#125;; Java Code：12345678910111213141516171819202122232425262728class Solution &#123; public boolean isValid(String s) &#123; if (null == s) &#123; return false; &#125; int len = s.length(); if (len == 0) &#123; return true; &#125; Stack&lt;Character&gt; stack = new Stack(); for (int i = 0;i &lt; len;i++) &#123; char cur = s.charAt(i); if (cur == ')' &amp;&amp; !stack.empty() &amp;&amp; '(' == stack.peek()) &#123; stack.pop(); &#125; else if (cur == '&#125;' &amp;&amp; !stack.empty() &amp;&amp; '&#123;' == stack.peek()) &#123; stack.pop(); &#125; else if (cur == ']' &amp;&amp; !stack.empty() &amp;&amp; '[' == stack.peek()) &#123; stack.pop(); &#125; else &#123; stack.push(cur); &#125; &#125; return stack.empty(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19. Remove Nth Node From End of List]]></title>
    <url>%2F2017%2F07%2F05%2F19-Remove-Nth-Node-From-End-of-List%2F</url>
    <content type="text"><![CDATA[19. Remove Nth Node From End of ListGiven a linked list, remove the nth node from the end of list and return its head. For example:Given linked list : 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note :​ Given n will always be valid.​ Try to do this in one pass. 题意： 给定一个链表，移除链表从最后一个节点开始的第n个节点，n值肯定是有效的，尝试一次遍历单链表实现。 思路： 先有一个指针pre按照给定的倒数第n个的值向后移动，当n==0时，last指针开始从头结点开始向后移动，，然后pre和last指针同时移动，当pre为空时，则last指针指向的是所删除元素的前一个元素，然后利用last删除元素，返回链表头结点。 特别注意n所指的元素刚刚好是链表的第一个元素的时候。 12345678910111213141516171819202122232425262728293031323334struct ListNode&#123; int val; ListNode *next; ListNode(int x) :val(x), next(NULL) &#123;&#125;&#125;;ListNode* removeNthFromEnd(ListNode* head, int n) &#123; if (head == NULL) return NULL; ListNode *pre = head, *last = head; while (pre !=NULL) &#123; while (n) &#123; pre = pre-&gt;next; n--; &#125; //注意此判断条件，因为n所指向的元素刚好是链表第一个元素的时候，按照下面的方法就会出错，因为n为第一个元素，则pre刚好移动到链表尾后空指针处，pre = pre-&gt;next;就会出错，所以要单独设立条件考虑。 if (!pre) &#123; return head-&gt;next; &#125; pre = pre-&gt;next; if (pre!=NULL) &#123; last = last-&gt;next; &#125; &#125; ListNode *tempNPoint = last-&gt;next; last-&gt;next = tempNPoint-&gt;next; tempNPoint-&gt;next = NULL; delete(tempNPoint); return head;&#125; Java Code：12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; if (null == head) &#123; return head; &#125; ListNode pre = head; ListNode after = head; while (n &gt; 0 &amp;&amp; null != pre) &#123; pre = pre.next; n--; &#125; if (null == pre) &#123; return head.next; &#125; while (null != pre) &#123; pre = pre.next; if (null != pre) &#123; after = after.next; &#125; &#125; ListNode deleteNode = after.next; after.next = deleteNode.next; deleteNode.next = null; return head; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[17. Letter Combinations of a Phone Number]]></title>
    <url>%2F2017%2F07%2F04%2F17-Letter-Combinations-of-a-Phone-Number%2F</url>
    <content type="text"><![CDATA[17. Letter Combinations of a Phone NumberGiven a digit string, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below. Input:Digit string “23”Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. Note:Although the above answer is in lexicographical order, your answer could be in any order you want. 题意： 给定一个数字字符串，每个数字对应手机键盘上的英文字母组合，返回所有数字可以代表的字符组合。 思路： 经典的backtracking（回溯算法）的题目。当一个题目，存在各种满足条件的组合，并且需要把它们全部列出来时，就可以考虑backtracking了。但是，backtracking在一定程度上属于穷举，所以当数据特别大的时候，不合适。而对于那些题目，可能就需要通过动态规划来完成。 这道题的思路很简单，假设输入的是”23”，2对应的是”abc”，3对应的是”edf”，那么我们在递归时，先确定2对应的其中一个字母（假设是a），然后进入下一层，穷举3对应的所有字母，并组合起来（”ae”，”ad”，”af”），当”edf”穷举完后，返回上一层，更新字母b，再重新进入下一层。这个就是backtracing的基本思想。 特别注意0和1在手机键盘上不对应字符。 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; res; if (digits.empty()) &#123; return res; &#125; vector&lt;string&gt; hashMap = &#123; "","","abc" ,"def" ,"ghi" ,"jkl" ,"mno" ,"pqrs" ,"tuv" ,"wxyz" &#125;;//0,1下标对应的是空字符串 letterCombina(digits, hashMap, res, 0, ""); return res; &#125; void letterCombina(string digits, vector&lt;string&gt; hashMap, vector&lt;string&gt; &amp;res, int index, string cutStr)//返回上一层要记录结果值，左移用引用参数 &#123; if (index==digits.size()) &#123; if (!cutStr.empty()) &#123; res.push_back(cutStr); return; &#125; &#125; string tempStr= hashMap[atoi(digits.substr(index,1).c_str())]; for (int i = 0;i&lt;tempStr.size();i++) &#123; string nextCutStr = cutStr+tempStr[i]; letterCombina(digits, hashMap, res, index + 1, nextCutStr); &#125; &#125;&#125;; Java Code：123456789101112131415161718192021class Solution &#123; private String[] letters = &#123;"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"&#125;; private List&lt;String&gt; ans = new ArrayList&lt;&gt;(); public List&lt;String&gt; letterCombinations(String digits) &#123; if (digits.length() == 0) return ans; track(digits, 0, ""); return ans; &#125; private void track(String digits, int index, String str) &#123; if (index == digits.length()) &#123; ans.add(str); return; &#125; int len = letters[digits.charAt(index) - '2'].length(); for (int j = 0; j &lt; len; j++) &#123; track(digits, index + 1, str + letters[digits.charAt(index) - '2'].charAt(j)); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; res = new ArrayList(); if (null == digits) &#123; return res; &#125; int len = digits.length(); if (len == 0) &#123; return res; &#125; Map&lt;Character,String&gt; phoneNumHash = new HashMap(); phoneNumHash.put('0', ""); phoneNumHash.put('1', ""); phoneNumHash.put('2', "abc"); phoneNumHash.put('3', "def"); phoneNumHash.put('4', "ghi"); phoneNumHash.put('5', "jkl"); phoneNumHash.put('6', "mno"); phoneNumHash.put('7', "pqrs"); phoneNumHash.put('8', "tuv"); phoneNumHash.put('9', "wxyz"); letterCombinations(digits, 0, res, "", phoneNumHash); return res; &#125; public void letterCombinations(String digits,int curIndex,List&lt;String&gt; res,String curStr,Map&lt;Character,String&gt; numHash)&#123; if (curIndex == digits.length()) &#123; if (null != curStr &amp;&amp; curStr.length() != 0) &#123; res.add(curStr); return; &#125; &#125; String numStr = numHash.get(digits.charAt(curIndex)); if (null == numStr) &#123; return; &#125; for (int i = 0;i &lt; numStr.length();i++) &#123; letterCombinations(digits, curIndex + 1, res, curStr + numStr.charAt(i), numHash); &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16. 3Sum Closest]]></title>
    <url>%2F2017%2F07%2F03%2F16-3Sum-Closest%2F</url>
    <content type="text"><![CDATA[16. 3Sum ClosestGiven an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. For example, given array S = {-1 2 1 -4}, and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 题意： 给一个含有n个整数的S数组，查找在S中的三元组，使三个数字的和最靠近目标值 ，返回最接近目标值的三个整数的和。假设每个输入都已一个确切的答案。 思路： 思想大致都和15. 3Sum相同，先排序，然后利用三个指针，一个指针指向固定元素，另外两个做为这个固定元素后面的两个移动指针，然后三元素求和，当和大于目标值的时候说明所求和大，需减小，所以把尾指针前移，小于目标值的时候说明所求和小，需增大，所以把首指针后移 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int len = nums.size(); sort(nums.begin(), nums.end()); int sum = 0, dis = INT_MAX; for (int i = 0;i&lt;len-2;i++) &#123; int pre = i + 1; int tail = len - 1; while (pre&lt;tail) &#123; int tempSum = nums[i] + nums[pre] + nums[tail]; int tempDis = abs(target - tempSum); if (tempDis &lt; dis) &#123; sum = tempSum; dis = tempDis; &#125; if (tempSum &lt; target) &#123; pre++; while (pre &lt; tail&amp;&amp;nums[pre] == nums[pre - 1]) &#123; pre++;//去除重复元素，类似15. 3Sum &#125; &#125; else &#123; tail--; while (pre &lt; tail&amp;&amp;nums[tail] == nums[tail + 1]) &#123; tail--;//去除重复元素，类似15. 3Sum &#125; &#125; &#125; &#125; return sum; &#125;&#125;; Java Code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; if (null == nums) &#123; return 0; &#125; int len = nums.length; if (len == 0) &#123; return 0; &#125; Arrays.sort(nums); int minDis = Integer.MAX_VALUE; int res = 0; for (int i = 0;i &lt; len - 2;i++) &#123; int curNum = nums[i]; int pre = i + 1; int tail = len - 1; while (pre &lt; tail) &#123; int preNum = nums[pre]; int tailNum = nums[tail]; int sum = curNum + preNum + tailNum; int dis = Math.abs(target - sum); if (dis &lt; minDis) &#123; res = sum; minDis = dis; &#125; if (target &gt; sum) &#123; pre++; while (pre &lt; tail &amp;&amp; nums[pre -1] == nums[pre]) &#123; pre++; &#125; &#125; else &#123; tail--; while (pre &lt; tail &amp;&amp; nums[tail + 1] == nums[tail]) &#123; tail--; &#125; &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15. 3Sum]]></title>
    <url>%2F2017%2F07%2F03%2F15-3Sum%2F</url>
    <content type="text"><![CDATA[15. 3SumGiven an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. 123456For example, given array S = [-1, 0, 1, 2, -1, -4],A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] 题意： 给一个含有n个整数的S数组，是否有三元组a,b,c在S中使a + b + c = 0，在S中找到所有的不重复的三元组，当三元组的和为0的时候。 注意： 结果集不能包含重复的三元组。 思路： 这道题的思路和Two Sum差不多，简单方式是暴力查找，先排序，然后3层循环遍历数组，时间复杂度O(n3)。优化时，可以先固定一个数，再用两个指针l和r从这个数后面的两边往中间查找，当这三个数之和等于0的时候，记录一下，当之和大于0的时候，r左移，而当之和小于0的时候，l右移，直到l和r相遇。这个其实就是在Two Sum外层加1层循环，因此时间复杂度是排序的O(nlogn)加O(n2)，即O(n2)。 由于三个数字需要按照非递减序列排放，因此先排序可以满足此要求。又要求不包含重复元素，因此在选择第一个数字的时候以及后面两个指针查找时，需要跳过重复元素 具体步骤： 先升序排序，然后用第一重for循环确定第一个数字。 然后在第二重循环里，第二、第三个数字分别从两端往中间扫。 如果三个数的sum等于0，得到一组解。 如果三个数的sum小于0，说明需要增大，所以第二个数往右移。 如果三个数的sum大于0，说明需要减小，所以第三个数往左移。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; set&lt;vector&lt;int&gt;&gt; tempRes;//set集合也是为了防止出现重复元素 if (nums.size() &lt; 3) return res; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; nums.size() - 2; i++) &#123; if (nums[i] &gt; 0)//第i个大于0，后面的数一定大于零，按数组递增排序 break; if (i&gt;0 &amp;&amp; nums[i] == nums[i - 1])//排序后如果nums[i] == nums[i - 1]，肯定会出现和前一个i重复的三元组 continue; int pre = i + 1; int tail = nums.size() - 1; while (pre&lt;tail) &#123; vector&lt;int&gt; vals; int sum = nums[i] + nums[pre] + nums[tail]; if (sum == 0) &#123; vals.push_back(nums[i]); vals.push_back(nums[pre]); vals.push_back(nums[tail]); tempRes.insert(vals); pre++; tail--; while (pre &lt; tail&amp;&amp;nums[pre] == nums[pre - 1]) pre++;//因为同一个nums[i]，如果nums[pre] == nums[pre - 1],则取出来的三元组肯定是重复的，所以直接把pre向后移动，然后再计算 while (pre &lt; tail&amp;&amp;nums[tail] == nums[tail + 1]) tail--;//因为一个nums[i]，如果nums[tail] == nums[tail + 1],则取出来的三元组肯定是重复的，所以直接把tail向前移动，然后再计算 &#125; else if (sum &lt; 0) &#123; pre++; &#125; else tail--; &#125; &#125; for (auto s : tempRes) &#123; res.push_back(s); &#125; return res; &#125;&#125;; Java Code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; if (null == nums) &#123; return new ArrayList(); &#125; int len = nums.length; if (len == 0) &#123; return new ArrayList(); &#125; Set&lt;List&lt;Integer&gt;&gt; res = new HashSet(); Arrays.sort(nums); for (int i = 0;i &lt; len - 2;i++) &#123; int curNum = nums[i]; if (curNum &gt; 0) &#123; break; &#125; if (i &gt; 0 &amp;&amp; curNum == nums[i - 1]) &#123; continue; &#125; int pre = i + 1; int tail = len - 1; while (pre &lt; tail) &#123; List&lt;Integer&gt; zeroNums = new ArrayList(); int preNum = nums[pre]; int tailNum = nums[tail]; int sum = curNum + preNum + tailNum; if (sum == 0) &#123; zeroNums.add(curNum); zeroNums.add(preNum); zeroNums.add(tailNum); res.add(zeroNums); pre++; tail--; while (pre &lt; tail &amp;&amp; nums[pre] == nums[pre - 1]) &#123; pre++; &#125; while (pre &lt; tail &amp;&amp; nums[tail] == nums[tail + 1]) &#123; tail--; &#125; &#125; else if (sum &gt; 0) &#123; tail--; &#125; else &#123; pre++; &#125; &#125; &#125; return res.stream().collect(Collectors.toList()); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14. Longest Common Prefix]]></title>
    <url>%2F2017%2F07%2F03%2F14-Longest-Common-Prefix%2F</url>
    <content type="text"><![CDATA[14. Longest Common PrefixWrite a function to find the longest common prefix string amongst an array of strings. 题意： 在一个字符串数组中查找最长相同前缀。 思路： 先找到字符串数组中最短的字符串，然后根据这个长度遍历每个string字符串中的字符，只要有一个字符串的字符不相等，则当前找的字符串就是最长相同前缀。 123456789101112131415161718192021222324class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string res = ""; if (strs.empty()) return res; int len = strs.size(); int minStrLen = INT_MAX; for (int i = 0; i &lt; len; i++) &#123; minStrLen = min(minStrLen, (int)strs[i].size()); &#125; for (int j = 0; j &lt; minStrLen; j++) &#123; char val = strs[0][j]; for (int i = 1; i &lt; len; i++) &#123; if (val == strs[i][j]) continue; else return res; &#125; res += val; &#125; return res; &#125;&#125;; Java Code：12345678910111213141516171819202122232425262728293031323334class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if (null == strs) &#123; return ""; &#125; int len = strs.length; if (len == 0) &#123; return ""; &#125; int minStrLen = Integer.MAX_VALUE; for (int i = 0;i &lt; len;i++) &#123; minStrLen = Math.min(minStrLen, strs[i].length()); &#125; String res = ""; for (int j = 0;j &lt; minStrLen;j++) &#123; char cur = strs[0].charAt(j); for (int i = 1;i &lt; len;i++) &#123; char next = strs[i].charAt(j); if (cur == next) &#123; continue; &#125; else &#123; return res; &#125; &#125; res += cur; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13. Roman to Integer]]></title>
    <url>%2F2017%2F07%2F03%2F13-Roman-to-Integer%2F</url>
    <content type="text"><![CDATA[13. Roman to IntegerGiven a roman numeral, convert it to an integer.Input is guaranteed to be within the range from 1 to 3999. 题意： 给定一个罗马数字，将其转换为整数，输入的数字确保在1到3999之间。 思路： 罗马数字基本字符： I、V、X、L、C、D、M相应的阿拉伯数字表示为：1、5、10、50、100、500、1000 罗马数字表示： 相同的数字连写，所表示的数等于这些数字相加得到的数，如：Ⅲ = 3； 小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数， 如：Ⅷ = 8；Ⅻ = 12； 小的数字，（限于Ⅰ、X 和C）在大的数字的左边，所表示的数等于大数减小数得到的数，如：Ⅳ = 4；Ⅸ = 9； 具体转换方法： 从左边第一个数字开始，依次加，因为有3的情况的存在， 加过以后判断，要是存在（3）的情况，就减去前一个（i - 1）＊2，因为本来应该减去前面这个小的数， 但是上次一循环还加了一次，于是这次就减去2次 右加左減： (1). 在较大的罗马数字的右边记上小的罗马数字，表示大数字加小数字。在较大的罗马数字的左边记上小的罗马数字，表示大数字减去小数字。(2). 左减的数字有限制，仅限于I、X、C。比如45不可以写成VL，只能是XLV(3). 但是，左减不能跨去一个位数。比如，99不可以用IC（100 - 1）表示，而是用XCIX（[100 - 10] + [10 - 1]）表示。（等同于阿拉伯每位数字表示每位）(4). 左减数字必须为一位，比如8写成VIII，而非IIX。(5). 右加数字不可连续超过三位，比如14写成XIV，而非XIIII。 所以用户输入一个数后，我们可以来遍历这个数，用sum来总计和，比较pre(s[i - 1]) 和 cur(s[i])，如果，cur 比 pre 小的话，直接相加，如果 cur 比 pre 大的话，则将总和sum减去pre这个地方数的两倍，同时加上 cur 就相当于后边的数比左边的数大，则用右边的数减左边的数。但因为之前已经加过一次了，所以减两次。 1234567891011121314151617181920212223242526272829303132333435363738//方法一：从左往右遍历罗马数字class Solution &#123;public: int romanToInt(string s) &#123; //I、V、X、L、C、D、M相应的阿拉伯数字表示为：1、5、10、50、100、500、1000 map&lt;char, int&gt; m = &#123; &#123;'I',1&#125;,&#123; 'V',5 &#125;,&#123; 'X',10 &#125;,&#123; 'L',50 &#125;,&#123; 'C',100 &#125;,&#123; 'D',500 &#125;,&#123; 'M',1000 &#125; &#125;; int n = s.size(); int sum=0; for (int i = 0; i &lt; n; i++) sum += m[s[i]]; for (int i = 0; i &lt; n - 1; i++) &#123; if (m[s[i]] &lt; m[s[i + 1]]) sum -= m[s[i]]*2; &#125; return sum; &#125;&#125;;//方法二：从右往左遍历罗马数字class Solution &#123;public: int romanToInt(string s) &#123; map&lt;char, int&gt; m = &#123; &#123; 'I',1 &#125;,&#123; 'V',5 &#125;,&#123; 'X',10 &#125;,&#123; 'L',50 &#125;,&#123; 'C',100 &#125;,&#123; 'D',500 &#125;,&#123; 'M',1000 &#125; &#125;; int res = 0; char max = 'I'; for (int i = s.size() - 1; i &gt;= 0; --i) &#123; if (m[s[i]] &gt;= m[max]) &#123; max = s[i]; res += m[s[i]]; &#125; else &#123; res -= m[s[i]]; &#125; &#125; return res; &#125;&#125;; Java Code：12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int romanToInt(String s) &#123; if (null == s) &#123; return 0; &#125; int len = s.length(); if (len == 0) &#123; return 0; &#125; Map&lt;Character, Integer&gt; hash = new HashMap(); hash.put('I', 1); hash.put('V', 5); hash.put('X', 10); hash.put('L', 50); hash.put('C', 100); hash.put('D', 500); hash.put('M', 1000); int res = 0; char maxChar = 'I'; for (int i = len - 1;i &gt;= 0;i--) &#123; char cur = s.charAt(i); int curNum = hash.get(cur); int maxCharNum = hash.get(maxChar); if (curNum &gt;= maxCharNum) &#123; res += curNum; maxChar = cur; &#125; else &#123; System.out.println(res); res -= curNum; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12. Integer to Roman]]></title>
    <url>%2F2017%2F07%2F03%2F12-Integer-to-Roman%2F</url>
    <content type="text"><![CDATA[12. Integer to RomanGiven an integer, convert it to a roman numeral.Input is guaranteed to be within the range from 1 to 3999. 题意： 给定一个整数，将其转换为罗马数字，输入的数字确保在1到3999之间。 思路： 罗马数字计数规则： 若干相同数字连写表示的数是这些罗马数字的和，如III = 3； 小数字在大数字前面表示的数是用大数字减去小数字，如IV＝4； 小数字在大数字后面表示的数是用大数字加上小数字，如VI = 6; 罗马数字组合规则： 基本数字I、X 、C 中的任何一个，自身连用构成数目，或者放在大数的右边连用构成数目，都不能超过三个；放在大数的左边只能用一个。 不能把基本数字 V 、L 、D 中的任何一个作为小数放在大数的左边采用相减的方法构成数目；放在大数的右边采用相加的方式构成数目，只能使用一个。 V 和 X 左边的小数字只能用I。 L 和 C 左边的小数字只能用×。 D 和 M 左 边的小数字只能用 C 。 具体实现方法： 利用map构造哈希映射表，把1到1000的所有数字用罗马数字表示，这几个数字也就是构成罗马数字的基本元素，组合可以够造数字： map&lt;char, int&gt; m = { { ‘I’,1 },{ ‘V’,5 },{ ‘X’,10 },{ ‘L’,50 },{ ‘C’,100 },{ ‘D’,500 },{ ‘M’,1000 } }; 利用整数数组和字符串数组构造哈希映射表： int val[] = { 1000,900,500,400,100,90,50,40,10,9,5,4,1 }; string r[] = { “M”,”CM”,”D”,”CD”,”C”,”XC”,”L”,”XL”,”X”,”IX”,”V”,”IV”,”I” }; 12345678910111213141516171819202122232425262728293031323334353637//方法一：class Solution &#123;public: string intToRoman(int num) &#123; map&lt;int, string&gt; mp = &#123; &#123; 1000,"M" &#125;,&#123; 900,"CM" &#125;,&#123; 500,"D" &#125;,&#123; 400,"CD" &#125;,&#123; 100,"C" &#125;,&#123; 90,"XC" &#125;,&#123; 50,"L" &#125;,&#123; 40,"XL" &#125;,&#123; 10,"X" &#125;,&#123; 9,"IX" &#125;,&#123; 5,"V" &#125;,&#123; 4,"IV" &#125;,&#123; 1,"I" &#125; &#125;; map&lt;int, string&gt;::reverse_iterator iter = mp.rbegin();//map按键值顺序排列，所以取值的时候要利用逆序迭代器 string roman; while (num &gt; 0&amp;&amp; iter!=mp.rend()) &#123; while (num &gt;= iter-&gt;first) &#123; roman += iter-&gt;second; num -= iter-&gt;first; &#125; ++iter; &#125; return roman; &#125;&#125;;//方法二：class Solution &#123;public: string intToRoman4(int num) &#123; int n[] = &#123; 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 &#125;; string r[] = &#123; "M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I" &#125;; string roman; int i = 0; while (num &gt; 0) &#123; while (num &gt;= n[i]) &#123; roman += r[i]; num -= n[i]; &#125; ++i; &#125; return roman; &#125;&#125;; Java Code：12345678910111213141516171819class Solution &#123; public String intToRoman(int num) &#123; int n[] = &#123; 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 &#125;; String r[] = &#123; "M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I" &#125;; StringBuilder builder = new StringBuilder(); int index = 0; while (num &gt; 0) &#123; while (num &gt;= n[index]) &#123; builder.append(r[index]); num -= n[index]; System.out.println(num); &#125; index++; &#125; return builder.toString(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11. Container With Most Water]]></title>
    <url>%2F2017%2F06%2F30%2F11-Container-With-Most-Water%2F</url>
    <content type="text"><![CDATA[11. Container With Most WaterGiven n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. 题意： 数组索引代表x轴坐标，数组元素值代表y轴索引，经过此点坐标做垂直于x轴的线段，求这样的线段，以及x轴围起来的容器能存储的最多的水。 思路： 从左右向中间遍历，左右两个指针依次向中间移动，在移动的过程中不断计算所围成容器的最大面积，其中有一点优化的地方就是当左右指针移动的时候，如果移动的下一个高度小于等于当前高度，直接移动，不用再计算面积，因为这样面经肯定会变小。 123456789101112131415161718192021class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int area = 0; int left = 0, right = height.size() - 1; while (left &lt; right) &#123; int ht = min(height[left], height[right]); area = max(area, ht*(right - left)); while(height[left] &lt;= ht&amp;&amp;left&lt;right)//左边下一个高度小于当前高度，直接移动左边指针 &#123; left++; &#125; while (height[right] &lt;= ht&amp;&amp;left &lt; right)//右边下一个高度小于当前高度，直接移动右边指针 &#123; right--; &#125; &#125; return area; &#125;&#125;; Java Code：1234567891011121314151617181920212223242526class Solution &#123; public int maxArea(int[] height) &#123; int len = height.length; if (len == 0 || len == 1) &#123; return 0; &#125; int left = 0; int right = len - 1; int area = 0; while (left &lt; right) &#123; int minHight = Math.min(height[left], height[right]); area = Math.max(area, minHight * (right - left)); while (height[left] &lt;= minHight &amp;&amp; left &lt; right) &#123; left++; &#125; while (height[right] &lt;= minHight &amp;&amp; right &gt; left) &#123; right--; &#125; &#125; return area; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序优化]]></title>
    <url>%2F2017%2F06%2F29%2FQuickSort-Optimization%2F</url>
    <content type="text"><![CDATA[快速排序的思想是分治法，当每次划分时，算法若都能分成两个等长的子序列时，那么分治算法效率会达到最大。所以基准枢纽元的选择是很重要，选择基准的方式决定了分割后两个子序列的长度，进而对整个算法的效率产生决定性影响。 通常实现的快速排序没有经过充分考虑的选择那个枢纽元，只是将第一个或最后一个元素用作枢纽元。选择第一个元素作为枢纽元的程序例子见快速排序的两种实现思路二,选择最后一个元素作为枢纽元的程序例子见快速排序的两种实现思路一 快速排序枢纽元选择的优化方法方法一：随机选取枢纽元 如果输入序列是随机的，那么固定枢纽元为第一个或者最后一个这是可以接受的，但是如果输入是预排序的或者是反序的，那么固定枢纽元就产生一个劣质的分割，因为所有的元素不是被划入S1就是被划入S2。更有甚者，这种情况发生在所有的递归调用中。 实际上，如果第一个元素用作枢纽元而且输入是预先排序的，那么快速排序的时间复杂度为Θ(n^2)。然而，预排序的输入(或者有一大段预排序数据的输入)也是相当常见的，因此，使用第一个元素作为枢纽元的算法效率不是很高的。 随机选取枢纽元是相对安全的策略。由于枢轴的位置是随机的，那么产生的分割也不会总是会出现劣质的分割。在整个数组数字全相等时，仍然是最坏情况，时间复杂度是O(n^2）。实际上，随机化快速排序得到理论最坏情况的可能性仅为1/(2^n）。所以随机化快速排序可以对于绝大多数输入数据达到O(nlogn）的期望时间复杂度。 随机选取枢纽元算法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//随机选取枢纽元int getRandomPivot(int low,int height)&#123; //主要是利用随机数，随机的获取数组中的一个元素做为主元 int size = height - low + 1; int index = low + rand() % size; return index;&#125;//随机枢纽元放到第一个元素的getPartition划分过程int getPartitionOptimize1(vector&lt;int&gt; &amp;nums, int low, int height)&#123; //主要是利用随机数，随机的获取数组中的一个元素做为枢纽元 int index =getRandomPivot(low,height); swap(nums[low], nums[index]);//交换第一个元素和随机枢纽元 int keyVal = nums[low]; while (low&lt;height) &#123; while (low&lt;height&amp;&amp;nums[height]&gt;=keyVal) &#123; height--; &#125; nums[low] = nums[height]; while (low&lt;height&amp;&amp;nums[low]&lt;=keyVal) &#123; low++; &#125; nums[height] = nums[low]; &#125; nums[low] = keyVal; return low;&#125;//随机枢纽元放到最后一个元素的getPartition划分过程int getPartitionOptimizer2(vector&lt;int&gt; &amp;nums, int low, int height)&#123; //主要是利用随机数，随机的获取数组中的一个元素做为枢纽元 int index =getRandomPivot(low,height); swap(nums[height], nums[index]);//交换最后一个元素和随机枢纽元 int keyVal = nums[height]; int i = low - 1; for (int j = low;j&lt;height;j++) &#123; if (nums[j]&lt;=keyVal) &#123; i = i + 1; swap(nums[j], nums[i]); &#125; &#125; swap(nums[i + 1], nums[height]); return i+1;&#125; 方法二：三数取中分割法选取枢纽元 虽然随机选取枢轴时，减少出现不好分割的几率，但是最坏情况下还是O(n^2），要缓解这种情况，就引入了三数取中选取枢纽，一组N个数的中值是第[N/2]个最大的数。枢纽元的最好的选择是数组的中值。可是，这很难算出来，并且会明显减慢快速排序的速度。这样的中值的估计可以通过随机选取三个元素并用它们的中值作为枢纽元而得到。事实上，随机性并没有多大的帮助，因此一般的做法是使用左端、右端和中心位置上的三个元素的中值作为枢纽元。显然使用三数中值分割法消除了预排序输入的不好情形。 三数取中分割法枢纽元算法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//三数取中分割法:通过确定nums[low], nums[mid], nums[height]三者之中的那个第二大的元素为枢纽元时，便能尽最大限度保证快速排序算法不会出现O（N ^ 2）的最坏情况。。void getMedianOfThreePivot(vector&lt;int&gt; &amp;nums, int low, int height)&#123; //主要是利用三元区中值，随机的获取数组中的一个元素做为枢纽元 int mid = (low + height) / 2; //首先把三元素中的最小的元素交换到中间 if (nums[low] &lt; nums[mid]) swap(nums[low], nums[mid]); if (nums[height] &lt; nums[mid]) swap(nums[height], nums[mid]); //在比较两个较大的元素，把最小的放到最左边位置，即为三数中值 if (nums[height] &lt; nums[low]) swap(nums[height], nums[low]);&#125;//三数取中分割法枢纽元放到第一个元素的getPartition划分过程int getPartitionOptimize1(vector&lt;int&gt; &amp;nums, int low, int height)&#123; getMedianOfThreePivot(nums,low,height);//确定枢纽元 int keyVal = nums[low]; while (low &lt; height) &#123; while (low &lt; height&amp;&amp;nums[height] &gt;= keyVal) &#123; height--; &#125; nums[low] = nums[height]; while (low &lt; height&amp;&amp;nums[low] &lt;= keyVal) &#123; low++; &#125; nums[height] = nums[low]; &#125; nums[low] = keyVal; return low;&#125;//三数取中分割法枢纽元放到最后一个元素的getPartition划分过程int getPartitionOptimizer4(vector&lt;int&gt; &amp;nums, int low, int height)&#123; getMedianOfThreePivot(nums,low,height);//确定枢纽元 int keyVal = nums[height]; int i = low - 1; for (int j = low; j &lt; height; j++) &#123; if (nums[j] &lt;= keyVal) &#123; i = i + 1; swap(nums[j], nums[i]); &#125; &#125; swap(nums[i + 1], nums[height]); return i + 1;&#125; 枢纽元确定后递归快排函数优化方法方法一：当待排序序列的长度分割到一定大小后，使用插入排序 对于很小和部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排．截止范围：待排序序列长度N &lt; 10，进行插入排序，而不是继续划分快排。 123456789101112131415161718192021222324252627282930//利用插入排序优化void insertSort(vector&lt;int&gt; &amp;nums, int low, int height)&#123; for (int i = low; i &lt;= height; i++) &#123; int key = nums[i]; int j = i - 1; while (j &gt;= low &amp;&amp; key &lt; nums[j]) &#123; nums[j + 1] = nums[j]; j--; &#125; nums[j + 1] = key; &#125;&#125;//递归快排函数通过加入插入排序进行优化void quickSortOptimize(vector&lt;int&gt; &amp;nums, int low, int height) &#123; if (height - low + 1 &lt; 10) &#123; insertSort(nums, low, height); return; &#125; else &#123; int mid = getPartitionOptimize1(nums, low, height); quickSort(nums, low, mid - 1); quickSort(nums, mid + 1, height); &#125;&#125; 方法二：在一次分割结束后，可以把与枢纽元相等的元素聚在一起，继续下次分割时，不用再对与枢纽元相等元素分割 举例：123456789举例：待排序序列 1 4 6 7 6 6 7 6 8 6三数取中选取枢轴：下标为4的数6转换后，待分割序列：6 4 6 7 1 6 7 6 8 6 枢纽元key：6本次划分后，未对与key元素相等处理的结果：1 4 6 6 7 6 7 6 8 6下次的两个子序列为：1 4 6 和 7 6 7 6 8 6本次划分后，对与key元素相等处理的结果：1 4 6 6 6 6 6 7 8 7下次的两个子序列为：1 4 和 7 8 7经过对比，我们可以看出，在一次划分后，把与key相等的元素聚在一起，能减少迭代次数，效率会提高不少 具体实现过程分为两步：12第一步，在划分过程中，把与枢纽元key相等元素放入数组的两端第二步，划分结束后，把与枢纽元key相等的元素移到枢纽元周围 具体代码实现： 枢纽元通过三数取中分割法后放在第一个元素，此法是从左右两边分别向中间靠拢，所以和枢纽元相等的值会出现在枢纽元左右两边，因此需要左右两边都进行相等枢纽元的聚集。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576vector&lt;int&gt; getPartitionGatherKey(vector&lt;int&gt; &amp;nums, int low, int height)&#123; getMedianOfThreePivot(nums, low, height);//转换枢纽元 int tmpLow = low; int tmpHeight = height; int left = low; int right = height; int leftCommonNum = 0;//记录左侧和枢纽元相等的元素个数 int rightCommonNum = 0;//记录右侧和枢纽元相等的元素个数 //第一步：划分的过程中把与枢纽元相等的元素分散到数组的两端 int keyVal = nums[low]; while (low &lt; height) &#123; while (low &lt; height &amp;&amp; nums[height] &gt;= keyVal) &#123; if (nums[height] == keyVal) &#123; swap(nums[height], nums[right]);//相等元素放到右端 --right; ++rightCommonNum; &#125; --height; &#125; nums[low] = nums[height]; while (low &lt; height &amp;&amp; nums[low] &lt;= keyVal) &#123; if (nums[low] == keyVal) &#123; swap(nums[low], nums[left]);//相等元素放到左端 ++left; ++leftCommonNum; &#125; ++low; &#125; nums[height] = nums[low]; &#125; nums[low] = keyVal; //第二步：划分结束后，把与keyVal相等的元素移到枢纽轴（也就是枢纽元素）的两边 for (int i = low -1,j = tmpLow;j &lt; left;j++) &#123; if (nums[i] != keyVal) swap(nums[j], nums[i]); --i; &#125; for (int i = low + 1, j = tmpHeight; j &gt; right; j--) &#123; if (nums[i] != keyVal) swap(nums[j], nums[i]); ++i; &#125; //计算划分区域的索引 int partitionLeftIndex = low - 1 - leftCommonNum; int partitionRighttIndex = low + 1 + rightCommonNum; vector&lt;int&gt; partitionIndex; partitionIndex.push_back(partitionLeftIndex); partitionIndex.push_back(partitionRighttIndex); return partitionIndex;&#125;void quickSortGatherKey(vector&lt;int&gt; &amp;nums, int low, int height)&#123; if (height - low + 1 &lt; 10) &#123; insertSort(nums, low, height); return; &#125; else &#123; vector&lt;int&gt; partitionIndex = getPartitionGatherKey(nums, low, height); quickSortGatherKey(nums, low, partitionIndex[0]); quickSortGatherKey(nums, partitionIndex[1], height); &#125;&#125; 枢纽元通过三数取中分割法后放在最后一个元素，此法枢纽元左边都是小于等于枢纽元的元素，右边都是大于枢纽元的元素，所以和枢纽元相等的值只会出现在枢纽元左两边，因此只需要左边进行相等枢纽元的聚集。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758vector&lt;int&gt; getPartitionGatherKey(vector&lt;int&gt; &amp;nums, int low, int height)&#123; getMedianOfThreePivot(nums, low, height);// swap(nums[height], nums[low]);//三数取中分割法后枢纽元在最左端，需放到最后一个元素处 int tmpLow = low; int left = low; int leftCommonNum = 0;//记录左侧和枢纽元相等的元素个数 //第一步：划分的过程中把与枢纽元相等的元素分散到数组的左端 int keyVal = nums[height]; int i = low - 1; for (int j = low; j &lt; height; j++) &#123; if (nums[j] &lt;= keyVal) &#123; i = i + 1; swap(nums[j], nums[i]); if (nums[i] == keyVal) &#123; swap(nums[left], nums[i]); ++left; ++leftCommonNum; &#125; &#125; &#125; swap(nums[i + 1], nums[height]); //第二步：划分结束后，把与keyVal相等的元素移到枢纽轴（也就是枢纽元素）的左边 for (int k = i,j = tmpLow;j &lt; left;j++) &#123; if (nums[k] != keyVal) &#123; swap(nums[k], nums[j]); &#125; --k; &#125; int partitionLeftIndex = i - leftCommonNum; int partitionRighttIndex = i + 2; vector&lt;int&gt; partitionIndex; partitionIndex.push_back(partitionLeftIndex); partitionIndex.push_back(partitionRighttIndex); return partitionIndex;&#125;void quickSortGatherKey(vector&lt;int&gt; &amp;nums, int low, int height)&#123; if (height - low + 1 &lt; 10) &#123; insertSort(nums, low, height); return; &#125; else &#123; vector&lt;int&gt; partitionIndex = getPartitionGatherKey(nums, low, height); quickSortGatherKey(nums, low, partitionIndex[0]); quickSortGatherKey(nums, partitionIndex[1], height); &#125;&#125; 综上所述，以及对大量数据的测试可以得到最好的快排组合是：三数取中+插排+聚集相等元素,它和STL中的Sort函数效率差不多]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6. ZigZag Conversion]]></title>
    <url>%2F2017%2F06%2F29%2F6-ZigZag-Conversion%2F</url>
    <content type="text"><![CDATA[6. ZigZag ConversionThe string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility(易读的)) 123P A H NA P L S I I GY I R 1&quot;PAHNAPLSIIGYIR&quot; And then read line by line: &quot;PAHNAPLSIIGYIR&quot; Write the code that will take a string and make this conversion given a number of rows: 123string convert(string text, int nRows);convert(&quot;PAYPALISHIRING&quot;, 3)&quot;PAHNAPLSIIGYIR&quot; 题意： 把一个字符串根据给的的行数，按之字形模式进行输出，然后按照输出的之字形模式按行读取，返回一个新的字符串。 思路： 方法一： 创建nRows个string数组，将s字符串按照0,1,2,…,nRows-2,nRows-1，然后nRows-2,…,2,1的顺序，组个把s串中的字符放入到各个string中。 具体来说，string数组下标先递增，直到nRows-1，则反向，直到0，再反向，……直到s字符串遍历完，再依次组合0~nRows-1个string元素。切记一点当到nRows-1返回的时候要从nRows-2开始，因为之字形返回最后一行数组s中字符元素，但是正向第一行是有的，所以从0开始。 12345678910111213141516171819202122232425262728class Solution &#123;public: string convert(string s, int numRows) &#123; if (numRows == 1) return s; string res = ""; int sLen = s.size(); vector&lt;string&gt; val(numRows); int down = 0, up = numRows-2;//向下记录从0开始，向上记录从 numRows-2开始， int i = 0; while (i&lt;sLen) &#123; for (int j = down; j &lt; numRows&amp;&amp;i&lt;sLen;) &#123; val[j++] += s[i++]; &#125; for (int j = up; j &gt; 0&amp;&amp;i&lt;sLen;) &#123; val[j--] += s[i++]; &#125; &#125; for (auto v : val) &#123; res += v; &#125; return res; &#125;&#125;; 方法二： 创建nRows个int数组，将s字符串的索引按照0,1,2,…,nRows-2,nRows-1，然后nRows-2,…,2,1,0的顺序装入int输出中。 具体来说，数组下标先递增，直到nRows-1，则反向，直到0，再反向，……直到s字符索引全部装入各数组，再依次组合0~nRows-1个数组。切记一点当到nRows-1返回的时候要从nRows-2开始记录索引，因为之字形返回最后一行数组没有索引元素，但是正向第一行是有索引元素的，所以从0开始。 1234567891011121314151617181920212223242526272829303132class Solution2 &#123;public: string convert(string s, int numRows) &#123; if (numRows == 1) return s; string res = ""; int sLen = s.size(); vector&lt;vector&lt;int&gt;&gt; sIndex(numRows, vector&lt;int&gt;()); int index = 0, flag = 0; for (int i = 0;i&lt;sLen;i++) &#123; index += flag; sIndex[index].push_back(i); if (index==numRows-1) &#123; flag = -1; &#125; else if(index==0) &#123; flag = 1; &#125; &#125; for (int i =0;i&lt;numRows;i++) &#123; for (int j =0;j&lt;sIndex[i].size();j++) &#123; res += s[sIndex[i][j]]; &#125; &#125; return res; &#125;&#125;; Java Code：1234567891011121314151617181920212223242526272829303132class Solution &#123; public String convert(String s, int numRows) &#123; if (null == s) &#123; return s; &#125; int len = s.length(); if (len == 1) &#123; return s; &#125; String[] rowStrs = new String[numRows]; for (int i = 0;i &lt; numRows;i++) &#123; rowStrs[i] = ""; &#125; for (int i = 0;i &lt; len;) &#123; for (int j = 0;j &lt; numRows &amp;&amp; i &lt; len;j++) &#123; rowStrs[j] += s.charAt(i); i++; &#125; for (int j = numRows - 2;j &gt; 0 &amp;&amp; i &lt; len;j--) &#123; rowStrs[j] += s.charAt(i); i++; &#125; &#125; StringBuilder resBuilder = new StringBuilder(); Arrays.asList(rowStrs).forEach(str -&gt; resBuilder.append(str)); return resBuilder.toString(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public String convert(String s, int numRows) &#123; if (null == s) &#123; return s; &#125; int len = s.length(); if (len == 1) &#123; return s; &#125; List&lt;String&gt; rowStrs = new ArrayList(numRows); for (int i = 0;i &lt; numRows;i++) &#123; rowStrs.add(""); &#125; for (int i = 0;i &lt; len;) &#123; for (int j = 0;j &lt; numRows &amp;&amp; i &lt; len;j++) &#123; String rowStr = rowStrs.get(j); rowStr += s.charAt(i); rowStrs.set(j, rowStr); i++; &#125; for (int j = numRows - 2;j &gt; 0 &amp;&amp; i &lt; len;j--) &#123; String rowStr = rowStrs.get(j); rowStr += s.charAt(i); rowStrs.set(j, rowStr); i++; &#125; &#125; StringBuilder resBuilder = new StringBuilder(); rowStrs.forEach(str -&gt; resBuilder.append(str)); return resBuilder.toString(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5. Longest Palindromic Substring]]></title>
    <url>%2F2017%2F06%2F28%2F5-Longest-Palindromic-Substring%2F</url>
    <content type="text"><![CDATA[5. Longest Palindromic SubstringGiven a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring. 题意： 给一个字符串，找到这个字符串的最长回文子串。可以假设给定的字符串的长度最长为1000个字符，而且一定存在一个唯一的最长回文子串。 思路： 判断一个字符串是否是回文串，主要有两种方式判断： 1. 两个指针从两端到中间，如果左右指针不出现不相等的字符，则此字符串是回文串。 2. 两个指针从中间到两端，即中心扩展法，如果左右指针不出现不相等的字符，则此字符串是回文串，注意此方法回文字符串字符数分为奇、偶两种类型。 此题主要采用方法二，从前往后遍历字符串，每个字符都有可能是回文字符串的中点。依次求得各字符作为中心的回文字符串，取其中最长的那个即是结果。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: string longestPalindrome(string s) &#123; string res = ""; if (s.size()&lt;=1) return s; for (int i =0;i&lt;s.size();i++) &#123; string tempPalindrome1 = isPalindrome(s, i, i);//奇数的情况 if (tempPalindrome1.size()&gt;res.size()) &#123; res = tempPalindrome1; &#125; string tempPalindrome2 = isPalindrome(s, i, i+1);//偶数的情况 if (tempPalindrome2.size() &gt; res.size()) &#123; res = tempPalindrome2; &#125; &#125; return res; &#125; string isPalindrome(string s,int pre,int tail) &#123; while (pre&gt;=0&amp;&amp;tail&lt;s.size()) &#123; if (s[pre] == s[tail]) &#123; pre--; tail++; continue; &#125; else break; &#125; return s.substr(pre+1,tail-pre-1); &#125;&#125;; Java Code：1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public String longestPalindrome(String s) &#123; if (null == s) &#123; return ""; &#125; int len = s.length(); String res = ""; for (int i = 0;i &lt; len;i++) &#123; String palindrome1 = getPalindromeStr(s, i, i); if (palindrome1.length() &gt; res.length()) &#123; res = palindrome1; &#125; String palindrome2 = getPalindromeStr(s, i, i + 1); if (palindrome2.length() &gt; res.length()) &#123; res = palindrome2; &#125; &#125; return res; &#125; public String getPalindromeStr(String s,int left, int right) &#123; while(left &gt;=0 &amp;&amp; right &lt; s.length()) &#123; char leftChar = s.charAt(left); char rightChar = s.charAt(right); if (leftChar == rightChar) &#123; left--; right++; &#125; else &#123; break; &#125; &#125; return s.substring(left + 1, right); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4. Median of Two Sorted Arrays]]></title>
    <url>%2F2017%2F06%2F27%2F4-Median-of-Two-Sorted-Arrays%2F</url>
    <content type="text"><![CDATA[4. Median of Two Sorted ArraysThere are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays.The overall run time complexity should be O(log(m + n)). Example 1:nums1 = [1, 3]nums2 = [2]The median is 2.0 Example2:nums1 = [1, 2]nums2 = [3, 4]The median is(2 + 3) / 2 = 2.5 题意： 给定两个排序数组nums1和nums2，大小分别是m和n，找到这两个排序数组的中位数，要求时间复杂度是O(log(m + n))。 思路： 该方法的核心是将原问题转变成一个寻找第k小数的问题（假设两个原序列升序排列），这样中位数实际上是第(m + n) / 2小的数。所以只要解决了第k小数的问题，原问题也得以解决。 首先假设数组A和B的元素个数都大于k / 2，我们比较A[k / 2 - 1]和B[k / 2 - 1]两个元素，这两个元素分别表示A的第k / 2小的元素和B的第k / 2小的元素。这两个元素比较共有三种情况： &gt; 、 &lt; 和 = 。如果A[k / 2 - 1]&lt;B[k / 2 - 1]，这表示A[0]到A[k / 2 - 1]的元素都在A和B合并之后的前k小的元素中。换句话说，A[k / 2 - 1]不可能大于两数组合并之后的第k小值，所以我们可以将其抛弃。 证明也很简单，可以采用反证法。假设A[k / 2 - 1]大于合并之后的第k小值，我们不妨假定其为第（k + 1）小值。由于A[k / 2 - 1]小于B[k / 2 - 1]，所以B[k / 2 - 1]至少是第（k + 2）小值。但实际上，在A中至多存在k / 2 - 1个元素小于A[k / 2 - 1]，B中也至多存在k / 2 - 1个元素小于A[k / 2 - 1]，所以小于A[k / 2 - 1]的元素个数至多有k / 2 + k / 2 - 2，小于k，这与A[k / 2 - 1]是第（k + 1）的数矛盾。 当A[k / 2 - 1]&gt;B[k / 2 - 1]时存在类似的结论。 当A[k / 2 - 1] = B[k / 2 - 1]时，我们已经找到了第k小的数，也即这个相等的元素，我们将其记为m。由于在A和B中分别有k / 2 - 1个元素小于m，所以m即是第k小的数。(这里可能有人会有疑问，如果k为奇数，则m不是中位数。这里是进行了理想化考虑，在实际代码中略有不同，是先求k / 2，然后利用k - k / 2获得另一个数。) 通过上面的分析，我们即可以采用递归的方式实现寻找第k小的数。此外我们还需要考虑几个边界条件： 1. 如果A或者B为空，则直接返回B[k - 1]或者A[k - 1]； 2. 如果k为1，我们只需要返回A[0]和B[0]中的较小值； 3. 如果A[k / 2 - 1] = B[k / 2 - 1]，返回其中一个； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int lenA = nums1.size(); int lenB = nums2.size(); if (lenA == 0 &amp;&amp; lenB == 0) &#123; return 0; &#125; int total = lenA + lenB; if (total &amp; 0x1) &#123; return getKth(nums1, 0, lenA, nums2, 0, lenB, total / 2 + 1);//如果为奇数，寻找第total/2+1小元素 &#125; else//如果为偶数，寻找第total/2+1小和total/2 小元素 &#123; double d1 = getKth(nums1, 0, lenA, nums2, 0, lenB, total / 2 + 1); double d2 = getKth(nums1, 0, lenA, nums2, 0, lenB, total / 2); return (d1 + d2) / 2.0; &#125; &#125; double getKth(vector&lt;int&gt; &amp;nums1,int startA, int lenA, vector&lt;int&gt; &amp;nums2,int startB, int lenB, int totalHalf) &#123; if (lenB &lt; lenA)//把短的数組一定放在前面，便于后面计算 &#123; return getKth(nums2,startB, lenB, nums1,startA, lenA, totalHalf); &#125; if (lenA == 0) &#123; return nums2[startB + totalHalf - 1]; &#125; if (totalHalf == 1) &#123; return min(nums1[startA], nums2[startB]); &#125; int midK1 = min(lenA, totalHalf / 2); int midK2 = totalHalf - midK1; if (nums1[startA + midK1 - 1] &lt; nums2[startB + midK2 - 1]) return getKth(nums1, startA + midK1, lenA - midK1, nums2, startB, lenB, totalHalf - midK1); else if (nums1[startA + midK1 - 1] &gt; nums2[startB + midK2 - 1]) return getKth(nums1, startA, lenA, nums2, startB + midK2, lenB - midK2, totalHalf - midK2); else return nums1[startA + midK1 - 1]; &#125;&#125;;int main()&#123; vector&lt;int&gt; nums1 = &#123; 1,5,8 &#125;; vector&lt;int&gt; nums2 = &#123; 2,6,7 &#125;; Solution s; double res = s.findMedianSortedArrays(nums1, nums2); return 0;&#125; Java Code：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int len1 = nums1.length; int len2 = nums2.length; if (len1 == 0 &amp;&amp; len2 == 0) &#123; return 0; &#125; int total = len1 + len2; if ((total &amp; 1) == 1) &#123; return getKth(nums1, 0, len1, nums2, 0, len2, total / 2 + 1); &#125; else &#123; double pre = getKth(nums1, 0, len1, nums2, 0, len2, total / 2); double after = getKth(nums1, 0, len1, nums2, 0, len2, total / 2 + 1); return (pre + after) / 2; &#125; &#125; public int getKth(int[] nums1, int start1, int len1, int[] nums2, int start2, int len2, int k) &#123; if (len2 &lt; len1) &#123; return getKth(nums2, start2, len2, nums1, start1, len1, k); &#125; if (len1 == 0) &#123; return nums2[start2 + k - 1]; &#125; if (k == 1) &#123; return Math.min(nums1[start1], nums2[start2]); &#125; int elementNum1 = Math.min(len1, k / 2); int elementNum2 = k - elementNum1; if (nums1[start1 + elementNum1 - 1] &lt; nums2[start2 + elementNum2 -1]) &#123; return getKth(nums1, start1 + elementNum1, len1 - elementNum1, nums2, start2, len2, k - elementNum1); &#125; else if (nums1[start1 + elementNum1 - 1] &gt; nums2[start2 + elementNum2 -1]) &#123; return getKth(nums1, start1, len1, nums2, start2 + elementNum2, len2 - elementNum2, k - elementNum2); &#125; else &#123; return nums1[start1 + elementNum1 - 1]; &#125; &#125;&#125;public class MainClass &#123; public static int[] stringToIntegerArray(String input) &#123; input = input.trim(); input = input.substring(1, input.length() - 1); if (input.length() == 0) &#123; return new int[0]; &#125; String[] parts = input.split(","); int[] output = new int[parts.length]; for(int index = 0; index &lt; parts.length; index++) &#123; String part = parts[index].trim(); output[index] = Integer.parseInt(part); &#125; return output; &#125; public static String doubleToString(double input) &#123; return new DecimalFormat("0.00000").format(input); &#125; public static void main(String[] args) throws IOException &#123; BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); String line; while ((line = in.readLine()) != null) &#123; int[] nums1 = stringToIntegerArray(line); line = in.readLine(); int[] nums2 = stringToIntegerArray(line); double ret = new Solution().findMedianSortedArrays(nums1, nums2); String out = doubleToString(ret); System.out.print(out); &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3. Longest Substring Without Repeating Characters]]></title>
    <url>%2F2017%2F06%2F26%2F3-Longest-Substring-Without-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[3. Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters. Examples:Given “abcabcbb”, the answer is “abc”, which the length is 3.Given “bbbbb”, the answer is “b”, with the length of 1.Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. 题意： 从一个字符串中查找子串，但是这个子串中不能包含重复的字符，并且要找出最长的不重字符复子串。 思路： 利用字符映射表来记录此字符之前（包括字符本身）有多少个元素，然后再利用一个元素来记录，此元素对应的之前重复的那个元素的之前的元素个数。 1234567891011121314151617181920212223class Solution&#123;public: int lengthOfLongestSubstring(string s) &#123; //键存储的是字符，值存储的此字符之前（包含此字符自身）有几个元素。 unordered_map&lt;char, int&gt; hash; int n = s.size(); int len = 0; for (int i=0,j=0;j&lt;n;j++) &#123; if (hash.count(s[j])) &#123; //i之前的包括i指向的元素一定包含重复元素，所以在此取i的值的时候要比较当前重复元素是出现在i前面还是后面 //后面的话更新i的值，否则i值不变，例如abba i = max(hash[s[j]], i); &#125; len = max(len, j - i + 1); hash[s[j]] = j+1; &#125; return len; &#125;&#125;; Java Code：12345678910111213141516171819202122232425class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (null == s) &#123; return 0; &#125; int size = s.length(); if (size == 0) &#123; return 0; &#125; Map&lt;Character, Integer&gt; hash = new HashMap(); int after = 0; int maxLength = 0; for (int pre = 0; pre &lt; size; pre++) &#123; char c = s.charAt(pre); if (hash.containsKey(c)) &#123; after = Math.max(hash.get(c), after); &#125; hash.put(c, pre + 1);//包括自身在内，之前的元素个数 maxLength = Math.max(maxLength, pre - after + 1); &#125; return maxLength; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2. Add Two Numbers]]></title>
    <url>%2F2017%2F06%2F22%2F2-Add-Two-Numbers%2F</url>
    <content type="text"><![CDATA[2. Add Two NumbersYou are given two linked lists representing two non - negative numbers.The digits are stored in reverse order and each of their nodes contain a single digit.Add the two numbers and return it as a linked list. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output : 7 -&gt; 0 -&gt; 8 题意： 有两个链表作为输入，它们表示逆序的两个非负数。如下面的两个链表表示的是342和465这两个数。你需要计算它们的和并且用同样的方式逆序输出。如342 + 465 = 807, 你需要把结果表达为7 -&gt;0 -&gt;8 输入: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出:Output : 7 -&gt; 0 -&gt; 8 思路：12345678910111213141516171819202122232425262728ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode head(-1); ListNode *p = &amp;head; int sum = 0; //两个有一个没到头，就继续 while (l1!=NULL||l2!=NULL) &#123; if (l1!=NULL) &#123; sum += l1-&gt;val; l1 = l1-&gt;next; &#125; if (l2!=NULL) &#123; sum += l2-&gt;val; l2 = l2-&gt;next; &#125; p-&gt;next = new ListNode(sum % 10); sum /= 10; p = p-&gt;next; &#125; //记得处理最后的进位 if (sum) &#123; p-&gt;next = new ListNode(sum); &#125; return head.next;&#125; Java Code：1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(-1); ListNode tmp = head; int sum = 0; while(l1 != null || l2 != null) &#123; if (l1 != null) &#123; sum += l1.val; l1 = l1.next; &#125; if (l2 != null) &#123; sum += l2.val; l2 = l2.next; &#125; tmp.next = new ListNode(sum % 10); sum /= 10; tmp = tmp.next; &#125; if (sum &gt; 0) &#123; tmp.next = new ListNode(sum); &#125; return head.next; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1. Two Sum]]></title>
    <url>%2F2017%2F06%2F21%2F1.%20Two%20Sum%2F</url>
    <content type="text"><![CDATA[1. Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution. Example: Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return[0, 1]. UPDATE(2016 / 2 / 13) :The return format had been changed to zero - based indices.Please read the above updated description carefully. 思路： 首先，不能对该数组作任何预处理。因为要求返回是原始数组的下标，如果对数组进行了排序，那么下标就会乱。（如果是有序数组，可以用双指针来做，参见Two Sum II - Input array is sorted） 很容易想到用&lt;value, index&gt;的映射表。遍历numbers，在映射表中寻找target-numbers[i]，若找到则结束，返回存储的下标+1和当前下标+1. （注意题目中规定，以1作为起始下标），若找不到则将&lt;numbers[i], i&gt;加入映射表。 NOTE: 这里又有一个问题，C++中常用的映射表有map, unordered_map。 1234567map: Internally, the elements in a map are always sorted by its key following a specific strict weak ordering criterion indicated by itsinternal comparison object (of type Compare). map containers are generally slower than unordered_map containers to access individual elements by their key, but they allow the direct iterationon subsets based on their order.map::operator[]:Logarithmic in size.（根据键值取元素时间复杂度是对数级别） 123456789unordered_map: Internally, the elements in the unordered_map are not sorted in any particular order with respect to either their key or mapped values,but organized into buckets depending on their hash values to allow for fast access to individual elements directly by their key values (with a constant average time complexity on average). unordered_map containers are faster than map containers to access individual elements by their key, although they are generally less efficientfor range iteration through a subset of their elements.unordered_map::operator[]: Average case: constant.（根据键值取元素平均时间复杂度是常数级别） Worst case: linear in container size.（根据键值取元素最坏时间复杂度是线性级别） 本题只需要根据key访问单个元素，因此unordered_map更合适。时间复杂度O(n)：一次遍历空间复杂度O(n)：unordered_mapps: 严格来说，target-numbers[i]可能溢出int，因此提升为long long int更鲁棒。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res; unordered_map&lt;int, int&gt; hash; for (int i = 0; i &lt; nums.size(); i++) &#123; if (hash.find(target-nums[i])==hash.end()) &#123; hash[nums[i]] = i; &#125; else &#123; res.push_back(hash[target - nums[i]]); res.push_back(i); return res; &#125; &#125; &#125;&#125;;int main()&#123; vector&lt;int&gt; nums = &#123; 2, 7, 11,7,15,7 &#125;; int target = 14; Solution s; auto re = s.twoSum(nums, target); system("pause"); return 0;&#125; Java Code：1234567891011121314class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0;i &lt; nums.length;i++) &#123; int sub = target - nums[i]; if(map.containsKey(sub)) return new int[] &#123;i,map.get(sub)&#125;; else map.put(nums[i],i); &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18. 4Sum]]></title>
    <url>%2F2017%2F06%2F20%2F18-4Sum%2F</url>
    <content type="text"><![CDATA[18. 4Sum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target ? Find all unique quadruplets in the array which gives the sum of target. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note : The solution set must not contain duplicate quadruplets. For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is : [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 思路 对数组排序 确定四元数中的前两个（a，b） 遍历剩余数组确定两外两个（c，d），确定cd时思路跟3Sum确定后两个数据一样，二分查找左右逼近。 在去重时采用set集合 问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一次提交自己写的如下代码也会超时，主要原因是在每层循环的时候都调用nums.size()会造成很多的时间浪费，因为其是一个不变的值，所以应该初始化的时候直接把他付给一个整形变量，后面就不会再重复调用nums.size()了，降低时间复杂度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; set&lt;vector&lt;int&gt;&gt; res2; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); int len = nums.size(); for (int i = 0;i&lt;len-3;i++) &#123; for (int j = i+1;j&lt;len-2;j++) &#123; int pre = j + 1; int tail = len - 1; while (pre &lt; tail) &#123; vector&lt;int&gt; tempRes; int sum = nums[i] + nums[j] + nums[pre] + nums[tail]; if (sum == target) &#123; tempRes.push_back(nums[i]); tempRes.push_back(nums[j]); tempRes.push_back(nums[pre]); tempRes.push_back(nums[tail]); res2.insert(tempRes); pre++; tail--; &#125; else if (sum &lt; target) &#123; pre++; &#125; else tail--; &#125; &#125; &#125; for (auto r : res2) &#123; res.push_back(r); &#125; return res; &#125;&#125;;int main()&#123; vector&lt;int&gt; s = &#123; -3,-2,-1,0,0,1,2,3 &#125;; int target = 0; Solution3 ss; auto res = ss.fourSum(s, target); system("pause"); return 0;&#125; Java Code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; if (null == nums) &#123; return new ArrayList(); &#125; int len = nums.length; if (len == 0) &#123; return new ArrayList(); &#125; Arrays.sort(nums); Set&lt;List&lt;Integer&gt;&gt; resSet = new HashSet(); //-2 -1 0 0 1 2 for (int i = 0;i &lt; len -3;i++) &#123; for (int j = i + 1;j &lt; len -2;j++) &#123; int pre = j + 1; int tail = len -1; while (pre &lt; tail) &#123; List&lt;Integer&gt; res = new ArrayList(); int sum = nums[i] + nums[j] + nums[pre] + nums[tail]; //System.out.println("i:" + i + ",j:" + j + ",pre:" + pre + ",tail:" + tail); //System.out.println(sum); if (target == sum) &#123; res.add(nums[i]); res.add(nums[j]); res.add(nums[pre]); res.add(nums[tail]); resSet.add(res); //System.out.println(res); pre++; tail--; &#125; else if (sum &lt; target) &#123; pre++; &#125; else &#123; tail--; &#125; &#125; &#125; &#125; return resSet.stream().collect(Collectors.toList()); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序的两种实现思路和非递归实现--C++实现]]></title>
    <url>%2F2017%2F06%2F20%2FQuickSort-implement-with-C%2B%2B%2F</url>
    <content type="text"><![CDATA[思路一：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一种是根据算法导论上的思想：取数组的最后一个元素为主元，i初始化为最低位元素的前一个位置，j指向遍历数组中待排序的元素，当j所指元素比主元小的时候i= i + 1，然后交换i和j所指的元素，j不断遍历，遇到小于主元的就进行交换，这样就能一直维持这样一个序列，i之前的元素(包括i所指元素本身)都是比主元小的元素，i到j之间都是比主元大的元素，j(包括j所指元素)之后都是待排序的元素，最后交换主元和第一个比主元大的元素就可以完成划分。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法导论具体介绍如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;快速排序是基于分治模式处理的，对一个典型子数组A[p…r]排序的分治过程为三个步骤： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体实现快速排序的伪代码： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体例子分析详情： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++代码实现如下： ++12345678910111213141516171819202122232425262728//1、进行区域的划分int getPartition(vector&lt;int&gt; &amp;nums, int low, int height)&#123; int keyVal = nums[height]; int i = low - 1; for (int j = low; j &lt; height; j++) &#123; if (nums[j] &lt;= keyVal) &#123; i = i + 1; swap(nums[i], nums[j]); &#125; &#125; swap(nums[i + 1], nums[height]); return i+1;&#125;//2、递归调用划分区域函数，进行快速排序void quickSort(vector&lt;int&gt; &amp;nums,int low,int height) &#123; if (low&lt;height) &#123; int mid = getPartition(nums, low, height); quickSort(nums, low, mid-1); quickSort(nums, mid + 1, height); &#125;&#125; 思路二：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二种是严蔚敏的数据结构(C语言版)上的思想：取数组的第一个元素为主元，左(left)、右(height)两指针进行遍历，先右边开始边查找比主元小的（比主元大时height直接减减），找到就直接覆盖左边所指的元素，然后从左边开始查找比主元大的元素，找到就直接覆盖右边所指的元素，依次循环进行。最后low不小于height时把所取的主元付给low所指的位置，完成划分。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据结构(C语言版)具体介绍如下： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体实现快速排序的伪代码： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体例子分析详情： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++代码实现如下： ++123456789101112131415161718192021222324252627//1、进行区域的划分int getPartition(vector&lt;int&gt; &amp;nums, int low, int height)&#123; int keyVal = nums[low]; while (low&lt;height) &#123; while (low &lt; height&amp;&amp;nums[height] &gt;= keyVal) height--; nums[low] = nums[height]; while (low &lt; height&amp;&amp;nums[low] &lt;= keyVal) low++; nums[height] = nums[low]; &#125; nums[low] = keyVal; return low;&#125;//2、递归调用划分区域函数，进行快速排序void quickSort(vector&lt;int&gt; &amp;nums,int low,int height) &#123; if (low&lt;height) &#123; int mid = getPartition(nums, low, height); quickSort(nums, low, mid-1); quickSort(nums, mid + 1, height); &#125;&#125; 最后呈上快速排序的非递归实现： ++1234567891011121314151617181920212223242526272829303132333435363738void quickSortNonRecursive(vector&lt;int&gt; &amp;nums, int low, int height)&#123; stack&lt;int&gt; s; if (low&lt;height) &#123; int mid = getPartition(nums, low, height); if (mid-1&gt;low) &#123; s.push(low); s.push(mid - 1); &#125; if (mid+1&lt;height) &#123; s.push(mid + 1); s.push(height); &#125; while (!s.empty()) &#123; int qHeight = s.top(); s.pop(); int pLow = s.top(); s.pop(); int pqMid = getPartition(nums, pLow, qHeight); if (pqMid - 1 &gt; pLow) &#123; s.push(pLow); s.push(pqMid - 1); &#125; if (pqMid + 1 &lt; qHeight) &#123; s.push(pqMid + 1); s.push(qHeight); &#125; &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实经过测试非递归的算法比递归实现还要慢。 因为递归算法使用的栈由程序自动产生，栈中包含：函数调用时的参数和函数中的局部变量。如果局部变量很多或者函数内部又调用了其他函数，则栈会很大。每次递归调用都要操作很大的栈，效率自然会下降。而对于非递归算法，每次循环使用自己预先创建的栈，因此不管程序复杂度如何，都不会影响程序效率。但是对于上面的快速排序，由于局部变量只有一个mid，栈很小，所以效率并不比非递归实现的低。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体的关于快速排序的优化，见文章快速排序优化。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的博客]]></title>
    <url>%2F2017%2F06%2F19%2Fhello-world2%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo O(∩_∩)O哈哈哈~ More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试分类和标签]]></title>
    <url>%2F2017%2F06%2F19%2Fhello-world2%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo O(∩_∩)O哈哈哈~ More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
