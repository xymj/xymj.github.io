<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PikachuBLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-24T04:01:33.775Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>CodePikachu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-CN 每日一题汇总</title>
    <link href="http://yoursite.com/2020/06/24/leetcode-cn/leetcode-cn-one-question-per-day/"/>
    <id>http://yoursite.com/2020/06/24/leetcode-cn/leetcode-cn-one-question-per-day/</id>
    <published>2020-06-24T03:32:51.000Z</published>
    <updated>2020-06-24T04:01:33.775Z</updated>
    
    <content type="html"><![CDATA[<p>Goog Good Study, Day Day Up……<br><a id="more"></a></p><h1 id="2020-06"><a href="#2020-06" class="headerlink" title="2020-06"></a>2020-06</h1><table><thead><tr><th>日期</th><th>题目</th><th>题解  </th></tr></thead><tbody><tr><td>24</td><td><a href="https://leetcode-cn.com/problems/3sum-closest/" title="16. 最接近的三数之和" target="_blank" rel="noopener"> 16. 最接近的三数之和</a></td><td><a href="https://leetcode-cn.com/problems/3sum-closest/solution/zui-jie-jin-de-san-shu-zhi-he-by-leetcode-solution/" title="最接近的三数之和题解" target="_blank" rel="noopener">排序 + 双指针  </a></td></tr><tr><td>25</td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Goog Good Study, Day Day Up……&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>70. Climbing Stairs</title>
    <link href="http://yoursite.com/2019/12/16/70-Climbing-Stairs/"/>
    <id>http://yoursite.com/2019/12/16/70-Climbing-Stairs/</id>
    <published>2019-12-16T15:29:41.000Z</published>
    <updated>2019-12-16T15:33:01.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a>70. Climbing Stairs</h1><p>You are climbing a stair case. It takes n steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?<br><a id="more"></a><br>Note: Given n will be a positive integer.</p><p>Example 1:</p><p>Input: 2<br>Output: 2<br>Explanation: There are two ways to climb to the top.</p><ol><li>1 step + 1 step</li><li>2 steps</li></ol><p>Example 2:</p><p>Input: 3<br>Output: 3<br>Explanation: There are three ways to climb to the top.</p><ol><li>1 step + 1 step + 1 step</li><li>1 step + 2 steps</li><li>2 steps + 1 step</li></ol><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>　　简单的动态规划思想，每一阶楼梯踏上的次数等于n-1阶和n-2的次数之和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> n;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//return climbStairs(n - 1) + climbStairs(n - 2);递归超时</span></span><br><span class="line">       <span class="comment">//使用数组存储到达每阶楼梯的方法次数</span></span><br><span class="line">       <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">       dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">       dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n;i++) &#123;</span><br><span class="line">           dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;70-Climbing-Stairs&quot;&gt;&lt;a href=&quot;#70-Climbing-Stairs&quot; class=&quot;headerlink&quot; title=&quot;70. Climbing Stairs&quot;&gt;&lt;/a&gt;70. Climbing Stairs&lt;/h1&gt;&lt;p&gt;You are climbing a stair case. It takes n steps to reach to the top.&lt;/p&gt;
&lt;p&gt;Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>69. Sqrt(x)</title>
    <link href="http://yoursite.com/2019/12/16/69-Sqrt(x)/"/>
    <id>http://yoursite.com/2019/12/16/69-Sqrt(x)/</id>
    <published>2019-12-16T14:13:41.000Z</published>
    <updated>2019-12-16T15:11:34.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="69-Sqrt-x"><a href="#69-Sqrt-x" class="headerlink" title="69. Sqrt(x)"></a>69. Sqrt(x)</h1><p>Implement int sqrt(int x).</p><p>Compute and return the square root of x, where x is guaranteed to be a non-negative integer.</p><p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.<br><a id="more"></a><br>Example 1:</p><p>Input: 4<br>Output: 2</p><p>Example 2:</p><p>Input: 8<br>Output: 2<br>Explanation: The square root of 8 is 2.82842…, and since the decimal part is truncated, 2 is returned.</p><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>　　二分查找，逐步找出平方接近x的值，并且用除的方式来比较查找的平方根的目标值，而不用乘法，防止整形越界。</p><p>###方法一：<br>        性能不是很好，并且取了long来针对越界问题，不是很好的解决方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (<span class="keyword">int</span>)Math.ceil(x / <span class="number">2.0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">1</span>;i &lt;= mid;i++) &#123;<span class="comment">//如果i不设置为long，那么i * i会按整形计算，超出整形32位的数字将会被抛弃，然后再转换为long，只有long * long 才不会出现越界问题</span></span><br><span class="line">            <span class="keyword">long</span> pow = i * i;</span><br><span class="line">            <span class="keyword">long</span> morePow = (i + <span class="number">1</span>) * (i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (pow &lt;= x &amp;&amp; morePow &gt; x) &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">int</span>)i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###方法二：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x == <span class="number">0</span> || x == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> right = x;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">           <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">int</span> sqrtVal = x / mid;</span><br><span class="line">           <span class="keyword">if</span> (mid == sqrtVal) &#123;</span><br><span class="line">               <span class="keyword">return</span> mid;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid &lt; sqrtVal) &#123;</span><br><span class="line">               left = mid + <span class="number">1</span>;</span><br><span class="line">               res = mid;<span class="comment">//记录下mid平方比x小的值，因为平方根取整后结果的平方肯定比x小</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               right = mid - <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;69-Sqrt-x&quot;&gt;&lt;a href=&quot;#69-Sqrt-x&quot; class=&quot;headerlink&quot; title=&quot;69. Sqrt(x)&quot;&gt;&lt;/a&gt;69. Sqrt(x)&lt;/h1&gt;&lt;p&gt;Implement int sqrt(int x).&lt;/p&gt;
&lt;p&gt;Compute and return the square root of x, where x is guaranteed to be a non-negative integer.&lt;/p&gt;
&lt;p&gt;Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>50. Pow(x, n)</title>
    <link href="http://yoursite.com/2019/12/03/50-Pow(x,n)/"/>
    <id>http://yoursite.com/2019/12/03/50-Pow(x,n)/</id>
    <published>2019-12-03T14:25:15.000Z</published>
    <updated>2019-12-03T14:51:03.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a>50. Pow(x, n)</h1><p>Implement pow(x, n), which calculates x raised to the power(x,n).</p><p>Example 1:</p><p>Input: 2.00000, 10<br>Output: 1024.00000<br><a id="more"></a><br>Example 2:</p><p>Input: 2.10000, 3<br>Output: 9.26100</p><p>Example 3:</p><p>Input: 2.00000, -2<br>Output: 0.25000<br>Explanation: 2-2 = 1/22 = 1/4 = 0.25</p><p>Note:</p><pre><code>-100.0 &lt; x &lt; 100.0n is a 32-bit signed integer, within the range [−231, 231 − 1]</code></pre><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　    实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>　　使用折半计算，每次把n缩小一半，这样n最终会缩小到0，任何数的0次方都为1，这时候我们再往回乘，如果此时n是偶数，直接把上次递归得到的值算个平方返回即可；如果是奇数，需要判断n是否为负数，n是负数的情况，需要把上次递归得到的值平方后乘以1/x，n是正数的情况，需要把上次递归得到的值平方后乘以x。</p><p>‘’’<br>思想： 使用折半计算。<br>    例如x=2,n=10<br>        res = 1, i = n</p><pre><code>i = 10     x = 2i = 5      res *= x, x = 4i = 2      x = 16i = 1      res = res *x即：i = 10     2,2,2,2,2,2,2,2,2,2i = 5      4,4,4,4,4   res=4i = 2      16,16i = 1      256,   res = 4 * 256i = 0      256*256    i不满足条件，循环停止</code></pre><p>‘’’</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> minPowValue = myPow(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            x = n &lt; <span class="number">0</span> ? <span class="number">1</span> / x * minPowValue * minPowValue : x * minPowValue * minPowValue;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x = minPowValue * minPowValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;50-Pow-x-n&quot;&gt;&lt;a href=&quot;#50-Pow-x-n&quot; class=&quot;headerlink&quot; title=&quot;50. Pow(x, n)&quot;&gt;&lt;/a&gt;50. Pow(x, n)&lt;/h1&gt;&lt;p&gt;Implement pow(x, n), which calculates x raised to the power(x,n).&lt;/p&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;p&gt;Input: 2.00000, 10&lt;br&gt;Output: 1024.00000&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>29. Divide Two Integers</title>
    <link href="http://yoursite.com/2019/11/15/29-Divide-Two-Integers/"/>
    <id>http://yoursite.com/2019/11/15/29-Divide-Two-Integers/</id>
    <published>2019-11-14T16:03:58.000Z</published>
    <updated>2019-11-13T16:08:09.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="29-Divide-Two-Integers"><a href="#29-Divide-Two-Integers" class="headerlink" title="29. Divide Two Integers"></a>29. Divide Two Integers</h1><p>Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.</p><p>Return the quotient after dividing dividend by divisor.</p><p>The integer division should truncate toward zero.</p><p>Example 1:</p><p>Input: dividend = 10, divisor = 3<br>Output: 3</p><p>Example 2:</p><p>Input: dividend = 7, divisor = -3<br>Output: -2</p><p>Note:</p><pre><code>Both dividend and divisor will be 32-bit signed integers.The divisor will never be 0.Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.</code></pre><a id="more"></a><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><pre><code>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。返回被除数 dividend 除以除数 divisor 得到的商。</code></pre><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><pre><code>1. 被除数和除数均为 32 位有符号整数。2. 除数不为 0。3. 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</code></pre><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解题思路：这题是除法，所以先普及下除法术语</span></span><br><span class="line"><span class="comment"> * 商，公式是：(被除数-余数)÷除数=商，记作：被除数÷除数=商...余数，是一种数学术语。</span></span><br><span class="line"><span class="comment"> * 在一个除法算式里，被除数、余数、除数和商的关系为：(被除数-余数)÷除数=商，记作：被除数÷除数=商...余数，</span></span><br><span class="line"><span class="comment"> * 进而推导得出：商×除数+余数=被除数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 要求商，我们首先想到的是减法，能被减多少次，那么商就为多少，但是明显减法的效率太低</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 那么我们可以用位移法，因为计算机在做位移时效率特别高，向左移1相当于乘以2，向右位移1相当于除以2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 我们可以把一个dividend（被除数）先除以2^n，n最初为31，不断减小n去试探,当某个n满足dividend/2^n&gt;=divisor时，</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 表示我们找到了一个足够大的数，这个数*divisor是不大于dividend的，所以我们就可以减去2^n个divisor，以此类推</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 我们可以以100/3为例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2^n是1，2，4，8...2^31这种数，当n为31时，这个数特别大，100/2^n是一个很小的数，肯定是小于3的，所以循环下来，</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当n=5时，100/32=3, 刚好是大于等于3的，这时我们将100-32*3=4，也就是减去了32个3，接下来我们再处理4，同样手法可以再减去一个3</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所以一共是减去了33个3，所以商就是33</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这其中得处理一些特殊的数，比如divisor是不能为0的，Integer.MIN_VALUE和Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="Java-Code："><a href="#Java-Code：" class="headerlink" title="　Java Code："></a>　Java Code：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (divisor == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> negative = (dividend ^ divisor) &lt; <span class="number">0</span>;<span class="comment">//用异或来计算是否符号相异</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> up = Math.abs((<span class="keyword">long</span>)dividend); <span class="comment">//注意转换为long类型</span></span><br><span class="line">        <span class="keyword">long</span> down = Math.abs((<span class="keyword">long</span>)divisor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">long</span> divValue = (up &gt;&gt; i);</span><br><span class="line">            <span class="keyword">if</span> (divValue &gt;= down) &#123; <span class="comment">//找出足够大的数2^n*divisor</span></span><br><span class="line">                up -= (down &lt;&lt; i); <span class="comment">//将结果加上2^n</span></span><br><span class="line">                result += (<span class="number">1</span> &lt;&lt; i); <span class="comment">//将被除数减去2^n*divisor</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> negative ? -result : result;  <span class="comment">//符号相异取反</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;29-Divide-Two-Integers&quot;&gt;&lt;a href=&quot;#29-Divide-Two-Integers&quot; class=&quot;headerlink&quot; title=&quot;29. Divide Two Integers&quot;&gt;&lt;/a&gt;29. Divide Two Integers&lt;/h1&gt;&lt;p&gt;Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.&lt;/p&gt;
&lt;p&gt;Return the quotient after dividing dividend by divisor.&lt;/p&gt;
&lt;p&gt;The integer division should truncate toward zero.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;p&gt;Input: dividend = 10, divisor = 3&lt;br&gt;Output: 3&lt;/p&gt;
&lt;p&gt;Example 2:&lt;/p&gt;
&lt;p&gt;Input: dividend = 7, divisor = -3&lt;br&gt;Output: -2&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Both dividend and divisor will be 32-bit signed integers.
The divisor will never be 0.
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>8. String to Integer (atoi)</title>
    <link href="http://yoursite.com/2019/10/16/8-String-to-Integer-(atoi)/"/>
    <id>http://yoursite.com/2019/10/16/8-String-to-Integer-(atoi)/</id>
    <published>2019-10-16T13:56:00.000Z</published>
    <updated>2019-12-03T14:22:34.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8. String to Integer (atoi)"></a>8. String to Integer (atoi)</h1><p>Implement atoi which converts a string to an integer.</p><p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p><p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p><p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p><p>If no valid conversion could be performed, a zero value is returned.<br><a id="more"></a><br>Note:</p><pre><code>Only the space character &apos; &apos; is considered as whitespace character.Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</code></pre><p><strong>Example 1:</strong></p><p>Input: “42”<br>Output: 42</p><p><strong>Example 2:</strong></p><p>Input: “   -42”<br>Output: -42<br>Explanation: The first non-whitespace character is ‘-‘, which is the minus sign.<br>             Then take as many numerical digits as possible, which gets 42.</p><p><strong>Example 3:</strong></p><p>Input: “4193 with words”<br>Output: 4193<br>Explanation: Conversion stops at digit ‘3’ as the next character is not a numerical digit.</p><p><strong>Example 4:</strong></p><p>Input: “words and 987”<br>Output: 0<br>Explanation: The first non-whitespace character is ‘w’, which is not a numerical<br>             digit or a +/- sign. Therefore no valid conversion could be performed.</p><p><strong>Example 5:</strong></p><p>Input: “-91283472332”<br>Output: -2147483648<br>Explanation: The number “-91283472332” is out of the range of a 32-bit signed integer.<br>             Thefore INT_MIN (−231) is returned.</p><!--more--><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><pre><code>请你来实现一个 atoi 函数，使其能将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。在任何情况下，若函数不能进行有效的转换时，请返回 0。说明：假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == str) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        str = str.trim();</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> positive = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> first = str.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="string">'+'</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first == <span class="string">'-'</span>) &#123;</span><br><span class="line">            positive = <span class="keyword">false</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;i &lt; len;i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> num = c - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; <span class="number">0</span> || num &gt; <span class="number">9</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (positive) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="number">10</span> || (res == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; num &gt; Integer.MAX_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">                   <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                res = res * <span class="number">10</span> + num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (res &lt; Integer.MIN_VALUE / <span class="number">10</span> || (res == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; -num &lt; Integer.MIN_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                res = res * <span class="number">10</span> - num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;8-String-to-Integer-atoi&quot;&gt;&lt;a href=&quot;#8-String-to-Integer-atoi&quot; class=&quot;headerlink&quot; title=&quot;8. String to Integer (atoi)&quot;&gt;&lt;/a&gt;8. String to Integer (atoi)&lt;/h1&gt;&lt;p&gt;Implement atoi which converts a string to an integer.&lt;/p&gt;
&lt;p&gt;The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.&lt;/p&gt;
&lt;p&gt;The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.&lt;/p&gt;
&lt;p&gt;If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.&lt;/p&gt;
&lt;p&gt;If no valid conversion could be performed, a zero value is returned.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>9.Palindrome Number</title>
    <link href="http://yoursite.com/2019/10/13/9-Palindrome-Number/"/>
    <id>http://yoursite.com/2019/10/13/9-Palindrome-Number/</id>
    <published>2019-10-13T07:17:00.000Z</published>
    <updated>2019-11-19T15:07:14.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9.Palindrome Number"></a>9.Palindrome Number</h1><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p><p><strong>Example 1:</strong></p><p>Input: 121</p><p>Output: true</p><p><strong>Example 2:</strong></p><p>Input: -121</p><p>Output: false</p><p>Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</p><p><strong>Example 3:</strong></p><p>Input: 10</p><p>Output: false</p><p>Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</p><p>Follow up:</p><p>Coud you solve it without converting the integer to a string?</p><a id="more"></a><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Special cases:</span></span><br><span class="line">        <span class="comment">// As discussed above, when x &lt; 0, x is not a palindrome.</span></span><br><span class="line">        <span class="comment">// Also if the last digit of the number is 0, in order to be a palindrome,</span></span><br><span class="line">        <span class="comment">// the first digit of the number also needs to be 0.</span></span><br><span class="line">        <span class="comment">// Only 0 satisfy this property.</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rightNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; rightNum) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            rightNum = rightNum * <span class="number">10</span> + digit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When the length is an odd number, we can get rid of the middle digit by revertedNumber/10</span></span><br><span class="line">        <span class="comment">// For example when the input is 12321, at the end of the while loop we get x = 12, revertedNumber = 123,</span></span><br><span class="line">        <span class="comment">// since the middle digit doesn't matter in palidrome(it will always equal to itself), we can simply get rid of it.</span></span><br><span class="line">        <span class="keyword">return</span> x == rightNum || x == rightNum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;9-Palindrome-Number&quot;&gt;&lt;a href=&quot;#9-Palindrome-Number&quot; class=&quot;headerlink&quot; title=&quot;9.Palindrome Number&quot;&gt;&lt;/a&gt;9.Palindrome Number&lt;/h1&gt;&lt;p&gt;Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Input: 121&lt;/p&gt;
&lt;p&gt;Output: true&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Input: -121&lt;/p&gt;
&lt;p&gt;Output: false&lt;/p&gt;
&lt;p&gt;Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Input: 10&lt;/p&gt;
&lt;p&gt;Output: false&lt;/p&gt;
&lt;p&gt;Explanation: Reads 01 from right to left. Therefore it is not a palindrome.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;/p&gt;
&lt;p&gt;Coud you solve it without converting the integer to a string?&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>7.Reverse Integer</title>
    <link href="http://yoursite.com/2019/10/11/7-reverse-integer/"/>
    <id>http://yoursite.com/2019/10/11/7-reverse-integer/</id>
    <published>2019-10-11T15:18:00.000Z</published>
    <updated>2019-10-13T07:17:08.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7. Reverse Integer"></a>7. Reverse Integer</h1><p>Given a 32-bit signed integer, reverse digits of an integer.</p><p><strong>Example 1:</strong></p><p>Input: 123</p><p>Output: 321</p><p><strong>Example 2:</strong></p><p>Input: -123</p><p>Output: -321</p><p><strong>Example 3:</strong></p><p>Input: 120</p><p>Output: 21</p><p>Note:<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><a id="more"></a><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>  假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= Integer.MIN_VALUE || x &gt;= Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Integer.MAX_VALUE = 2147483647</span></span><br><span class="line">        <span class="comment">//Integer.MIN_VALUE = -2147483648</span></span><br><span class="line">        <span class="keyword">int</span> maxCeiling = Integer.MAX_VALUE / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> minFloor = Integer.MIN_VALUE / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res &gt; maxCeiling) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res &lt; minFloor) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> digit = x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (res == maxCeiling &amp;&amp; digit &gt; <span class="number">7</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res == minFloor &amp;&amp; digit &lt; -<span class="number">8</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + digit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= Integer.MIN_VALUE || x &gt;= Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Integer.MAX_VALUE = 2147483647</span></span><br><span class="line">        <span class="comment">//Integer.MIN_VALUE = -2147483648</span></span><br><span class="line">        <span class="keyword">int</span> maxCeiling = Integer.MAX_VALUE / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> minFloor = Integer.MIN_VALUE / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + digit;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (res &lt;= Integer.MIN_VALUE || res &gt;= Integer.MAX_VALUE) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;7-Reverse-Integer&quot;&gt;&lt;a href=&quot;#7-Reverse-Integer&quot; class=&quot;headerlink&quot; title=&quot;7. Reverse Integer&quot;&gt;&lt;/a&gt;7. Reverse Integer&lt;/h1&gt;&lt;p&gt;Given a 32-bit signed integer, reverse digits of an integer.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Input: 123&lt;/p&gt;
&lt;p&gt;Output: 321&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Input: -123&lt;/p&gt;
&lt;p&gt;Output: -321&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Input: 120&lt;/p&gt;
&lt;p&gt;Output: 21&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>CPU占用分析</title>
    <link href="http://yoursite.com/2018/09/16/Java/2018-09-16-cpu-analysis/"/>
    <id>http://yoursite.com/2018/09/16/Java/2018-09-16-cpu-analysis/</id>
    <published>2018-09-16T13:17:00.000Z</published>
    <updated>2018-09-16T15:17:38.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>&ensp;&ensp;&ensp;当程序中出现死循环，或者计算量很大的线程的时候，就会导致Java程序进程占用大量CPU资源，从而可能导致程序挂掉，此文从实例进行概述具体的查询占用CPU资源高的程序代码。<br><a id="more"></a></p><h2 id="二、排查步骤"><a href="#二、排查步骤" class="headerlink" title="二、排查步骤"></a>二、排查步骤</h2><ol><li>查看占用CPU高的进程<ul><li>top命令</li></ul></li><li>查看进程中占用CPU最多的线程。<ul><li>top -Hp ${pid} 命令（PID表示进程ID，排列靠前的几个基本都是此进程下最占用CPU资源的线程）</li></ul></li><li>将进程信息转出到文件。<ul><li>jstack -l ${pid} &gt; ${file.log}</li></ul></li><li>将线程ID转成16进制。<ul><li>printf ‘%x\n’ ${TID} 命令（TID表示线程ID）</li></ul></li><li>根据16进制线程ID在3中输出的file.log中找到对应线程的息更具体代码信息。</li></ol><h2 id="三、具体实例"><a href="#三、具体实例" class="headerlink" title="三、具体实例"></a>三、具体实例</h2><h3 id="1、实例代码"><a href="#1、实例代码" class="headerlink" title="1、实例代码"></a>1、实例代码</h3><p>&ensp;&ensp;&ensp;很简单的一个死循环例子，来模仿占用CPU资源，然后进行问题排查。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CPUTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2、问题排查"><a href="#2、问题排查" class="headerlink" title="2、问题排查"></a>2、问题排查</h3><p>&ensp;&ensp;&ensp;1)、启动程序，top命令查看当前占用CPU资源最高的进程，如下图：<br><img src="/images/top.png" alt="top.png"><br>&ensp;&ensp;&ensp;从图中可以看出进程5278所占用的CPU资源99.5%，并且从COMMAND能看出确实是启动的Java进程，说明Java程序中存在问题，导致狂占CPU资源。</p><p>&ensp;&ensp;&ensp;2)、对1)中得到的占用CPU资源高的进程执行top -Hp 5278，得到此Java进程内最占用CPU资源的线程，如下图：<br><img src="/images/top-Hp.png" alt="top-Hp.png"><br>&ensp;&ensp;&ensp;从图中可以看出线程5279所占用的CPU资源99.6%，这就可以明确的定位到Java程序中占用CPU资源的线程号5279。</p><p>&ensp;&ensp;&ensp;3)、对2)中得到的占用CPU资源高的线程号执行printf ‘%x\n’ 5279，得到线程号的十六进制值149f，如下图：<br><img src="/images/tid-16Hx.png" alt="tid-16Hx.png"></p><p>&ensp;&ensp;&ensp;4)、通过jstack -l 5278 &gt; file.log 重定向输出Java进程的jstack日志。</p><p>&ensp;&ensp;&ensp;5)、通过对3)中得到的线程十六进制值，在4)的file.log中查找线程中具体的占用CPU资源的代码信息，如下图：<br><img src="/images/paramerror.png" alt="paramerror.png"><br>&ensp;&ensp;&ensp;从图中可以看出线程0x149f主线程中具体的占用CPU资源的代码行，定位到文字开始的实例代码，可以看到正常程序中的while死循环造成的CPU资源占用过高，从而定位代码问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;当程序中出现死循环，或者计算量很大的线程的时候，就会导致Java程序进程占用大量CPU资源，从而可能导致程序挂掉，此文从实例进行概述具体的查询占用CPU资源高的程序代码。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="CPU" scheme="http://yoursite.com/tags/CPU/"/>
    
  </entry>
  
  <entry>
    <title>G1垃圾收集器</title>
    <link href="http://yoursite.com/2018/09/09/Java/jvm/2018-09-09-g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://yoursite.com/2018/09/09/Java/jvm/2018-09-09-g1垃圾收集器/</id>
    <published>2018-09-09T05:12:00.000Z</published>
    <updated>2018-09-09T15:25:07.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>&ensp;&ensp;&ensp;本文主要通过对比G1(Garbage-Firs Collector)和CMS(Concurrent Mark-Sweep Collector)垃圾收集器的堆内存结构，以及具体垃圾收集过程，每个过程中是怎么扫描虚拟机堆，来阐述G1垃圾收集器的原理和具体优势。</p><p>&ensp;&ensp;&ensp;G1是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器。以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征. 在Oracle JDK 7 update 4 及以上版本中得到完全支持, 专为以下应用程序设计:</p><ul><li>可以像CMS收集器一样,GC操作与应用的线程一起并发执行。</li><li>紧凑的空闲内存区间且没有很长的GC停顿时间。</li><li>需要可预测的GC暂停耗时。</li><li>不想牺牲太多吞吐量性能。</li><li>启动后不需要请求更大的Java堆。<a id="more"></a>&ensp;&ensp;&ensp;G1的长期目标是取代CMS(Concurrent Mark-Sweep Collector, 并发标记-清除)。因为特性的不同使G1成为比CMS更好的解决方案。一个区别是,G1是一款压缩型的收集器。G1通过有效的压缩完全避免了对细微空闲内存空间的分配,不用依赖于regions，这不仅大大简化了收集器，而且还消除了潜在的内存碎片问题。除压缩以外，G1的垃圾收集停顿也比CMS容易估计，也允许用户自定义所希望的停顿参数。</li></ul><h2 id="二、G1、CMS垃圾收集器内存结构"><a href="#二、G1、CMS垃圾收集器内存结构" class="headerlink" title="二、G1、CMS垃圾收集器内存结构"></a>二、G1、CMS垃圾收集器内存结构</h2><p>&ensp;&ensp;&ensp;G1出现之前的上一代垃圾收集器(串行serial, 并行parallel, 以及CMS)都把堆内存划分为固定大小的三个部分: 年轻代(young generation), 年老代(old generation), 以及持久代(permanent generation)。Java堆内存的每个对象都存放在这三个区域中的一个。<br><img src="/images/02_1_HeapStructure_CN.png" alt="HeapStructure_CN.png"></p><p>&ensp;&ensp;&ensp;G1采用一种不同的方式来管理堆内存。堆内存被划分为多个大小相等的heap区,每个heap区都是逻辑上连续的一段内存(virtual memory)。其中一部分区域被当成老一代收集器相同的角色(eden, survivor, old), 但每个角色的区域个数都不是固定的。这在内存使用上提供了更多的灵活性。<br><img src="/images/02_2_G1HeapAllocation_CN.png" alt="G1HeapAllocation_CN.png"></p><p>&ensp;&ensp;&ensp;G1执行垃圾回收的处理方式与CMS相似。G1在全局标记阶段(global marking phase)并发执行, 以确定堆内存中哪些对象是存活的。标记阶段完成后,G1就可以知道哪些heap区的empty空间最大。它会首先回收这些区,通常会得到大量的自由空间。这也是为什么这种垃圾收集方法叫做Garbage-First(垃圾优先)的原因。顾名思义, G1将精力集中放在可能布满可收回对象的区域, 可回收对象(reclaimable objects)也就是所谓的垃圾。G1使用暂停预测模型(pause prediction model)来达到用户定义的目标暂停时间,并根据目标暂停时间来选择此次进行垃圾回收的heap区域数量。</p><p>&ensp;&ensp;&ensp;被G1标记为适合回收的heap区将使用转移(evacuation)的方式进行垃圾回收。G1将一个或多个heap区域中的对象拷贝到其他的单个区域中,并在此过程中压缩和释放内存. 在多核CPU上转移是并行执行的(parallel on multi-processors), 这样能减少停顿时间并增加吞吐量。因此,每次垃圾收集时, G1都会持续不断地减少碎片, 并且在用户给定的暂停时间内执行。这比以前的方法强大了很多。CMS垃圾收集器(Concurrent Mark Sweep,并发标记清理)不进行压缩。ParallelOld垃圾收集只对整个堆执行压缩,从而导致相当长的暂停时间。</p><p>&ensp;&ensp;&ensp;需要强调的是, G1并不是一款实时垃圾收集器(real-time collector)。能以极高的概率在设定的目标暂停时间内完成,但不保证绝对在这个时间内完成。基于以前收集的各种监控数据,G1会根据用户指定的目标时间来预估能回收多少个heap区。因此,收集器有一个相当精确的heap区耗时计算模型,并根据该模型来确定在给定时间内去回收哪些heap区。</p><p>&ensp;&ensp;&ensp;注意：G1分为两个阶段: 并发阶段(concurrent, 与应用线程一起运行, 如: 细化 refinement、标记 marking、清理 cleanup) 和并行阶段(parallel, 多线程执行, 如: 停止所有JVM线程, stop the world)。而FullGC(完整垃圾收集)仍然是单线程的, 但如果进行适当的调优,则应用程序应该能够避免 full GC。</p><h3 id="1、G1内存占用-Footprint"><a href="#1、G1内存占用-Footprint" class="headerlink" title="1、G1内存占用(Footprint)"></a>1、G1内存占用(Footprint)</h3><p>&ensp;&ensp;&ensp;如果从 ParallelOldGC 或者 CMS收集器迁移到 G1, 您可能会看到JVM进程占用更多的内存(a larger JVM process size)。这在很大程度上与 “accounting” 数据结构有关, 如 Remembered Sets 和 Collection Sets。</p><p>&ensp;&ensp;&ensp;Remembered Sets 简称 RSets, 跟踪指向某个heap区内的对象引用. 堆内存中的每个区都有一个 RSet。 RSet 使heap区能并行独立地进行垃圾集合。 RSets的总体影响小于5%.</p><p>&ensp;&ensp;&ensp;Collection Sets 简称 CSets, 收集集合, 在一次GC中将执行垃圾回收的heap区。GC时在CSet中的所有存活数据(live data)都会被转移(复制/移动)。集合中的heap区可以是 Eden, survivor, old generation。CSets所占用的JVM内存小于1%。</p><h3 id="2、推荐使用G1的场景-Recommended-Use-Cases"><a href="#2、推荐使用G1的场景-Recommended-Use-Cases" class="headerlink" title="2、推荐使用G1的场景(Recommended Use Cases)"></a>2、推荐使用G1的场景(Recommended Use Cases)</h3><p>&ensp;&ensp;&ensp;G1的首要目标是为需要大量内存的系统提供一个保证<strong>GC低延迟</strong>的解决方案。也就是说堆内存在6GB及以上,稳定和可预测的暂停时间小于0.5秒。</p><p>&ensp;&ensp;&ensp;如果应用程序具有如下的一个或多个特征,那么将垃圾收集器从CMS或ParallelOldGC切换到G1将会大大提升性能。</p><ul><li>Full GC 次数太频繁或者消耗时间太长.</li><li>对象分配的频率或代数提升(promotion)显著变化.</li><li>受够了太长的垃圾回收或内存整理时间(超过0.5~1秒)</li></ul><p>&ensp;&ensp;&ensp;注意: 如果正在使用CMS或ParallelOldGC,而应用程序的垃圾收集停顿时间并不长,那么继续使用现在的垃圾收集器是个好主意。使用最新的JDK时并不要求切换到G1收集器。</p><h2 id="三、CMS垃圾收集器概述"><a href="#三、CMS垃圾收集器概述" class="headerlink" title="三、CMS垃圾收集器概述"></a>三、CMS垃圾收集器概述</h2><p>&ensp;&ensp;&ensp;并发标记清理(CMS, Concurrent Mark Sweep)收集器(也称为多并发低暂停的收集器)回收老年代内存(tenured generation)。它将垃圾回收中的绝大部分工作与应用程序的线程一起并发执行,以期能最小化暂停时间。通常多并发低暂停收集器<strong>不复制或也不压缩存活的对象</strong>。垃圾回收不移动存活的对象, 如果产生内存碎片问题,就会分配/占用更大的堆内存空间。</p><h3 id="1、CMS垃圾收集阶段划分-Collection-Phases"><a href="#1、CMS垃圾收集阶段划分-Collection-Phases" class="headerlink" title="1、CMS垃圾收集阶段划分(Collection Phases)"></a>1、CMS垃圾收集阶段划分(Collection Phases)</h3><p>&ensp;&ensp;&ensp;CMS收集器在老年代堆内存的回收中执行分为以下阶段:</p><style>table th:first-of-type {    width: 245px;}</style><table><thead><tr><th>操作阶段</th><th>主要操作</th></tr></thead><tbody><tr><td>1、初始标记 (Initial Mark)</td><td>(Stop the World Event,所有应用线程暂停) 在老年代(old generation)中的对象, 如果从年轻代(young generation)中能访问到, 则被 “标记,marked” 为可达的(reachable)。暂停时间一般持续时间较短,相对小的收集暂停时间.</td></tr><tr><td>2、并发标记 (Concurrent Marking)</td><td>在Java应用程序线程运行的同时遍历老年代(tenured generation)的可达对象图。扫描从被标记的对象开始,直到遍历完从root可达的所有对象。调整器(mutators)在并发阶段的2、3、5阶段执行,在这些阶段中新分配的所有对象(包括被提升的对象)都立刻标记为存活状态。</td></tr><tr><td>3、再次标记(Remark)</td><td>(Stop the World Event, 所有应用线程暂停) 查找在并发标记阶段漏过的对象，这些对象是在并发收集器完成对象跟踪之后由应用线程更新的。</td></tr><tr><td>4、并发清理(Concurrent Sweep)</td><td>回收在标记阶段(marking phases)确定为不可及的对象. 死对象的回收将此对象占用的空间增加到一个空闲列表(free list),供以后的分配使用。死对象的合并可能在此时发生. 请注意,存活的对象并没有被移动.</td></tr><tr><td>5、重置(Resetting)</td><td>清理数据结构,为下一个并发收集做准备.</td></tr></tbody></table><p><img src="/images/cms_grabage_clean.png" alt="cms_grabage_clean.png"></p><h3 id="2、CMS的GC步骤"><a href="#2、CMS的GC步骤" class="headerlink" title="2、CMS的GC步骤"></a>2、CMS的GC步骤</h3><h4 id="ensp-1-CMS的堆内存结构-Heap-Structure"><a href="#ensp-1-CMS的堆内存结构-Heap-Structure" class="headerlink" title="&ensp;1). CMS的堆内存结构(Heap Structure)"></a>&ensp;1). CMS的堆内存结构(Heap Structure)</h4><p>&ensp;&ensp;&ensp;堆内存被分为3个空间。年轻代(Young generation)分为 1个新生代空间(Eden)和2个存活区(survivor spaces)，这三个空间默认大小比例是8:1:1。老年代(Old generation)是一大块连续的空间, CMS垃圾回收(Object collection)就地解决(is done in place)垃圾对象, <strong>除了进行Full GC, 否则这个区域不会进行压缩</strong>(compaction).<br><img src="/images/03_1_CMS_Heap_Structure_CN.png" alt="CMS_Heap_Structure_CN.png"></p><h4 id="ensp-2-CMS年轻代-Young-GC的工作方式"><a href="#ensp-2-CMS年轻代-Young-GC的工作方式" class="headerlink" title="&ensp;2). CMS年轻代(Young) GC的工作方式"></a>&ensp;2). CMS年轻代(Young) GC的工作方式</h4><p>&ensp;&ensp;&ensp;年轻代(young generation)用高亮的绿色表示, 老年代(old generation)用蓝色表示。如果程序运行了一段时间,那么 CMS 看起来就像下图这个样子，对象散落在老年代中的各处地方。在使用 CMS 时, 老年代的对象回收就地进行(deallocated in place)。<strong>他们不会被移动到其他地方，除了 Full GC, 否则内存空间不会进行压缩。</strong><br><img src="/images/03_2_How_yong_GC_Works_CN.png" alt="How_yong_GC_Works_CN.png"></p><h4 id="ensp-3-年轻代垃圾回收-Young-Generation-Collection"><a href="#ensp-3-年轻代垃圾回收-Young-Generation-Collection" class="headerlink" title="&ensp;3). 年轻代垃圾回收(Young Generation Collection)"></a>&ensp;3). 年轻代垃圾回收(Young Generation Collection)</h4><p>&ensp;&ensp;&ensp;Eden区和survivor区中的存活对象被拷贝到另一个空的survivor 区。存活时间更长,达到阀值的对象会被提升到老年代(promoted to old generation)。<br><img src="/images/03_3_Yong_Generation_Collection_CN.png" alt="Yong_Generation_Collection_CN.png"></p><h4 id="ensp-4-年轻代-Young-GC-之后"><a href="#ensp-4-年轻代-Young-GC-之后" class="headerlink" title="&ensp;4). 年轻代(Young) GC 之后"></a>&ensp;4). 年轻代(Young) GC 之后</h4><p>&ensp;&ensp;&ensp;年轻代(Young)进行一次垃圾回收之后, Eden 区被清理干净(cleared),两个 survivor 区中的一个也被清理干净了,如下图。图中新提升到老年代的对象用深蓝色来标识。绿色的部分是年轻代中存活的对象,但还没被提升到老年代中。<br><img src="/images/03_4_After_Young_GC_CN.png" alt="After_Young_GC_CN.png"></p><h4 id="ensp-5-CMS的老年代回收-标记-Old-Generation-Collection"><a href="#ensp-5-CMS的老年代回收-标记-Old-Generation-Collection" class="headerlink" title="&ensp;5). CMS的老年代回收-标记(Old Generation Collection)"></a>&ensp;5). CMS的老年代回收-标记(Old Generation Collection)</h4><p>&ensp;&ensp;&ensp;两次stop the world事件发生在: 初始标记(initial mark)以及重新标记(remark)阶段。当老年代达到一定的占有率时,CMS垃圾回收器就开始工作。<br>&ensp;&ensp;&ensp;&ensp;a). 初始标记(Initial mark)阶段的停顿时间很短,在此阶段存活的(live)、可及的(reachable), 对象被记下来.<br>&ensp;&ensp;&ensp;&ensp;b). 并发标记(Concurrent marking)在程序继续运行的同时找出存活的对象。<br>&ensp;&ensp;&ensp;&ensp;c). 在第3阶段(remark phase), 查找在第2阶段(concurrent marking)中错过的对象。<br><img src="/images/03_5_Old_Generation_Collection_in_CMS_CN.png" alt="Old_Generation_Collection_in_CMS_CN.png"></p><h4 id="ensp-6-老年代回收-并发清理-Concurrent-Sweep"><a href="#ensp-6-老年代回收-并发清理-Concurrent-Sweep" class="headerlink" title="&ensp;6). 老年代回收-并发清理(Concurrent Sweep)"></a>&ensp;6). 老年代回收-并发清理(Concurrent Sweep)</h4><p>&ensp;&ensp;&ensp;在前面阶段<strong>未被标记的对象</strong>(Unmarked),即<strong>已死对象</strong>(Dead Objects)将会就地释放(deallocated in place)。此处<strong>没有压缩</strong>(compaction)。<br><img src="/images/03_6_Concurrent_Sweep_CN.png" alt="Concurrent_Sweep_CN.png"></p><h4 id="ensp-7-老年代回收-清理之后-After-Sweeping"><a href="#ensp-7-老年代回收-清理之后-After-Sweeping" class="headerlink" title="&ensp;7). 老年代回收 - 清理之后(After Sweeping)"></a>&ensp;7). 老年代回收 - 清理之后(After Sweeping)</h4><p>&ensp;&ensp;&ensp;在第4步(Sweeping phase)之后, 可以看到很多内存被释放了。还应该注意到,这里并没有执行内存压缩整理(no compaction)。</p><p>&ensp;&ensp;&ensp;最后, CMS 收集器进入第5阶段, 重置(resetting phase), 然后等候下一次的GC阀值到来(GC threshold)。<br><img src="/images/03_7_After_Sweeping_CN.png" alt="After_Sweeping_CN.png"></p><h2 id="四、G1垃圾收集器概述"><a href="#四、G1垃圾收集器概述" class="headerlink" title="四、G1垃圾收集器概述"></a>四、G1垃圾收集器概述</h2><h3 id="1、G1的堆内存结构"><a href="#1、G1的堆内存结构" class="headerlink" title="1、G1的堆内存结构"></a>1、G1的堆内存结构</h3><p>&ensp;&ensp;&ensp;堆内存被划分为固定大小的多个区域。每个heap区(Region)的大小在JVM启动时就确定了。 JVM 通常生成 2000 个左右的heap区, 根据堆内存的总大小,区的size范围允许为 1Mb 到 32Mb。<br><img src="/images/04_1_G1_Heap_Structure_CN.png" alt="G1_Heap_Structure_CN.png"></p><h3 id="2、G1-堆空间分配"><a href="#2、G1-堆空间分配" class="headerlink" title="2、G1 堆空间分配"></a>2、G1 堆空间分配</h3><p>&ensp;&ensp;&ensp;G1的堆内存上一个个区域(regions)被映射为逻辑上的 Eden, Survivor, 和 old generation(老年代)空间。</p><p>&ensp;&ensp;&ensp;图中的颜色标识了每一个区域属于哪个角色。存活的对象从一块区域转移(复制或移动)到另一块区域。设计成 heap 区的目的是为了并行地进行垃圾回收的同时停止/或不停止其他应用程序线程.</p><p>&ensp;&ensp;&ensp;图中heap区可以分配为 Eden, Survivor, 或 old generation(老年代)区。此外,还有第四种类型的对象被称为巨无霸区域(Humongous regions),这种巨无霸区是设计了用来保存比标准块(standard region)大50%及以上的对象, 它们存储在一组连续的区中。最后一个类型是堆内存中的未使用区(unused areas)。<br><img src="/images/02_2_G1HeapAllocation_CN.png" alt="G1HeapAllocation_CN.png"></p><h3 id="3、G1的年轻代收集"><a href="#3、G1的年轻代收集" class="headerlink" title="3、G1的年轻代收集"></a>3、G1的年轻代收集</h3><h4 id="ensp-1-G1中的年轻代-Young-Generation"><a href="#ensp-1-G1中的年轻代-Young-Generation" class="headerlink" title="&ensp;1). G1中的年轻代(Young Generation)"></a>&ensp;1). G1中的年轻代(Young Generation)</h4><p>&ensp;&ensp;&ensp;堆被分为大约2000个区，这些区大小相同。每个区最小size为1 Mb, 最大size为 32Mb。蓝色的区保存老年代对象,绿色区域保存年轻代对象。并且G1中各代的heap区不像老一代垃圾收集器一样要求各部分是连续的。<br><img src="/images/04_3_Young_Generation_in_G1_CN.png" alt="Young_Generation_in_G1_CN.png"></p><h4 id="ensp-2-G1中的一次年轻代GC"><a href="#ensp-2-G1中的一次年轻代GC" class="headerlink" title="&ensp;2). G1中的一次年轻代GC"></a>&ensp;2). G1中的一次年轻代GC</h4><p>&ensp;&ensp;&ensp;存活的对象被转移(copied or moved)到一个或多个存活区(survivor regions)。 如果存活时间达到阀值,这部分对象就会被提升到老年代(promoted to old generation regions)。</p><p>&ensp;&ensp;&ensp;此时会有一次 stop the world(STW)暂停。会计算出 Eden大小和 survivor 大小,给下一次年轻代GC使用。清单统计信息(Accounting)保存了用来辅助计算size。诸如暂停时间目标之类的东西也会纳入考虑。<br>&ensp;&ensp;&ensp;这种方法使得调整各代区域的尺寸很容易, 让其更大或更小一些以满足需要。<br><img src="/images/04_4_A_Young_GC_in_G1_CN.png" alt="A_Young_GC_in_G1_CN.png"></p><h4 id="ensp-3-G1的一次年轻代GC完成后"><a href="#ensp-3-G1的一次年轻代GC完成后" class="headerlink" title="&ensp;3). G1的一次年轻代GC完成后"></a>&ensp;3). G1的一次年轻代GC完成后</h4><p>&ensp;&ensp;&ensp;存活对象被转移到存活区(survivor regions) 或 老年代(old generation regions)。刚刚被提升上来的对象用深绿色显示。Survivor 区用绿色表示。<br><img src="/images/04_5_End_of_Young_GC_with_G1_CN.png" alt="End_of_Young_GC_with_G1_CN.png"></p><h4 id="ensp-4-G1的年轻代收集归纳"><a href="#ensp-4-G1的年轻代收集归纳" class="headerlink" title="&ensp;4). G1的年轻代收集归纳"></a>&ensp;4). G1的年轻代收集归纳</h4><ul><li>堆一整块内存空间,被分为多个heap区(regions)。</li><li>年轻代内存由一组不连续的heap区组成. 这使得在需要时很容易进行容量调整。</li><li>年轻代的垃圾收集,或者叫 young GC, 会有 stop the world 事件。在操作时所有的应用程序线程都会被暂停(stopped)。</li><li>年轻代 GC 通过多线程并行进行。</li><li>存活的对象被拷贝到新的 survivor 区或者老年代。</li><li>G1在已经使用堆内存的大小(Eden,Survivor,old generation,Humongous整体使用内存大小)，大约超过整个堆内存大小的75%的时候会触发Young GC。</li></ul><h3 id="4、G1的老年代收集"><a href="#4、G1的老年代收集" class="headerlink" title="4、G1的老年代收集"></a>4、G1的老年代收集</h3><p>&ensp;&ensp;&ensp;与CMS收集器相似, G1收集器也被设计为用来对老年代的对象进行低延迟(low pause)的垃圾收集。</p><h4 id="ensp-1-G1垃圾收集阶段划分"><a href="#ensp-1-G1垃圾收集阶段划分" class="headerlink" title="&ensp;1). G1垃圾收集阶段划分"></a>&ensp;1). G1垃圾收集阶段划分</h4><p>&ensp;&ensp;&ensp;G1收集器在老年代堆内存中执行下面的这些阶段。 注意有些阶段也是年轻代垃圾收集的一部分。</p><table><thead><tr><th>操作阶段</th><th>主要操作</th></tr></thead><tbody><tr><td>1、初始标记 (Initial Mark)</td><td>(Stop the World Event,所有应用线程暂停) 此时会有一次 stop the world(STW)暂停事件. 在G1中, 这附加在(piggybacked on)一次正常的年轻代GC. 标记可能有引用指向老年代对象的survivor区(根regions).</td></tr><tr><td>2、扫描根区域(Root Region Scanning)</td><td>扫描 survivor 区中引用到老年代的引用。这个阶段应用程序的线程会继续运行。在年轻代GC可能发生之前此阶段必须完成。</td></tr><tr><td>3、并发标记(Concurrent Marking)</td><td>在整个堆中查找活着的对象。此阶段应用程序的线程正在运行。此阶段可以被年轻代GC打断(interrupted).</td></tr><tr><td>4、再次标记(Remark)</td><td>(Stop the World Event,所有应用线程暂停) 完成堆内存中存活对象的标记。使用一个叫做 snapshot-at-the-beginning(SATB, 起始快照)的算法, 该算法比CMS所使用的算法要快速的多。</td></tr><tr><td>5、清理(Cleanup)</td><td>(Stop the World,所有应用线程暂停,清理线程并发执行)在存活对象和完全空闲的区域上执行统计(accounting)。(Stop the world)擦写 Remembered Sets。(Stop the world)重置空heap区并将他们返还给空闲列表(free list)。</td></tr><tr><td>6、拷贝(Copying)</td><td>(Stop the World,所有应用线程暂停) 转移或拷贝存活的对象到新的未使用的heap区(new unused regions)。只在年轻代发生时日志会记录为 <code>[GC pause (young)]</code>。如果在年轻代和老年代一起执行则会被日志记录为 <code>[GC Pause (mixed)]</code>。</td></tr></tbody></table><p><img src="/images/g1_grabage_clean.png" alt="g1_grabage_clean.png"></p><h4 id="ensp-2-G1老年代收集步骤"><a href="#ensp-2-G1老年代收集步骤" class="headerlink" title="&ensp;2). G1老年代收集步骤"></a>&ensp;2). G1老年代收集步骤</h4><h5 id="ensp-ensp-a-初始标记阶段-Initial-Marking-Phase"><a href="#ensp-ensp-a-初始标记阶段-Initial-Marking-Phase" class="headerlink" title="&ensp;&ensp;a). 初始标记阶段(Initial Marking Phase)"></a>&ensp;&ensp;a). 初始标记阶段(Initial Marking Phase)</h5><p>&ensp;&ensp;&ensp;存活对象的初始标记被固定在年轻代垃圾收集里面。 在日志中被记为 GC pause (young)(inital-mark)。<br><img src="/images/04_6_Initial_Marking_Phase_CN.png" alt="Initial_Marking_Phase_CN.png"></p><h5 id="ensp-ensp-b-并发标记阶段-Concurrent-Marking-Phase"><a href="#ensp-ensp-b-并发标记阶段-Concurrent-Marking-Phase" class="headerlink" title="&ensp;&ensp;b). 并发标记阶段(Concurrent Marking Phase)"></a>&ensp;&ensp;b). 并发标记阶段(Concurrent Marking Phase)</h5><p>&ensp;&ensp;&ensp;如果找到空的区域(如用红叉“X”标示的区域), 则会在 Remark 阶段立即移除。 当然,”清单(accounting)”信息决定了活跃度(liveness)的计算。<br><img src="/images/04_7_Concurrent_Marking_Phase_CN.png" alt="Concurrent_Marking_Phase_CN.png"></p><h5 id="ensp-ensp-c-再次标记阶段-Remark-Phase"><a href="#ensp-ensp-c-再次标记阶段-Remark-Phase" class="headerlink" title="&ensp;&ensp;c). 再次标记阶段(Remark Phase)"></a>&ensp;&ensp;c). 再次标记阶段(Remark Phase)</h5><p>&ensp;&ensp;&ensp;空的区域被移除并回收。现在计算所有区域的活跃度(Region liveness)。<br><img src="/images/04_8_Remark_Phase_CN.png" alt="Remark_Phase_CN.png"></p><h5 id="ensp-ensp-d-拷贝-清理阶段-Copying-Cleanup"><a href="#ensp-ensp-d-拷贝-清理阶段-Copying-Cleanup" class="headerlink" title="&ensp;&ensp;d). 拷贝/清理阶段(Copying/Cleanup)"></a>&ensp;&ensp;d). 拷贝/清理阶段(Copying/Cleanup)</h5><p>&ensp;&ensp;&ensp;G1选择“活跃度(liveness)”最低的区域, 这些区域可以最快的完成回收。然后这些区域和年轻代GC在同时被垃圾收集，在日志被标识为 [GC pause (mixed)]。 所以年轻代和老年代都在同一时间被垃圾收集。<br><img src="/images/04_9_Copying_Cleanup_Phase_CN.png" alt="Copying_Cleanup_Phase_CN.png"></p><h5 id="ensp-ensp-e-拷贝-清理之后-After-Copying-Cleanup"><a href="#ensp-ensp-e-拷贝-清理之后-After-Copying-Cleanup" class="headerlink" title="&ensp;&ensp;e). 拷贝/清理之后(After Copying/Cleanup)"></a>&ensp;&ensp;e). 拷贝/清理之后(After Copying/Cleanup)</h5><p>&ensp;&ensp;&ensp;所选择的区域被收集和压缩到下图所示的深蓝色区域和深绿色区域。<br><img src="/images/04_10_After_Copying_Cleanup_Phase_CN.png" alt="After_Copying_Cleanup_Phase_CN.png"></p><h4 id="ensp-3-G1的老年代收集归纳"><a href="#ensp-3-G1的老年代收集归纳" class="headerlink" title="&ensp;3). G1的老年代收集归纳"></a>&ensp;3). G1的老年代收集归纳</h4><ul><li>并发标记阶段(Concurrent Marking Phase)<ul><li>活跃度信息在程序运行的时候被并行计算出来。</li><li>活跃度(liveness)信息标识出哪些区域在转移暂停期间最适合回收.</li></ul></li><li>再次标记阶段(Remark Phase)<ul><li>使用的 Snapshot-at-the-Beginning (SATB, 开始快照) 算法比起 CMS所用的算法要快得多。</li><li>完全空的区域直接被回收。</li></ul></li><li>拷贝/清理阶段(Copying/Cleanup Phase)<ul><li>年轻代与老年代同时进行回收。</li><li>老年代的选择基于其活跃度(liveness)。</li></ul></li></ul><h2 id="五、G1命令行参数"><a href="#五、G1命令行参数" class="headerlink" title="五、G1命令行参数"></a>五、G1命令行参数</h2><h2 id="六、G1的GC日志分析"><a href="#六、G1的GC日志分析" class="headerlink" title="六、G1的GC日志分析"></a>六、G1的GC日志分析</h2><h5 id="相关参考资源："><a href="#相关参考资源：" class="headerlink" title="相关参考资源："></a>相关参考资源：</h5><p><a href="https://blog.csdn.net/renfufei/article/details/41897113" target="_blank" rel="noopener">G1垃圾收集器入门</a><br><a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" target="_blank" rel="noopener">Getting Started with the G1 Garbage Collector</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;本文主要通过对比G1(Garbage-Firs Collector)和CMS(Concurrent Mark-Sweep Collector)垃圾收集器的堆内存结构，以及具体垃圾收集过程，每个过程中是怎么扫描虚拟机堆，来阐述G1垃圾收集器的原理和具体优势。&lt;/p&gt;
&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;G1是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器。以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征. 在Oracle JDK 7 update 4 及以上版本中得到完全支持, 专为以下应用程序设计:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以像CMS收集器一样,GC操作与应用的线程一起并发执行。&lt;/li&gt;
&lt;li&gt;紧凑的空闲内存区间且没有很长的GC停顿时间。&lt;/li&gt;
&lt;li&gt;需要可预测的GC暂停耗时。&lt;/li&gt;
&lt;li&gt;不想牺牲太多吞吐量性能。&lt;/li&gt;
&lt;li&gt;启动后不需要请求更大的Java堆。
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM—GC 相关参数总结</title>
    <link href="http://yoursite.com/2018/09/02/Java/jvm/2018-09-02-jvm%E2%80%94gc-%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/09/02/Java/jvm/2018-09-02-jvm—gc-相关参数总结/</id>
    <published>2018-09-02T15:35:00.000Z</published>
    <updated>2018-09-02T15:40:22.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-与串行回收器相关的参数"><a href="#1-与串行回收器相关的参数" class="headerlink" title="1. 与串行回收器相关的参数"></a>1. 与串行回收器相关的参数</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:+UseSerialGC</strong>   :&nbsp;&nbsp;&nbsp;在新生代和老年代使用串行回收器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:+SuivivorRatio</strong>  :&nbsp;&nbsp;&nbsp;设置 eden 区大小和 survivor 区大小的比例。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:+PretenureSizeThreshold</strong>         :&nbsp;&nbsp;&nbsp;设置大对象直接进入老年代的阈值。当对象的大小超过这个值时，将直接在老年代分配。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:MaxTenuringThreshold</strong>  :&nbsp;&nbsp;&nbsp;设置对象进入老年代的年龄的最大值。每一次 Minor GC 后，对象年龄就加 1。任何大于这个年龄的对象，一定会进入老年代。</p><a id="more"></a><h2 id="2-与并行-GC-相关的参数"><a href="#2-与并行-GC-相关的参数" class="headerlink" title="2. 与并行 GC 相关的参数"></a>2. 与并行 GC 相关的参数</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:+UseParNewGC</strong>   : &nbsp;&nbsp;&nbsp;在新生代使用并行收集器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:+UseParallelOldGC</strong>   : &nbsp;&nbsp;&nbsp;老年代使用并行回收收集器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:ParallelGCThreads</strong>    ：设置用于垃圾回收的线程数。通常情况下可以和 CPU 数量相等。但在 CPU 数量比较多的情况下，设置相对较小的数值也是合理的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:MaxGCPauseMills</strong>   ：设置最大垃圾收集停顿时间。它的值是一个大于 0 的整数。收集器在工作时，会调整 Java 堆大小或者其他一些参数，尽可能地把停顿时间控制在 MaxGCPauseMills 以内。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:GCTimeRatio</strong>   :&nbsp;&nbsp;&nbsp;设置吞吐量大小，它的值是一个 0-100 之间的整数。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:+UseAdaptiveSizePolicy</strong>   :&nbsp;&nbsp;&nbsp;打开自适应 GC 策略。在这种模式下，新生代的大小，eden 和 survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。</p><h2 id="3-与-CMS-回收器相关的参数"><a href="#3-与-CMS-回收器相关的参数" class="headerlink" title="3. 与 CMS 回收器相关的参数"></a>3. 与 CMS 回收器相关的参数</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:+UseConcMarkSweepGC</strong>   :&nbsp;&nbsp;&nbsp; 新生代使用并行收集器，老年代使用 CMS+串行收集器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:+ParallelCMSThreads</strong>   : &nbsp;&nbsp;&nbsp;设定 CMS 的线程数量。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:+CMSInitiatingOccupancyFraction</strong>   :&nbsp;&nbsp;&nbsp;设置 CMS 收集器在老年代空间被使用多少后触发，默认为 68% (JDK 1.6中提升至92%)。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:+UseFullGCsBeforeCompaction</strong>   :&nbsp;&nbsp;&nbsp;设定进行多少次 CMS 垃圾回收后，进行一次内存压缩。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:+CMSClassUnloadingEnabled</strong>   :&nbsp;&nbsp;&nbsp;允许对类元数据进行回收。？？？？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:+CMSParallelRemarkEndable</strong>   :&nbsp;&nbsp;&nbsp;启用并行重标记。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:CMSInitatingPermOccupancyFraction</strong>   :当永久区占用率达到这一百分比后，启动 CMS 回收 (前提是-XX:+CMSClassUnloadingEnabled 激活了)。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:UseCMSInitatingOccupancyOnly</strong>   :表示只在到达阈值的时候，才进行 CMS 回收。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:+CMSIncrementalMode</strong>   :&nbsp;&nbsp;&nbsp;使用增量模式，比较适合单 CPU。</p><h2 id="4-与-G1-回收器相关的参数"><a href="#4-与-G1-回收器相关的参数" class="headerlink" title="4. 与 G1 回收器相关的参数"></a>4. 与 G1 回收器相关的参数</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:+UseG1GC</strong>   ：&nbsp;&nbsp;&nbsp;使用 G1 回收器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:+UnlockExperimentalVMOptions</strong>   :允许使用实验性参数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:+MaxGCPauseMills</strong>   :&nbsp;&nbsp;&nbsp;设置最大垃圾收集停顿时间。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:+GCPauseIntervalMills</strong>   :&nbsp;&nbsp;&nbsp;设置停顿间隔时间。</p><h2 id="5-其他参数"><a href="#5-其他参数" class="headerlink" title="5. 其他参数"></a>5. 其他参数</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>-XX:+DisableExplicitGC</strong>   : &nbsp;&nbsp;&nbsp;禁用显示 GC。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-与串行回收器相关的参数&quot;&gt;&lt;a href=&quot;#1-与串行回收器相关的参数&quot; class=&quot;headerlink&quot; title=&quot;1. 与串行回收器相关的参数&quot;&gt;&lt;/a&gt;1. 与串行回收器相关的参数&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;-XX:+UseSerialGC&lt;/strong&gt;   :&amp;nbsp;&amp;nbsp;&amp;nbsp;在新生代和老年代使用串行回收器。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;-XX:+SuivivorRatio&lt;/strong&gt;  :&amp;nbsp;&amp;nbsp;&amp;nbsp;设置 eden 区大小和 survivor 区大小的比例。&lt;/p&gt;
&lt;p&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;-XX:+PretenureSizeThreshold&lt;/strong&gt;         :&amp;nbsp;&amp;nbsp;&amp;nbsp;设置大对象直接进入老年代的阈值。当对象的大小超过这个值时，将直接在老年代分配。&lt;/p&gt;
&lt;p&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;-XX:MaxTenuringThreshold&lt;/strong&gt;  :&amp;nbsp;&amp;nbsp;&amp;nbsp;设置对象进入老年代的年龄的最大值。每一次 Minor GC 后，对象年龄就加 1。任何大于这个年龄的对象，一定会进入老年代。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM—垃圾收集器</title>
    <link href="http://yoursite.com/2018/09/02/Java/jvm/2018-09-02-jvm%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://yoursite.com/2018/09/02/Java/jvm/2018-09-02-jvm—垃圾收集器/</id>
    <published>2018-09-02T15:17:00.000Z</published>
    <updated>2018-09-09T13:45:37.887Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<img src="https://raw.githubusercontent.com/changwensir/study_document/master/upload_img/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="image"></p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;上图展示了7种作用于不同分代的收集器（包括JDK 1.7_Update14之后正式提供商用的G1收集器），如果两个收集器之间存在连线，就说明它们可以搭配使用。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;在介绍这些收集器各自的特性之前，我们先来明确一个观点：虽然我们是在对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。因为直到现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器。这点不需要多加解释就能证明：如果有一种放之四海皆准、任何场景下都适用的完美收集器存在，那HotSpot虚拟机就没必要实现那么多不同的收集器了。</p><a id="more"></a><hr><h3 id="新生代收集器："><a href="#新生代收集器：" class="headerlink" title="新生代收集器："></a>新生代收集器：</h3><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>1. Serial 收集器</strong><br>&nbsp; &nbsp;&nbsp;&nbsp;<strong>2. ParNew 收集器</strong><br>&nbsp; &nbsp;&nbsp;&nbsp;<strong>3. Parallel Scavenge 收集器</strong><br><br><br><br></p><h3 id="nbsp-nbsp-nbsp-1、Serial-收集器"><a href="#nbsp-nbsp-nbsp-1、Serial-收集器" class="headerlink" title="&nbsp; &nbsp;&nbsp;1、Serial 收集器"></a>&nbsp; &nbsp;&nbsp;1、Serial 收集器</h3><hr><p>&nbsp; &nbsp;&nbsp;&nbsp;最基本、发展历史最悠久的收集器。<br><br>&nbsp; &nbsp;&nbsp;&nbsp;<strong>适用：</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;看上去没什么用，但实际上到现在为止，它依然是虚拟机运行在Client模式下的默认新生代收集器。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>特点:</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;1).单线程的收集器，说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;2).在它进行垃圾收集时，必须暂停其他所有的工作线程（Sun将这件事情称之为“Stop The World”）,直到它收集结束。这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户的正常工作的线程全部停掉，这对很多应用来说都是难以接受的。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>收集算法：</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;采用复制算法</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>优点:</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>缺点:</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;GC时暂停线程带给用户不良体验</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>搭配使用的收集器：</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;CMS 或Serial Old(MSC)</p><p><img src="https://img-blog.csdn.net/20161221144138060?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDU1ODY2MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p><hr><h3 id="nbsp-nbsp-nbsp-2、ParNew收集器"><a href="#nbsp-nbsp-nbsp-2、ParNew收集器" class="headerlink" title="&nbsp; &nbsp;&nbsp;2、ParNew收集器"></a>&nbsp; &nbsp;&nbsp;2、ParNew收集器</h3><hr><p>&nbsp; &nbsp;&nbsp;&nbsp;ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为都与Serial收集器完全一样，实现上这两种收集器也共用了相当多的代码。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>适用：</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;运行在Server模式下的虚拟机中的新生代。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>特点:</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;1.多线程GC(并行):ParNew是Serial的多线程版本，两者共用了许多代码。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;2.在GC时暂停所有用户线程。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>算法：</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;采用复制算法。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>优点:</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;高效。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>缺点:</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;GC时暂停线程带给用户不良体验,单线程下效果不一定优于Serial。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>搭配使用的收集器：</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;CMS 或Serial Old(MSC)。</p><p><img src="https://img-blog.csdn.net/20161221144147142?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDU1ODY2MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p><p>　　<br>&nbsp;&nbsp;&nbsp;&nbsp;ParNew收集器有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。在JDK 1.5以后使用CMS来收集老年代的时候，新生代只能选择ParNew或Serial收集器中的一个。</p><hr><h3 id="nbsp-nbsp-nbsp-3、Parallel-Scavenge收集器"><a href="#nbsp-nbsp-nbsp-3、Parallel-Scavenge收集器" class="headerlink" title="&nbsp; &nbsp;&nbsp;3、Parallel Scavenge收集器"></a>&nbsp; &nbsp;&nbsp;3、Parallel Scavenge收集器</h3><hr><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>适用：</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;新生代收集器，在后台运算而不需要太多交互的任务。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>特点:</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;1.多线程GC(并行)。<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;2.在GC时暂停所有用户线程。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>算法：</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;采用复制算法</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>优点:</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;高效</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>搭配使用的收集器：</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;Parallel Old或Serial Old(MSC)</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>与其他收集器的不同:</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;1.ParNew,CMS等收集器的关注点在于尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。<strong>【吞吐量：运行代码时间/（运行用户代码时间+垃圾收集时间）】</strong></p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;2.停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;3.Parallel Scavenge可采用GC自适应的调节策略(这是与另外两一个重要的区别）。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>相关参数设置，用于精确控制吞吐量：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:MaxGCPauseMillis &nbsp;&nbsp;&nbsp;&nbsp;最大垃圾收集停顿时间<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-XX:GCTimeRatio &nbsp;&nbsp;&nbsp;&nbsp;垃圾收集时间与运行用户代码时间的比例=垃圾收集时间/运行用户代码时间,相当于是吞吐量的倒数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>实现：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;降低GC停顿时间：牺牲吞吐量和新生代空间(减小新生代空间，GC频率变大，吞吐量降低)</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>GC自适应的调节策略:</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;-XX:+UseAdaptiveSizePolicy&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 使用自适应的调节策略 即不需要指定新生代的大小，Eden与Surivior的比例，晋升老年代的年龄等细节参数，虚拟机自动根据根据当前系统的状态动态调整这些参数以提供最合适的停顿时间或最大的吞吐量。</p><hr><h3 id="老年代收集器："><a href="#老年代收集器：" class="headerlink" title="老年代收集器："></a>老年代收集器：</h3><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>1. Serial Old 收集器</strong><br>&nbsp; &nbsp;&nbsp;&nbsp;<strong>2. Parallel Old 收集器</strong><br>&nbsp; &nbsp;&nbsp;&nbsp;<strong>3. CMS 收集器</strong><br><br><br><br></p><h3 id="nbsp-nbsp-nbsp-1-Serial-Old-收集器"><a href="#nbsp-nbsp-nbsp-1-Serial-Old-收集器" class="headerlink" title="&nbsp; &nbsp;&nbsp;1. Serial Old 收集器"></a>&nbsp; &nbsp;&nbsp;1. Serial Old 收集器</h3><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>适用：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;1.运行在Client模式下的虚拟机中的老年代。</p><p>　　<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.在Server模式下，它主要还有两大用途。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;1).与Parallel Scavenge搭配。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;2).作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>特点:</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;1.单线程GC，Serial收集器的老年代版本。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;2.在GC时暂停所有用户线程。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>算法：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;采用标记-整理算法</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>优点：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;简单，高效</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>缺点：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;GC时暂停线程带给用户不良体验</p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>搭配使用的收集器：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;Serial Old(MSC)或ParNew</p><hr><h3 id="nbsp-nbsp-nbsp-2-Parallel-Old-收集器"><a href="#nbsp-nbsp-nbsp-2-Parallel-Old-收集器" class="headerlink" title="&nbsp; &nbsp;&nbsp;2. Parallel Old 收集器"></a>&nbsp; &nbsp;&nbsp;2. Parallel Old 收集器</h3><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>适用：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行在Server模式下，注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>特点：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1).多线程GC(并行):Parallel Scavenge的老年代版本。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2).在GC时暂停所有用户线程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3).这个收集器是在JDK 1.6中才开始提供。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>算法：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用标记-整理算法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>优点：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;高效</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>缺点：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GC时暂停线程带给用户不良体验,单线程下效果不一定优于Serial。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>搭配使用的收集器：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parallel Scavenge</p><p><img src="https://img-blog.csdn.net/20161221144209592?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDU1ODY2MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p><hr><h3 id="nbsp-nbsp-nbsp-3-CMS-Concurrent-Mark-Sweep-收集器"><a href="#nbsp-nbsp-nbsp-3-CMS-Concurrent-Mark-Sweep-收集器" class="headerlink" title="&nbsp; &nbsp;&nbsp;3. CMS(Concurrent Mark Sweep) 收集器"></a>&nbsp; &nbsp;&nbsp;3. CMS(Concurrent Mark Sweep) 收集器</h3><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>适用：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行在Server模式下的虚拟机中的老年代，适合对响应时间要求高的应用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>算法：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用“标记-清除”算法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>特点:</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多线程、与用户工作线程并发</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>过程:</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.初始标记：暂停用户线程，标记GC Roots能直接关联的对象,速度很快。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.并发标记：用户线程与标记线程并发，进行GC Roots Tracing的过程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.重新标记：为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.并发清除：用户线程与清除线程并发。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。</strong></p><p>　　<br>&nbsp;&nbsp;&nbsp;&nbsp;下图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间。</p><p><img src="https://github.com/changwensir/study_document/raw/master/upload_img/JVM/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="image"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>优点:</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并发收集、低停顿，由于耗时最长的并发标记和并发清除阶段都与用户线程并行工作，故系统停顿时间极短。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>缺点:</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. <strong>对CPU资源非常敏感</strong>。<br><br>　　<strong>原因</strong>：面向并发设计的程序都对CPU资源比较敏感。并发时，因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低，应用程序会变慢，当CPU数不足时，尤其明显。<br><br>　　<strong>解决</strong>：增量式并发收集器（i-CMS）：在并发标记、清除时让GC线程与用户线程交替运行，以降低GC线程独占CPU的时间。当GC时间将变长时，效果一般，被丢弃使用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. <strong>无法处理浮动垃圾,可能出现“Concurrent Mode “Failure”失败而导致另一次Full GC的产生</strong>。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>浮动垃圾</strong>：在并发清除阶段，用户线程仍在运行，此时产生的垃圾无法在该次收集中处理。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时由于要保证并发，就必须预留内存给用户线程使用，因此CMS无法等到老年代几乎完全填满时再进行收集。JDK 1.5中CMS默认当老年代被使用68%时被激发。1.6中为92%。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode “Failure”失败，这时虚拟机将启动后备预案：临时使用Serial Old收集器来重新进行老年代垃圾收集，这样停顿时间就会很长。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. <strong>产生空间碎片，影响大对象的分配。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于该收集器是由“标记-清除”算法实现的所引起的。所以往往存在有很大空间剩余，当无法找到足够大的连续空间来分配当前对象，不得不提前出发一次Full GC。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>解决：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.-XX:+UseCMSCompactFullCollection 开关参数（默认开启）用于当CMS要进行<strong>Full GC时开启内存碎片的合并整理过程</strong>,该过程不能并发，故停顿==时间变长==。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.-XX:CMSFullGCsBeforeCompaction 用于设置<strong>执行多少次不压缩的Full GC后跟着来一次带压缩的Full GC</strong>。默认为0，表示每次进入Full GC时都进行碎片整理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>搭配使用的收集器</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Serial或ParNew</p><hr><h3 id="新生代和老年代均适用集器："><a href="#新生代和老年代均适用集器：" class="headerlink" title="新生代和老年代均适用集器："></a>新生代和老年代均适用集器：</h3><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>1. G1 收集器</strong><br><br><br><br></p><h3 id="nbsp-nbsp-nbsp-1-G1-收集器-未来垃圾收集器的趋势，需好好了解"><a href="#nbsp-nbsp-nbsp-1-G1-收集器-未来垃圾收集器的趋势，需好好了解" class="headerlink" title="&nbsp; &nbsp;&nbsp;1. G1 收集器(未来垃圾收集器的趋势，需好好了解)"></a>&nbsp; &nbsp;&nbsp;1. G1 收集器(未来垃圾收集器的趋势，需好好了解)</h3><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>适用：</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;面向服务端应用，适用于新生代和老年代。当前收集器技术发展的最前沿成果</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>内存布局：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G1的堆内存布局与其他收集器不同，G1将整个堆内存空间划分为多个大小相等的Region(2-32M 大小，可以参数指定)，虽然仍然有新生代和老年代的概念，但是新生代和老年代不再是物理隔离的，他们都是一部分Region（不需要连续）的集合。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>特点:</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>1.并行与并发</strong>，可充分利用CPU资源。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>2.分代收集。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>3.空间整合</strong>， G1从整体看是”标记-整理“算法，从局部(两个Region之间)看，是”复制“算法。 不会产生空间碎片。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>4.可预测的停顿</strong>，建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间内，消耗在垃圾收集的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。　　</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Garbage First名称的由来：</strong><br><br>　　G1收集器可以实现在基本不牺牲吞吐量的前提下完成低停顿的内存回收，这是由于它能够极力地避免全区域的垃圾收集。G1将内存划分为Region，跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>难点:</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然内存分为Region，但垃圾收集不能真的以Region为单位进行，因为Region不可能是孤立的，存在某个对象被多个Region的引用，那在做可达性判断确定对象是否存活时，是否需要扫描整个堆空间呢？注意：此问题在所有的收集器中都存在（如存在新生代与老年代之间的引用）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>解决：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用Remembered Set来避免全堆扫描。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>优化的Region扫描过程：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断操作，检查Reference类型引用的对象是否处于不同的Region（在分代的例子中就是检查是否老年代的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>垃圾收集过程(与CMS相似)：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.初始标记:暂停用户线程，标记GC Roots能直接关联的对象。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.并发标记:用户线程与标记线程并发，进行GC Roots的Trace。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.最终标记修正并发标记阶段，因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.筛选回收:最后筛选回收阶段，首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，进而进行垃圾回收。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>算法：</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;全局标记-整理+局部复制算法</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>优点:</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;高效，停顿时间可控、可预测</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。&lt;/p&gt;
&lt;p&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;img src=&quot;https://raw.githubusercontent.com/changwensir/study_document/master/upload_img/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;上图展示了7种作用于不同分代的收集器（包括JDK 1.7_Update14之后正式提供商用的G1收集器），如果两个收集器之间存在连线，就说明它们可以搭配使用。&lt;/p&gt;
&lt;p&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在介绍这些收集器各自的特性之前，我们先来明确一个观点：虽然我们是在对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。因为直到现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器。这点不需要多加解释就能证明：如果有一种放之四海皆准、任何场景下都适用的完美收集器存在，那HotSpot虚拟机就没必要实现那么多不同的收集器了。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM—垃圾收集算法</title>
    <link href="http://yoursite.com/2018/09/02/Java/jvm/JVM%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/09/02/Java/jvm/JVM—垃圾收集算法/</id>
    <published>2018-09-02T15:12:00.000Z</published>
    <updated>2018-09-09T13:45:37.887Z</updated>
    
    <content type="html"><![CDATA[<h3 id="nbsp-nbsp-nbsp-1、标记-清除算法-Mark-Sweep"><a href="#nbsp-nbsp-nbsp-1、标记-清除算法-Mark-Sweep" class="headerlink" title="&nbsp; &nbsp;&nbsp;1、标记-清除算法(Mark-Sweep)"></a>&nbsp; &nbsp;&nbsp;1、标记-清除算法(Mark-Sweep)</h3><hr><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;最基础的收集算法，之所以这么说，是因为下面的其它算法都是基于这种思路并对其不足进行改进而得到的。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<strong>原理：分为标记-清除两个阶段</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.标记阶段：首先标记出所有需要回收的对象。<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.清除阶段：标记完成后，统一回收被标记的对象<br><a id="more"></a><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<strong>缺点：</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.效率问题：标记和清除过程效率都不高。<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.空间问题：标记清除之后会产生大量的不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续的内存空间而不得不提前触发另一次垃圾收集动作。<br></p><p><img src="/images/Mark-Sweep.png" alt="Mark-Sweep.png"></p><hr><h3 id="nbsp-nbsp-nbsp-2、复制算法-Copying"><a href="#nbsp-nbsp-nbsp-2、复制算法-Copying" class="headerlink" title="&nbsp; &nbsp;&nbsp;2、复制算法(Copying)"></a>&nbsp; &nbsp;&nbsp;2、复制算法(Copying)</h3><hr><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;为了解决上面所提到的标记清楚算法的效率问题，而出现了复制算法。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<strong>原理：</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.将现有的内存空间分为两快，每次只使用其中一块。<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.当其中一块内存用完的时候，就将还存活的对象复制到另外一块上去。<br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.再把已使用过的内存空间一次清理掉。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<strong>优点：</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.由于是每次都对整个半区进行内存回收，内存分配时不必考虑内存碎片问题。<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。<br></p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<strong>缺点：</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.内存减少为原来的一半，太浪费了。<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.对象存活率较高的时候就要执行较多的复制操作，效率变低。<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.如果不使用50%的对分策略，老年代需要考虑的空间担保策略。<br></p><p><img src="/images/Copying.png" alt="Copying.png"></p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<strong>内存划分优化：</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存的划分并不需要根据1:1划分内存空间，而是将内存划分为一块较大的EdenSpace和两块较小的SurvivorSpace。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaHeap内存回收模型（当前商业虚拟机大多使用此算法回收新生代）</p><p><img src="/images/Copy-algorithm.png" alt="Copy-algorithm"></p><p><img src="/images/eden-survivor.png" alt="eden-survivor"></p><hr><h3 id="nbsp-nbsp-nbsp-3、标记整理算法-Mark-Compact"><a href="#nbsp-nbsp-nbsp-3、标记整理算法-Mark-Compact" class="headerlink" title="&nbsp; &nbsp;&nbsp;3、标记整理算法(Mark-Compact)"></a>&nbsp; &nbsp;&nbsp;3、标记整理算法(Mark-Compact)</h3><hr><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;由于复制算法的缺点，以及老年代的特点（<strong>存活率高，没有额外内存对其进行空间担保</strong>），老年代一般不使用复制算法。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<strong>原理：</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.标记阶段：首先标记出所有需要回收的对象，与“标记-清除”一样。<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.让存活的对象向内存的一端移动。而不像“标记-清除”算法那样直接对可回收对象进行清理。<br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.再直接清理掉端边界以外的内存。</p><p><img src="/images/Mark-Compact.png" alt="Mark-Compact"></p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;由于老年代存活率高，没有额外内存对老年代进行空间担保，那么老年代只能采用标记-清理算法或者标记整理算法。　</p><hr><h3 id="nbsp-nbsp-nbsp-4、分代收集算法-Generational-Collecting"><a href="#nbsp-nbsp-nbsp-4、分代收集算法-Generational-Collecting" class="headerlink" title="&nbsp; &nbsp;&nbsp;4、分代收集算法(Generational Collecting)"></a>&nbsp; &nbsp;&nbsp;4、分代收集算法(Generational Collecting)</h3><hr><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当前的商业虚拟机的垃圾收集都采用分代收集算法，把Java堆分为新生代和老年代。根据各个年代的特点采用最适当的收集算法。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，选用：复制算法</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清除”或者“标记-整理”算法来进行回收。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;nbsp-nbsp-nbsp-1、标记-清除算法-Mark-Sweep&quot;&gt;&lt;a href=&quot;#nbsp-nbsp-nbsp-1、标记-清除算法-Mark-Sweep&quot; class=&quot;headerlink&quot; title=&quot;&amp;nbsp; &amp;nbsp;&amp;nbsp;1、标记-清除算法(Mark-Sweep)&quot;&gt;&lt;/a&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;1、标记-清除算法(Mark-Sweep)&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;最基础的收集算法，之所以这么说，是因为下面的其它算法都是基于这种思路并对其不足进行改进而得到的。&lt;/p&gt;
&lt;p&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;原理：分为标记-清除两个阶段&lt;/strong&gt;&lt;br&gt;&lt;br&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.标记阶段：首先标记出所有需要回收的对象。&lt;br&gt;&lt;br&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2.清除阶段：标记完成后，统一回收被标记的对象&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM—对象存活判定算法</title>
    <link href="http://yoursite.com/2018/09/02/Java/jvm/JVM%E2%80%94%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/09/02/Java/jvm/JVM—对象存活判定算法/</id>
    <published>2018-09-02T14:39:00.000Z</published>
    <updated>2018-09-02T15:39:50.224Z</updated>
    
    <content type="html"><![CDATA[<h3 id="nbsp-nbsp-nbsp-1、引用计数算法"><a href="#nbsp-nbsp-nbsp-1、引用计数算法" class="headerlink" title="&nbsp; &nbsp;&nbsp;1、引用计数算法"></a>&nbsp; &nbsp;&nbsp;1、引用计数算法</h3><hr><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;引用计数算法就是对于创建的每一个对象都有一个与之关联的计数器，这个计数器记录着该对象被使用的次数，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器减1；任何时刻计数器都为0的对象就是不可能再被使用的，垃圾收集器在进行垃圾回收时，对扫描到的每一个对象判断一下计数器是否等于0，若等于0，就会释放该对象占用的内存空间,同时将该对象引用的其他对象的计数器进行减一操作。</p><a id="more"></a><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;引用计数算法的垃圾收集一般有侵入式与非侵入式两种，侵入式的实现就是将引用计数器直接根植在对象内部，用C++的思想进行解释就是，在对象的构造或者拷贝构造中进行加一操作，在对象的析构中进行减一操作，非侵入式思想就是有一块单独的内存区域，用作引用计数器。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;算法的优点：引用计数算法的实现简单，判断效率也很高，使用引用计数器,内存回收可以穿插在程序的运行中，在程序运行中，当发现某一对象的引用计数器为0时，可以立即对该对象所占用的内存空间进行回收，这种方式可以避免FULL GC时带来的程序暂停。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;算法的缺点：采用引用计数器进行垃圾回收，最大的缺点就是不能解决<strong>循环引用</strong>的问题，例如一个象(A Object)持有另外一个对象(B Object)的引用，t同时B对象也持有A对象的引用，这种情况下，两个对象实例将一直存在于JVM的堆中，无法进行回收,代码示例如下(引用计数器无法对a与b对象进行回收):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    private B b;</span><br><span class="line">    public B getB() &#123;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setB(B b) &#123;</span><br><span class="line">        this.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">    private A a;</span><br><span class="line">    public A getA() &#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setA(A a) &#123;</span><br><span class="line">        this.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A a = new A();</span><br><span class="line">        B b = new B();</span><br><span class="line">        a.setB(b);</span><br><span class="line">        b.setA(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;Java语言中没有选用引用计数算法来管理内存，其中最主要的一个原因也是它很难解决<strong>对象之间相互循环引用的问题</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 在testGC()方法中，对象objA和objB都有字段instance，</span><br><span class="line">* 赋值令objA.instance=objB及objB.instance=objA，</span><br><span class="line">* 除此之外这两个对象再无任何引用，</span><br><span class="line">* 实际上这两个对象都已经不能再被访问，</span><br><span class="line">* 但是它们因为相互引用着对象方，</span><br><span class="line">* 导致它们的引用计数都不为0，</span><br><span class="line">* 于是引用计数算法无法通知GC收集器回收它们。</span><br><span class="line">*/  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 执行后，objA和objB会不会被GC呢？</span><br><span class="line"> */</span><br><span class="line">public class ReferenceCountingGC &#123;</span><br><span class="line">    public Object instance = null;</span><br><span class="line">    private static final int _1MB = 1024 * 1024;</span><br><span class="line">    /**</span><br><span class="line">     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过</span><br><span class="line">     */</span><br><span class="line">    private byte[] bigSize = new byte[2 * _1MB];</span><br><span class="line">    public static void testGC() &#123;</span><br><span class="line">        ReferenceCountingGC objA = new ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = new ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = null;</span><br><span class="line">        objB = null;</span><br><span class="line"></span><br><span class="line">        //假设在这行发生了GC，objA和ojbB是否被回收</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p>[Full GC (System)  [Tenured: 0K-&gt;210K(10240K), 0.0149142 secs] <strong>4603K-&gt;210K</strong>(19456K), [Perm : 2999K-&gt;2999(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;从运行结果中可以看到GC日志中包含”4603K-&gt;210K”，这意味着虚拟机并没有因为这两个对象相互引用就不回收它们，这也证明虚拟并不是通过引用计数算法来判断对象是否存活的。</p><hr><p><br></p><h3 id="nbsp-nbsp-nbsp-2、可达性分析算法"><a href="#nbsp-nbsp-nbsp-2、可达性分析算法" class="headerlink" title="&nbsp; &nbsp;&nbsp;2、可达性分析算法"></a>&nbsp; &nbsp;&nbsp;2、可达性分析算法</h3><hr><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;在主流的商用程序语言中(Java和C#)，都是使用可达性分析(Reachability Analysis)算法判断对象是否存活的。这个算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，下图对象object5, object6, object7虽然有互相判断，但它们到GC Roots是不可达的，所以它们将会判定为是可回收对象。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<img src="/images/GCRootReachAnalysis.png" alt="GCRootReachAnalysis.png"></p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;在Java语言里，可作为GC Roots对象的包括如下几种：<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;1. 虚拟机栈(栈桢中的本地变量表)中的引用的对象<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;2. 方法区中的类静态属性引用的对象<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;3. 方法区中的常量引用的对象<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;4. 本地方法栈中JNI的引用的对象<br></p><h4 id="nbsp-nbsp-nbsp-对象生存还是死亡"><a href="#nbsp-nbsp-nbsp-对象生存还是死亡" class="headerlink" title="&nbsp; &nbsp;&nbsp;对象生存还是死亡"></a>&nbsp; &nbsp;&nbsp;对象生存还是死亡</h4><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;两次对对象进行标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。<br></p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>1).第一次标记并进行一次筛选。</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;筛选的条件是此对象是否有必要执行finalize()方法。<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;当对象没有覆盖finalize方法，或者finzlize方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，对象被回收。<br></p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>2).第二次标记</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象finalize()方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;finalize()方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己(this 关键字)赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。不过要尽量避免使用finalize这个方法。<br></p><p>流程图如下：</p><p><img src="/images/finilized2.png" alt="finilized2.png"></p><p><img src="/images/finilized1.png" alt="finilized1.png"></p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 此代码演示了两点</span><br><span class="line"> * 1、对象可以在被GC时自我拯救</span><br><span class="line"> * 2、这种自救的机会只有一次，因为一个对象的finalize()方法最多只能被系统自动调用一次。</span><br><span class="line"> */</span><br><span class="line">public class FinalizeEscapeGC &#123;</span><br><span class="line">    public static FinalizeEscapeGC SAVE_HOOK = null;</span><br><span class="line">    public void isAlive() &#123;</span><br><span class="line">        System.out.println(&quot;yes, I am still alive&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">        System.out.println(&quot;finalize method executed!&quot;);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = this;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        SAVE_HOOK = new FinalizeEscapeGC();</span><br><span class="line">        //对象第一次成功拯救自己</span><br><span class="line">        SAVE_HOOK = null;</span><br><span class="line">        System.gc();</span><br><span class="line">        //因为finalize方法优先级很低，所有暂停0.5秒以等待它</span><br><span class="line">        Thread.sleep(500);</span><br><span class="line">        if (SAVE_HOOK != null) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;no ,I am dead!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //-----------------------</span><br><span class="line">        //以上代码与上面的完全相同,但这次自救却失败了！！！</span><br><span class="line">        SAVE_HOOK = null;</span><br><span class="line">        System.gc();</span><br><span class="line">        //因为finalize方法优先级很低，所有暂停0.5秒以等待它</span><br><span class="line">        Thread.sleep(500);</span><br><span class="line">        if (SAVE_HOOK != null) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;no ,I am dead!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><br>finalize method executed!<br><br>yew, I am still alive<br><br>no ,I am dead!<br></p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;从结果可以看出，SAVE_HOOK对象的finalize()方法确实被GC收集器触发过，并且在被收集前成功逃脱了。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;另外一个值得注意的地方是，代码中两段完全一样的代码，执行结果却是一次逃脱成功，一次失败，这是因为<strong>任何一个对象的finalize()方法都只会被系统自动调用一次</strong>，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。<strong>不建议自己重写finalize()方法，尽量避免使用。</strong></p><hr><p><br></p><h4 id="nbsp-nbsp-nbsp-3、引用"><a href="#nbsp-nbsp-nbsp-3、引用" class="headerlink" title="&nbsp; &nbsp;&nbsp;3、引用"></a>&nbsp; &nbsp;&nbsp;3、引用</h4><hr><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在JDK 1.2之前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，这四种引用强度依次逐渐减弱。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<strong>强引用</strong>：就是指在程序代码之中普遍存在的，类似Object obj = new Object()这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<strong>软引用</strong>：用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<strong>弱引用</strong>：也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。</p><p>　　<br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<strong>虚引用</strong>：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;nbsp-nbsp-nbsp-1、引用计数算法&quot;&gt;&lt;a href=&quot;#nbsp-nbsp-nbsp-1、引用计数算法&quot; class=&quot;headerlink&quot; title=&quot;&amp;nbsp; &amp;nbsp;&amp;nbsp;1、引用计数算法&quot;&gt;&lt;/a&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;1、引用计数算法&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;引用计数算法就是对于创建的每一个对象都有一个与之关联的计数器，这个计数器记录着该对象被使用的次数，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器减1；任何时刻计数器都为0的对象就是不可能再被使用的，垃圾收集器在进行垃圾回收时，对扫描到的每一个对象判断一下计数器是否等于0，若等于0，就会释放该对象占用的内存空间,同时将该对象引用的其他对象的计数器进行减一操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Blog</title>
    <link href="http://yoursite.com/2018/09/02/Hexo/hexo_blog/"/>
    <id>http://yoursite.com/2018/09/02/Hexo/hexo_blog/</id>
    <published>2018-09-02T10:05:00.000Z</published>
    <updated>2018-09-02T15:09:55.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　备忘通过Hexo实现从md文件生成静态页面，然后发布到GitHub Pages的过程。</p><h2 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h2><h3 id="1、安装必须的软件"><a href="#1、安装必须的软件" class="headerlink" title="1、安装必须的软件"></a>1、安装必须的软件</h3><ol><li>安装Git<ul><li><a href="http://git-scm.com/download/win" target="_blank" rel="noopener">Git官方版本的安装</a></li></ul></li><li>安装Node.js<ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js官方版本的安装</a></li></ul></li><li><p>安装Hexo</p><ul><li><p>常规安装命令<br><br>$ npm install -g hexo-cli</p></li><li><p>常规命令有可能被“墙”，安装hexo为了避免出现类似情况，我使用<a href="https://npm.taobao.org" target="_blank" rel="noopener">淘宝NPM镜像</a>,输入以下命令等待安装完成。<br><br>$ npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p></li><li><p>使用淘宝NPM安装Hexo。<br><br>$ cnpm install -g hexo-cli   （与原先的npm完全一样，只是命令改为cnpm,一样等待hexo安装完成），出现的WARN可以不用理会，继续输入以下命令：<br>$ cnpm install hexo –save</p></li></ul></li></ol><a id="more"></a><h3 id="2、验证软件正确安装"><a href="#2、验证软件正确安装" class="headerlink" title="2、验证软件正确安装"></a>2、验证软件正确安装</h3><ul><li>git –version     　　检验git是否安装成功，显示出git的具体版本</li><li>node -v   　　　　检验node是否安装成功，显示出node的具体版本</li><li>npm -v     　　　　检验npm是否安装成功，显示出npm的具体版本</li><li>hexo -v　　　　检验hexo是否安装成功，显示出hexo的具体版本</li></ul><h3 id="3、-使用Hexo建站"><a href="#3、-使用Hexo建站" class="headerlink" title="3、 使用Hexo建站"></a>3、 使用Hexo建站</h3><ul><li>安装完后，创建文件夹（例如D：\Hexo），在文件夹内点击鼠标右键选择Git bash，输入以下指令：</li></ul><p>　　 <code>$ hexo init</code>　　　该命令会在目标文件夹内建立网站所需要的所有文件。</p><ul><li>接下来是安装依赖包：</li></ul><p>　　 <code>$ npm install</code>　或者　<code>$ cnpm install</code>　　　搭建起本地的Hexo博客</p><ul><li>本地运行博客只要输入该命令</li></ul><p>　　 <code>$ hexo generate　和　$ hexo server</code>　或者　<code>$ hexo s -g</code>　　启动本地博客，打开浏览器，输入localhost:4000,就可以在本地看到你的个人博客了</p><h3 id="4、-一般的搭建方法"><a href="#4、-一般的搭建方法" class="headerlink" title="4、 一般的搭建方法"></a>4、 一般的搭建方法</h3><p>　　在上面，我们已经配置好了所需的所有东西，也成功地搭建了一个本地Hexo博客。现在，需要使用GitHub Pages搭建一个别人能够访问的Hexo博客。</p><h4 id="4-1-使用默认theme"><a href="#4-1-使用默认theme" class="headerlink" title="4.1 使用默认theme"></a>4.1 使用默认theme</h4><p>　我们继续使用上面的文件夹D:\Hexo（也可以新建一个文件夹重新生成），然后编辑该文件夹下的_config.yml。<br>　默认生成的_config.yml：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: http://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type:</span><br></pre></td></tr></table></figure></p><p>　修改后的_config.yml：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: 对应仓库的SSH地址（可以在GitHub对应的仓库中复制）</span><br><span class="line">  branch: 分支（User Pages为master，Project Pages为gh-pages）</span><br></pre></td></tr></table></figure></p><p>　为了能够使Hexo部署到GitHub上，需要安装一个插件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save  或者 $ cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>　执行下列指令即可完成部署：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br><span class="line">或者</span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure></p><p>　之后，可以通过在浏览器键入：username.github.io进行浏览。</p><h4 id="4-2-简介-blog-config-yml文件"><a href="#4-2-简介-blog-config-yml文件" class="headerlink" title="4.2 简介 blog/_config.yml文件"></a>4.2 简介 blog/_config.yml文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#博客名称</span><br><span class="line">title: 我的博客</span><br><span class="line">#副标题</span><br><span class="line">subtitle: 一天进步一点</span><br><span class="line">#简介</span><br><span class="line">description: 记录生活点滴</span><br><span class="line">#博客作者</span><br><span class="line">author: John Doe</span><br><span class="line">#博客语言</span><br><span class="line">language: zh-CN</span><br><span class="line">#时区</span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line">#博客地址,与申请的GitHub一致</span><br><span class="line">url: http:<span class="comment">//elfwalk.github.io</span></span><br><span class="line">root: /</span><br><span class="line">#博客链接格式</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: <span class="keyword">public</span></span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: <span class="number">0</span></span><br><span class="line">render_drafts: <span class="keyword">false</span></span><br><span class="line">post_asset_folder: <span class="keyword">false</span></span><br><span class="line">relative_link: <span class="keyword">false</span></span><br><span class="line">future: <span class="keyword">true</span></span><br><span class="line">highlight:</span><br><span class="line">  enable: <span class="keyword">true</span></span><br><span class="line">  line_number: <span class="keyword">true</span></span><br><span class="line">  auto_detect: <span class="keyword">true</span></span><br><span class="line">  tab_replace:</span><br><span class="line"></span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line">#日期格式</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line">#分页，每页文章数量</span><br><span class="line">per_page: <span class="number">10</span></span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line">#博客主题</span><br><span class="line">theme: landscape</span><br><span class="line"></span><br><span class="line">#发布设置</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  #elfwalk改为你的github用户名</span><br><span class="line">  repository: https:<span class="comment">//github.com/elfwalk/elfwalk.github.io.git</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h3 id="5、优化部署与管理-☆☆☆"><a href="#5、优化部署与管理-☆☆☆" class="headerlink" title="5、优化部署与管理(☆☆☆)"></a>5、优化部署与管理(☆☆☆)</h3><p>　　Hexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，就不可能了（除非你自己写html）。</p><p>　　其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。</p><p>　　但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库(）。</p><p>　　所以，利用了分支！！！简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。</p><h4 id="5-1-搭建流程"><a href="#5-1-搭建流程" class="headerlink" title="5.1 搭建流程"></a>5.1 搭建流程</h4><pre><code>1. 创建仓库，username.github.io；2. 创建两个分支：master 与 hexo；3. 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；4. 使用git clone git@github.com:username/username.github.io.git拷贝仓库；5. 在本地username.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;6. 修改_config.yml中的deploy参数，分支应为master；7. 依次执行git add .;    git commit -m &quot;…&quot;;    git push origin hexo提交网站相关的文件；8. 执行hexo generate -d生成网站并部署到GitHub上。</code></pre><p>　　这样一来，在GitHub上的username.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。</p><h4 id="5-3-管理流程"><a href="#5-3-管理流程" class="headerlink" title="5.3 管理流程"></a>5.3 管理流程</h4><h5 id="5-3-1-日常修改"><a href="#5-3-1-日常修改" class="headerlink" title="5.3.1 日常修改"></a>5.3.1 日常修改</h5><p>　　1. 在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理：</p><pre><code>2. 依次执行git add .git;  commit -m &quot;…&quot;;   git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；3. 然后才执行hexo generate -d发布网站到master分支上。</code></pre><h5 id="5-3-２本地资料丢失"><a href="#5-3-２本地资料丢失" class="headerlink" title="5.3.２本地资料丢失"></a>5.3.２本地资料丢失</h5><p>当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</p><pre><code>1. 使用git clone git@github.com:username/username.github.io.git拷贝仓库（默认分支为hexo）；2. 在本地新拷贝的username.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;　　备忘通过Hexo实现从md文件生成静态页面，然后发布到GitHub Pages的过程。&lt;/p&gt;
&lt;h2 id=&quot;主要流程&quot;&gt;&lt;a href=&quot;#主要流程&quot; class=&quot;headerlink&quot; title=&quot;主要流程&quot;&gt;&lt;/a&gt;主要流程&lt;/h2&gt;&lt;h3 id=&quot;1、安装必须的软件&quot;&gt;&lt;a href=&quot;#1、安装必须的软件&quot; class=&quot;headerlink&quot; title=&quot;1、安装必须的软件&quot;&gt;&lt;/a&gt;1、安装必须的软件&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;安装Git&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://git-scm.com/download/win&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Git官方版本的安装&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安装Node.js&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Node.js官方版本的安装&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装Hexo&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;常规安装命令&lt;br&gt;&lt;br&gt;$ npm install -g hexo-cli&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;常规命令有可能被“墙”，安装hexo为了避免出现类似情况，我使用&lt;a href=&quot;https://npm.taobao.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;淘宝NPM镜像&lt;/a&gt;,输入以下命令等待安装完成。&lt;br&gt;&lt;br&gt;$ npm install -g cnpm –registry=&lt;a href=&quot;https://registry.npm.taobao.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://registry.npm.taobao.org&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用淘宝NPM安装Hexo。&lt;br&gt;&lt;br&gt;$ cnpm install -g hexo-cli   （与原先的npm完全一样，只是命令改为cnpm,一样等待hexo安装完成），出现的WARN可以不用理会，继续输入以下命令：&lt;br&gt;$ cnpm install hexo –save&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Work Begin</title>
    <link href="http://yoursite.com/2018/04/07/WorkBegin/"/>
    <id>http://yoursite.com/2018/04/07/WorkBegin/</id>
    <published>2018-04-07T15:09:00.000Z</published>
    <updated>2018-09-02T08:50:18.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Work-Begin"><a href="#Work-Begin" class="headerlink" title="Work Begin"></a>Work Begin</h1><h2 id="Work-hard-and-start-recording-your-knowledge-every-day-Don’t-forget-to-improve-your-professional-knowledge-in-your-work"><a href="#Work-hard-and-start-recording-your-knowledge-every-day-Don’t-forget-to-improve-your-professional-knowledge-in-your-work" class="headerlink" title="Work hard and start recording your knowledge every day. Don’t forget to improve your professional knowledge in your work."></a>Work hard and start recording your knowledge every day. Don’t forget to improve your professional knowledge in your work.</h2><h2 id="Need-Work…"><a href="#Need-Work…" class="headerlink" title="Need Work…"></a>Need Work…</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Work-Begin&quot;&gt;&lt;a href=&quot;#Work-Begin&quot; class=&quot;headerlink&quot; title=&quot;Work Begin&quot;&gt;&lt;/a&gt;Work Begin&lt;/h1&gt;&lt;h2 id=&quot;Work-hard-and-start-recording-you
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>225. Implement Stack using Queues</title>
    <link href="http://yoursite.com/2017/08/31/225-Implement-Stack-using-Queues/"/>
    <id>http://yoursite.com/2017/08/31/225-Implement-Stack-using-Queues/</id>
    <published>2017-08-31T15:17:29.000Z</published>
    <updated>2018-04-07T14:44:08.725Z</updated>
    
    <content type="html"><![CDATA[<p>Implement the following operations of a stack using queues.</p><p>push(x) –Push element x onto stack.<br>pop() –Removes the element on top of the stack.<br>top() –Get the top element.<br>empty() –Return whether the stack is empty.</p><p>Notes:<br>You must use only standard operations of a queue – which means only push to back, peek / pop from front, size, and is empty operations are valid.<br>Depending on your language, queue may not be supported natively.You may simulate a queue by using a list or deque(double - ended queue), as long as you use only standard operations of a queue.<br>You may assume that all operations are valid(for example, no pop or top operations will be called on an empty stack).</p><a id="more"></a><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　使用队列实现堆栈的push(x) ，pop()，top()，empty()操作。<br>　　只能使用一个队列的标准操作 - 这意味着只能从前面，后面，peek / pop从前面，大小，并且是空的操作是有效的。<br>根据您的语言，队列可能不被本机支持。您可以使用列表或deque（双端队列）来模拟队列，只要您仅使用队列的标准操作即可。可以假设所有操作都有效（例如，在空堆栈上不会调用pop或top操作）。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="　方法一："></a>　方法一：</h3><p>　　用两个队列模拟一个堆栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">队列a和b</span><br><span class="line"> （<span class="number">1</span>）取栈顶元素： 返回有元素的队列的首元素</span><br><span class="line"> （<span class="number">2</span>）判栈空：若队列a和b均为空则栈空</span><br><span class="line"> （<span class="number">3</span>）入栈：a队列当前有元素，b为空（倒过来也一样）则将需要入栈的元素先放b中，然后将a中的元素依次出队列并入列倒b中。（保证有一个队列是空的）</span><br><span class="line"> （<span class="number">4</span>）出栈：将有元素的队列出列即可。</span><br><span class="line">比如先将<span class="number">1</span>插入队a中 ，现在要将<span class="number">2</span>入栈，则将<span class="number">2</span>插入b中然后将a中的<span class="number">1</span>出列入到b中，b中的元素变为 <span class="number">2</span> ，<span class="number">1</span></span><br><span class="line">a为空，现在要压入<span class="number">3</span> 则将<span class="number">3</span>插入a中 ，依次将b中的<span class="number">2</span> ，<span class="number">1</span> 出列并加入倒a中 ，a中的元素变为 <span class="number">3</span>，<span class="number">2</span>，<span class="number">1</span> b为空</span><br><span class="line">注意：算法保证在任何时候都有一队列为空</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Push element x onto stack.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (q1.empty())</span><br><span class="line">&#123;</span><br><span class="line">q1.push(x);</span><br><span class="line"><span class="keyword">while</span> (!q2.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = q2.front();</span><br><span class="line">q2.pop();</span><br><span class="line">q1.push(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">q2.push(x);</span><br><span class="line"><span class="keyword">while</span> (!q1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = q1.front();</span><br><span class="line">q1.pop();</span><br><span class="line">q2.push(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Removes the element on top of the stack.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!q1.empty())</span><br><span class="line">q1.pop();</span><br><span class="line"><span class="keyword">if</span> (!q2.empty())</span><br><span class="line">q2.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the top element.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!q1.empty())</span><br><span class="line"><span class="keyword">return</span> q1.front();</span><br><span class="line"><span class="keyword">if</span> (!q2.empty())</span><br><span class="line"><span class="keyword">return</span>q2.front();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return whether the stack is empty.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span>q1.empty()&amp;&amp;q2.empty();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="　方法二："></a>　方法二：</h3><p>　　 利用双端队列，实现代码简单，但是不懂原理，效率低，真正要学习的是两个队列实现栈，以及两个栈实现队列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Push element x onto stack.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">res.push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Removes the element on top of the stack.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">res.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the top element.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> res.back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return whether the stack is empty.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span>res.empty();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Implement the following operations of a stack using queues.&lt;/p&gt;
&lt;p&gt;push(x) –Push element x onto stack.&lt;br&gt;pop() –Removes the element on top of the stack.&lt;br&gt;top() –Get the top element.&lt;br&gt;empty() –Return whether the stack is empty.&lt;/p&gt;
&lt;p&gt;Notes:&lt;br&gt;You must use only standard operations of a queue – which means only push to back, peek / pop from front, size, and is empty operations are valid.&lt;br&gt;Depending on your language, queue may not be supported natively.You may simulate a queue by using a list or deque(double - ended queue), as long as you use only standard operations of a queue.&lt;br&gt;You may assume that all operations are valid(for example, no pop or top operations will be called on an empty stack).&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>224. Basic Calculator</title>
    <link href="http://yoursite.com/2017/08/31/224-Basic-Calculator/"/>
    <id>http://yoursite.com/2017/08/31/224-Basic-Calculator/</id>
    <published>2017-08-31T14:30:03.000Z</published>
    <updated>2018-04-07T14:44:08.725Z</updated>
    
    <content type="html"><![CDATA[<p>Implement a basic calculator to evaluate a simple expression string.<br>he expression string may contain open(and closing parentheses), the plus + or minus sign - , non - negative integers and empty spaces .</p><p>You may assume that the given expression is always valid.<br>Some examples :<br>“1 + 1” = 2<br>“ 2-1 + 2 “ = 3<br>“(1+(4+5+2)-3)+(6+8)” = 23</p><a id="more"></a><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　实现基本的计算器来计算一个简单的表达式字符串，表达式字符串可能包含打开“（”和闭括号“）”，加号或减号，非负整数和空格。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="　方法一："></a>　方法一：</h3><p>　　两个要点：<br>　　　　1、无括号时，顺序执行<br>　　　　2、有括号时，先执行括号中的<br>　　两个栈：<br>　　　　一个存放操作数，每次进栈要注意，如果操作符栈顶元素为’+’/‘-‘，则需要立即计算。<br>　　　　一个存放操作符（包括括号），每次出现’)’时，不断进行出栈计算再进栈，直到弹出’(‘，说明当前括号内计算完毕。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; num;<span class="comment">//存放操作数</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; op;<span class="comment">//存放操作符</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; s.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; s.size() &amp;&amp; s[i] == <span class="string">' '</span>)<span class="comment">//跳过字符串中的空格字符</span></span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (i == s.size())</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">'+'</span> || s[i] == <span class="string">'-'</span> || s[i] == <span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line">op.push(s[i]);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">')'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (op.top() != <span class="string">'('</span>)</span><br><span class="line">&#123;<span class="comment">// calculation within parentheses </span></span><br><span class="line"><span class="keyword">int</span> n2 = num.top();</span><br><span class="line">num.pop();</span><br><span class="line"><span class="keyword">int</span> n1 = num.top();</span><br><span class="line">num.pop();</span><br><span class="line"><span class="keyword">if</span> (op.top() == <span class="string">'+'</span>)</span><br><span class="line">num.push(n1 + n2);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">num.push(n1 - n2);</span><br><span class="line">op.pop();</span><br><span class="line">&#125;</span><br><span class="line">op.pop();</span><br><span class="line"><span class="keyword">while</span> (!op.empty() &amp;&amp; op.top() != <span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n2 = num.top();</span><br><span class="line">num.pop();</span><br><span class="line"><span class="keyword">int</span> n1 = num.top();</span><br><span class="line">num.pop();</span><br><span class="line"><span class="keyword">if</span> (op.top() == <span class="string">'+'</span>)</span><br><span class="line">num.push(n1 + n2);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">num.push(n1 - n2);</span><br><span class="line">op.pop();</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; s.size() &amp;&amp; s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">n = n * <span class="number">10</span> + (s[i] - <span class="string">'0'</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">num.push(n);</span><br><span class="line"><span class="keyword">while</span> (!op.empty() &amp;&amp; op.top() != <span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n2 = num.top();</span><br><span class="line">num.pop();</span><br><span class="line"><span class="keyword">int</span> n1 = num.top();</span><br><span class="line">num.pop();</span><br><span class="line"><span class="keyword">if</span> (op.top() == <span class="string">'+'</span>)</span><br><span class="line">num.push(n1 + n2);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">num.push(n1 - n2);</span><br><span class="line">op.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num.top();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="　方法二："></a>　方法二：</h3><p>　　由于表达式中只含有括号和加减法运算，我们可以通过加减法的规律对表达式进行化简，，因为只有加减，去括号的话只会影响括号内部的符号变换，表达式都是从左到右依次执行的，然后求值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">num.push(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">char</span> op = <span class="string">'+'</span>;</span><br><span class="line"><span class="keyword">long</span> re = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">switch</span> (s[i]) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">op = s[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">num.push(num.top() * (op == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>));</span><br><span class="line">op = <span class="string">'+'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">num.pop();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">tmp = tmp * <span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">i--;</span><br><span class="line">re += (op == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>)*num.top()*tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法三："><a href="#方法三：" class="headerlink" title="　方法三："></a>　方法三：</h3><p>　　通用性代码，可以包含乘除，加括号等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculates5</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1、把表达式去掉空格存到队列中</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; que;<span class="comment">//存放表达式序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>str = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">switch</span> (s[i])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                str = s[i];</span><br><span class="line">                que.push(str);</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">while</span> (i&lt;s.size()&amp;&amp;s[i]&gt;=<span class="string">'0'</span>&amp;&amp;s[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    str += s[i];</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                que.push(str);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、把中缀表达式转换为后缀表达式</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; stackA;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; stackB;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> temp = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">char</span> op = temp.at(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (op==<span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stackB.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (op==<span class="string">')'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stackB.empty() &amp;&amp; stackB.top() != <span class="string">"("</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    stackA.push(stackB.top());</span><br><span class="line">                    stackB.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!stackB.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    stackB.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (op==<span class="string">'+'</span> || op ==<span class="string">'-'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (stackB.empty() || stackB.top()==<span class="string">"("</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    stackB.push(temp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!stackB.empty()&amp;&amp;stackB.top()!=<span class="string">"("</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        stackA.push(stackB.top());</span><br><span class="line">                        stackB.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    stackB.push(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                stackA.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stackB.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            stackA.push(stackB.top());</span><br><span class="line">            stackB.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stackA.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            stackB.push(stackA.top());</span><br><span class="line">            stackA.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、通过后缀表达式进行计算</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!stackB.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">string</span> temp = stackB.top();</span><br><span class="line">            stackB.pop();</span><br><span class="line">            <span class="keyword">char</span> op = temp.at(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">switch</span> (op)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                res = result.top();</span><br><span class="line">                result.pop();</span><br><span class="line">                res += result.top();</span><br><span class="line">                result.pop();</span><br><span class="line">                result.push(res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                res = result.top();</span><br><span class="line">                result.pop();</span><br><span class="line">                res = result.top() - res;</span><br><span class="line">                result.pop();</span><br><span class="line">                result.push(res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                result.push(atoi(temp.c_str()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Implement a basic calculator to evaluate a simple expression string.&lt;br&gt;he expression string may contain open(and closing parentheses), the plus + or minus sign - , non - negative integers and empty spaces .&lt;/p&gt;
&lt;p&gt;You may assume that the given expression is always valid.&lt;br&gt;Some examples :&lt;br&gt;“1 + 1” = 2&lt;br&gt;“ 2-1 + 2 “ = 3&lt;br&gt;“(1+(4+5+2)-3)+(6+8)” = 23&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>222. Count Complete Tree Nodes</title>
    <link href="http://yoursite.com/2017/08/31/222-Count-Complete-Tree-Nodes/"/>
    <id>http://yoursite.com/2017/08/31/222-Count-Complete-Tree-Nodes/</id>
    <published>2017-08-31T13:59:31.000Z</published>
    <updated>2018-04-07T14:44:08.725Z</updated>
    
    <content type="html"><![CDATA[<p>Given a complete binary tree, count the number of nodes.</p><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　给定一棵完全二叉树，求树种节点的个数。</p><a id="more"></a><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>　　如果用常规的解法一个个遍历，就是O(n)时间复杂度 ，不通过。因为是完全二叉树，满二叉树有一个性质是节点数等于2^h-1，h为高度，所以可以这样判断节点的左右高度是不是一样，如果是一样说明是满二叉树，就可以用刚才的公式，如果左右不相等就递归计算左右节点。</p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="　方法一："></a>　方法一：</h3><p>　　若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。根据完全二叉树的这个性质，可以这样来求解完全二叉树中节点的个数。对于一个节点node，计算它最左端的节点到node的深度为leftDepth，计算它最右端的节点到node的深度是rightDepth；如果leftDepth和rightDepth相等，那么以node为根节点的树是一棵满二叉树，此时以node为根节点的树的节点个数是pow(2,leftDepth)-1；如果leftDepth和rightDepth不相等，递归求解node的左子树的节点数和右子树的节点数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depthLeft</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (root)</span><br><span class="line">&#123;</span><br><span class="line">root = root-&gt;left;</span><br><span class="line">height++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depthRight</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (root)</span><br><span class="line">&#123;</span><br><span class="line">root = root-&gt;right;</span><br><span class="line">height++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ld = depthLeft(root);</span><br><span class="line"><span class="keyword">int</span> rd = depthRight(root);</span><br><span class="line"><span class="keyword">if</span> (ld == rd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> lnum = <span class="built_in">pow</span>(<span class="number">2</span>,ld) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> lnum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> countNodes(root-&gt;left) + countNodes(root-&gt;right) + <span class="number">1</span>;<span class="comment">//最后加一加的是根节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="　方法二："></a>　方法二：</h3><p>　　也是比较左右子树的高度是否相等，如果左子树等于右子树的高度（都按左子树计算高度，因为完全二叉树的高度由左子树的高度确定的）则左子树肯定是完全二叉树，右子树再递归判读，如果左子树不等于右子树高度，右子树肯定是完全二叉树，左子树再递归判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (root)</span><br><span class="line">&#123;</span><br><span class="line">root = root-&gt;left;</span><br><span class="line">height++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ld = depth(root-&gt;left);</span><br><span class="line"><span class="keyword">int</span> rd = depth(root-&gt;right);</span><br><span class="line"><span class="keyword">if</span> (ld==rd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, ld) + countNodes(root-&gt;right);</span><br><span class="line">   <span class="comment">/* int lnum = (2 &lt;&lt; (ld - 1)) + countNodes(root-&gt;left);//当层数是0的时候左移公式出现问题</span></span><br><span class="line"><span class="comment">return lnum;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, rd) + countNodes(root-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a complete binary tree, count the number of nodes.&lt;/p&gt;
&lt;h2 id=&quot;题意：&quot;&gt;&lt;a href=&quot;#题意：&quot; class=&quot;headerlink&quot; title=&quot;题意：&quot;&gt;&lt;/a&gt;题意：&lt;/h2&gt;&lt;p&gt;　　给定一棵完全二叉树，求树种节点的个数。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>219. Contains Duplicate II</title>
    <link href="http://yoursite.com/2017/08/30/219-Contains-Duplicate-II/"/>
    <id>http://yoursite.com/2017/08/30/219-Contains-Duplicate-II/</id>
    <published>2017-08-30T15:18:27.000Z</published>
    <updated>2018-04-07T14:44:08.725Z</updated>
    
    <content type="html"><![CDATA[<p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array<br>such that nums[i] = nums[j] and the difference between i and j is at most k.</p><a id="more"></a><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　给定整数数组和整数k，找出数组中是否有两个不同的索引i和j，使得nums [i] = nums [j]，i和j之间的差最多为k。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>　　利用hash表，key为元素值，value为此元素所对应的索引的集合，遍历元素组，把相同元素的索引都放入到对应hash表的value集合中，然后遍历hash表，找出集合大小大于1的value集合，遍历此集合，求出相同元素索引间最小距离。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; hash;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">hash[nums[i]].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> itr = hash.begin();itr!=hash.end();itr++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (itr-&gt;second.size()&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> minIndex = INT_MAX;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; itr-&gt;second.size(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> m = j - <span class="number">1</span>;</span><br><span class="line">minIndex = min(minIndex, itr-&gt;second[j] - itr-&gt;second[m]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (minIndex&lt;=k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="　方法二："></a>　方法二：</h3><p>　　思路同方法一，利用hash表，不同点是一边遍历数组，一边在hash表对应的索引值进行相减比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> itr = hash.find(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (itr != hash.end())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - itr-&gt;second &lt;= k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    hash.erase(itr);</span><br><span class="line">            &#125;</span><br><span class="line">            hash[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array&lt;br&gt;such that nums[i] = nums[j] and the difference between i and j is at most k.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
</feed>
