<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PikachuBLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-02T15:09:59.774Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>CodePikachu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM—对象存活判定算法</title>
    <link href="http://yoursite.com/2018/09/02/Java/jvm/JVM%E2%80%94%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/09/02/Java/jvm/JVM—对象存活判定算法/</id>
    <published>2018-09-02T14:39:00.000Z</published>
    <updated>2018-09-02T15:09:59.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM——对象存活判定算法"><a href="#JVM——对象存活判定算法" class="headerlink" title="JVM——对象存活判定算法"></a>JVM——对象存活判定算法</h1><h3 id="nbsp-nbsp-nbsp-1、引用计数算法"><a href="#nbsp-nbsp-nbsp-1、引用计数算法" class="headerlink" title="&nbsp; &nbsp;&nbsp;1、引用计数算法"></a>&nbsp; &nbsp;&nbsp;1、引用计数算法</h3><hr><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;引用计数算法就是对于创建的每一个对象都有一个与之关联的计数器，这个计数器记录着该对象被使用的次数，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器减1；任何时刻计数器都为0的对象就是不可能再被使用的，垃圾收集器在进行垃圾回收时，对扫描到的每一个对象判断一下计数器是否等于0，若等于0，就会释放该对象占用的内存空间,同时将该对象引用的其他对象的计数器进行减一操作。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;引用计数算法的垃圾收集一般有侵入式与非侵入式两种，侵入式的实现就是将引用计数器直接根植在对象内部，用C++的思想进行解释就是，在对象的构造或者拷贝构造中进行加一操作，在对象的析构中进行减一操作，非侵入式思想就是有一块单独的内存区域，用作引用计数器。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;算法的优点：引用计数算法的实现简单，判断效率也很高，使用引用计数器,内存回收可以穿插在程序的运行中，在程序运行中，当发现某一对象的引用计数器为0时，可以立即对该对象所占用的内存空间进行回收，这种方式可以避免FULL GC时带来的程序暂停。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;算法的缺点：采用引用计数器进行垃圾回收，最大的缺点就是不能解决<strong>循环引用</strong>的问题，例如一个象(A Object)持有另外一个对象(B Object)的引用，t同时B对象也持有A对象的引用，这种情况下，两个对象实例将一直存在于JVM的堆中，无法进行回收,代码示例如下(引用计数器无法对a与b对象进行回收):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    private B b;</span><br><span class="line">    public B getB() &#123;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setB(B b) &#123;</span><br><span class="line">        this.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">    private A a;</span><br><span class="line">    public A getA() &#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setA(A a) &#123;</span><br><span class="line">        this.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A a = new A();</span><br><span class="line">        B b = new B();</span><br><span class="line">        a.setB(b);</span><br><span class="line">        b.setA(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;Java语言中没有选用引用计数算法来管理内存，其中最主要的一个原因也是它很难解决<strong>对象之间相互循环引用的问题</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 在testGC()方法中，对象objA和objB都有字段instance，</span><br><span class="line">* 赋值令objA.instance=objB及objB.instance=objA，</span><br><span class="line">* 除此之外这两个对象再无任何引用，</span><br><span class="line">* 实际上这两个对象都已经不能再被访问，</span><br><span class="line">* 但是它们因为相互引用着对象方，</span><br><span class="line">* 导致它们的引用计数都不为0，</span><br><span class="line">* 于是引用计数算法无法通知GC收集器回收它们。</span><br><span class="line">*/  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 执行后，objA和objB会不会被GC呢？</span><br><span class="line"> */</span><br><span class="line">public class ReferenceCountingGC &#123;</span><br><span class="line">    public Object instance = null;</span><br><span class="line">    private static final int _1MB = 1024 * 1024;</span><br><span class="line">    /**</span><br><span class="line">     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过</span><br><span class="line">     */</span><br><span class="line">    private byte[] bigSize = new byte[2 * _1MB];</span><br><span class="line">    public static void testGC() &#123;</span><br><span class="line">        ReferenceCountingGC objA = new ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = new ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = null;</span><br><span class="line">        objB = null;</span><br><span class="line"></span><br><span class="line">        //假设在这行发生了GC，objA和ojbB是否被回收</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p>[Full GC (System)  [Tenured: 0K-&gt;210K(10240K), 0.0149142 secs] <strong>4603K-&gt;210K</strong>(19456K), [Perm : 2999K-&gt;2999(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;从运行结果中可以看到GC日志中包含”4603K-&gt;210K”，这意味着虚拟机并没有因为这两个对象相互引用就不回收它们，这也证明虚拟并不是通过引用计数算法来判断对象是否存活的。</p><hr><p><br></p><h3 id="nbsp-nbsp-nbsp-2、可达性分析算法"><a href="#nbsp-nbsp-nbsp-2、可达性分析算法" class="headerlink" title="&nbsp; &nbsp;&nbsp;2、可达性分析算法"></a>&nbsp; &nbsp;&nbsp;2、可达性分析算法</h3><hr><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;在主流的商用程序语言中(Java和C#)，都是使用可达性分析(Reachability Analysis)算法判断对象是否存活的。这个算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，下图对象object5, object6, object7虽然有互相判断，但它们到GC Roots是不可达的，所以它们将会判定为是可回收对象。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<img src="/images/GCRootReachAnalysis.png" alt="GCRootReachAnalysis.png"></p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;在Java语言里，可作为GC Roots对象的包括如下几种：<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;1. 虚拟机栈(栈桢中的本地变量表)中的引用的对象<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;2. 方法区中的类静态属性引用的对象<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;3. 方法区中的常量引用的对象<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;4. 本地方法栈中JNI的引用的对象<br></p><h4 id="nbsp-nbsp-nbsp-对象生存还是死亡"><a href="#nbsp-nbsp-nbsp-对象生存还是死亡" class="headerlink" title="&nbsp; &nbsp;&nbsp;对象生存还是死亡"></a>&nbsp; &nbsp;&nbsp;对象生存还是死亡</h4><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;两次对对象进行标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。<br></p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>1).第一次标记并进行一次筛选。</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;筛选的条件是此对象是否有必要执行finalize()方法。<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;当对象没有覆盖finalize方法，或者finzlize方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，对象被回收。<br></p><p>&nbsp; &nbsp;&nbsp;&nbsp;<strong>2).第二次标记</strong><br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象finalize()方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。<br><br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;finalize()方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己(this 关键字)赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。不过要尽量避免使用finalize这个方法。<br></p><p>流程图如下：</p><p><img src="/images/finilized2.png" alt="finilized2.png"></p><p><img src="/images/finilized1.png" alt="finilized1.png"></p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 此代码演示了两点</span><br><span class="line"> * 1、对象可以在被GC时自我拯救</span><br><span class="line"> * 2、这种自救的机会只有一次，因为一个对象的finalize()方法最多只能被系统自动调用一次。</span><br><span class="line"> */</span><br><span class="line">public class FinalizeEscapeGC &#123;</span><br><span class="line">    public static FinalizeEscapeGC SAVE_HOOK = null;</span><br><span class="line">    public void isAlive() &#123;</span><br><span class="line">        System.out.println(&quot;yes, I am still alive&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">        System.out.println(&quot;finalize method executed!&quot;);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = this;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        SAVE_HOOK = new FinalizeEscapeGC();</span><br><span class="line">        //对象第一次成功拯救自己</span><br><span class="line">        SAVE_HOOK = null;</span><br><span class="line">        System.gc();</span><br><span class="line">        //因为finalize方法优先级很低，所有暂停0.5秒以等待它</span><br><span class="line">        Thread.sleep(500);</span><br><span class="line">        if (SAVE_HOOK != null) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;no ,I am dead!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //-----------------------</span><br><span class="line">        //以上代码与上面的完全相同,但这次自救却失败了！！！</span><br><span class="line">        SAVE_HOOK = null;</span><br><span class="line">        System.gc();</span><br><span class="line">        //因为finalize方法优先级很低，所有暂停0.5秒以等待它</span><br><span class="line">        Thread.sleep(500);</span><br><span class="line">        if (SAVE_HOOK != null) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;no ,I am dead!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><br>finalize method executed!<br><br>yew, I am still alive<br><br>no ,I am dead!<br></p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;从结果可以看出，SAVE_HOOK对象的finalize()方法确实被GC收集器触发过，并且在被收集前成功逃脱了。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;另外一个值得注意的地方是，代码中两段完全一样的代码，执行结果却是一次逃脱成功，一次失败，这是因为<strong>任何一个对象的finalize()方法都只会被系统自动调用一次</strong>，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。<strong>不建议自己重写finalize()方法，尽量避免使用。</strong></p><hr><p><br></p><h4 id="nbsp-nbsp-nbsp-3、引用"><a href="#nbsp-nbsp-nbsp-3、引用" class="headerlink" title="&nbsp; &nbsp;&nbsp;3、引用"></a>&nbsp; &nbsp;&nbsp;3、引用</h4><hr><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在JDK 1.2之前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，这四种引用强度依次逐渐减弱。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<strong>强引用</strong>：就是指在程序代码之中普遍存在的，类似Object obj = new Object()这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<strong>软引用</strong>：用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。</p><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<strong>弱引用</strong>：也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。</p><p>　　<br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<strong>虚引用</strong>：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM——对象存活判定算法&quot;&gt;&lt;a href=&quot;#JVM——对象存活判定算法&quot; class=&quot;headerlink&quot; title=&quot;JVM——对象存活判定算法&quot;&gt;&lt;/a&gt;JVM——对象存活判定算法&lt;/h1&gt;&lt;h3 id=&quot;nbsp-nbsp-nbsp-1、引用计数
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Blog</title>
    <link href="http://yoursite.com/2018/09/02/Hexo/hexo_blog/"/>
    <id>http://yoursite.com/2018/09/02/Hexo/hexo_blog/</id>
    <published>2018-09-02T10:05:00.000Z</published>
    <updated>2018-09-02T15:09:55.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　备忘通过Hexo实现从md文件生成静态页面，然后发布到GitHub Pages的过程。</p><h2 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h2><h3 id="1、安装必须的软件"><a href="#1、安装必须的软件" class="headerlink" title="1、安装必须的软件"></a>1、安装必须的软件</h3><ol><li>安装Git<ul><li><a href="http://git-scm.com/download/win" target="_blank" rel="noopener">Git官方版本的安装</a></li></ul></li><li>安装Node.js<ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js官方版本的安装</a></li></ul></li><li><p>安装Hexo</p><ul><li><p>常规安装命令<br><br>$ npm install -g hexo-cli</p></li><li><p>常规命令有可能被“墙”，安装hexo为了避免出现类似情况，我使用<a href="https://npm.taobao.org" target="_blank" rel="noopener">淘宝NPM镜像</a>,输入以下命令等待安装完成。<br><br>$ npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p></li><li><p>使用淘宝NPM安装Hexo。<br><br>$ cnpm install -g hexo-cli   （与原先的npm完全一样，只是命令改为cnpm,一样等待hexo安装完成），出现的WARN可以不用理会，继续输入以下命令：<br>$ cnpm install hexo –save</p></li></ul></li></ol><a id="more"></a><h3 id="2、验证软件正确安装"><a href="#2、验证软件正确安装" class="headerlink" title="2、验证软件正确安装"></a>2、验证软件正确安装</h3><ul><li>git –version     　　检验git是否安装成功，显示出git的具体版本</li><li>node -v   　　　　检验node是否安装成功，显示出node的具体版本</li><li>npm -v     　　　　检验npm是否安装成功，显示出npm的具体版本</li><li>hexo -v　　　　检验hexo是否安装成功，显示出hexo的具体版本</li></ul><h3 id="3、-使用Hexo建站"><a href="#3、-使用Hexo建站" class="headerlink" title="3、 使用Hexo建站"></a>3、 使用Hexo建站</h3><ul><li>安装完后，创建文件夹（例如D：\Hexo），在文件夹内点击鼠标右键选择Git bash，输入以下指令：</li></ul><p>　　 <code>$ hexo init</code>　　　该命令会在目标文件夹内建立网站所需要的所有文件。</p><ul><li>接下来是安装依赖包：</li></ul><p>　　 <code>$ npm install</code>　或者　<code>$ cnpm install</code>　　　搭建起本地的Hexo博客</p><ul><li>本地运行博客只要输入该命令</li></ul><p>　　 <code>$ hexo generate　和　$ hexo server</code>　或者　<code>$ hexo s -g</code>　　启动本地博客，打开浏览器，输入localhost:4000,就可以在本地看到你的个人博客了</p><h3 id="4、-一般的搭建方法"><a href="#4、-一般的搭建方法" class="headerlink" title="4、 一般的搭建方法"></a>4、 一般的搭建方法</h3><p>　　在上面，我们已经配置好了所需的所有东西，也成功地搭建了一个本地Hexo博客。现在，需要使用GitHub Pages搭建一个别人能够访问的Hexo博客。</p><h4 id="4-1-使用默认theme"><a href="#4-1-使用默认theme" class="headerlink" title="4.1 使用默认theme"></a>4.1 使用默认theme</h4><p>　我们继续使用上面的文件夹D:\Hexo（也可以新建一个文件夹重新生成），然后编辑该文件夹下的_config.yml。<br>　默认生成的_config.yml：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: http://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type:</span><br></pre></td></tr></table></figure></p><p>　修改后的_config.yml：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: 对应仓库的SSH地址（可以在GitHub对应的仓库中复制）</span><br><span class="line">  branch: 分支（User Pages为master，Project Pages为gh-pages）</span><br></pre></td></tr></table></figure></p><p>　为了能够使Hexo部署到GitHub上，需要安装一个插件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save  或者 $ cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>　执行下列指令即可完成部署：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br><span class="line">或者</span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure></p><p>　之后，可以通过在浏览器键入：username.github.io进行浏览。</p><h4 id="4-2-简介-blog-config-yml文件"><a href="#4-2-简介-blog-config-yml文件" class="headerlink" title="4.2 简介 blog/_config.yml文件"></a>4.2 简介 blog/_config.yml文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#博客名称</span><br><span class="line">title: 我的博客</span><br><span class="line">#副标题</span><br><span class="line">subtitle: 一天进步一点</span><br><span class="line">#简介</span><br><span class="line">description: 记录生活点滴</span><br><span class="line">#博客作者</span><br><span class="line">author: John Doe</span><br><span class="line">#博客语言</span><br><span class="line">language: zh-CN</span><br><span class="line">#时区</span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line">#博客地址,与申请的GitHub一致</span><br><span class="line">url: http:<span class="comment">//elfwalk.github.io</span></span><br><span class="line">root: /</span><br><span class="line">#博客链接格式</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: <span class="keyword">public</span></span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: <span class="number">0</span></span><br><span class="line">render_drafts: <span class="keyword">false</span></span><br><span class="line">post_asset_folder: <span class="keyword">false</span></span><br><span class="line">relative_link: <span class="keyword">false</span></span><br><span class="line">future: <span class="keyword">true</span></span><br><span class="line">highlight:</span><br><span class="line">  enable: <span class="keyword">true</span></span><br><span class="line">  line_number: <span class="keyword">true</span></span><br><span class="line">  auto_detect: <span class="keyword">true</span></span><br><span class="line">  tab_replace:</span><br><span class="line"></span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line">#日期格式</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line">#分页，每页文章数量</span><br><span class="line">per_page: <span class="number">10</span></span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line">#博客主题</span><br><span class="line">theme: landscape</span><br><span class="line"></span><br><span class="line">#发布设置</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  #elfwalk改为你的github用户名</span><br><span class="line">  repository: https:<span class="comment">//github.com/elfwalk/elfwalk.github.io.git</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h3 id="5、优化部署与管理-☆☆☆"><a href="#5、优化部署与管理-☆☆☆" class="headerlink" title="5、优化部署与管理(☆☆☆)"></a>5、优化部署与管理(☆☆☆)</h3><p>　　Hexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，就不可能了（除非你自己写html）。</p><p>　　其实，Hexo生成的网站文件中有.gitignore文件，因此它的本意也是想我们将Hexo生成的网站文件存放到GitHub上进行管理的（而不是用U盘或者云备份啦）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。</p><p>　　但是，如果每一个GitHub Pages都需要创建一个额外的仓库来存放Hexo网站文件，我感觉很麻烦（10个项目需要20个仓库(）。</p><p>　　所以，利用了分支！！！简单地说，每个想建立GitHub Pages的仓库，起码有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。</p><h4 id="5-1-搭建流程"><a href="#5-1-搭建流程" class="headerlink" title="5.1 搭建流程"></a>5.1 搭建流程</h4><pre><code>1. 创建仓库，username.github.io；2. 创建两个分支：master 与 hexo；3. 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；4. 使用git clone git@github.com:username/username.github.io.git拷贝仓库；5. 在本地username.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;6. 修改_config.yml中的deploy参数，分支应为master；7. 依次执行git add .;    git commit -m &quot;…&quot;;    git push origin hexo提交网站相关的文件；8. 执行hexo generate -d生成网站并部署到GitHub上。</code></pre><p>　　这样一来，在GitHub上的username.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。</p><h4 id="5-3-管理流程"><a href="#5-3-管理流程" class="headerlink" title="5.3 管理流程"></a>5.3 管理流程</h4><h5 id="5-3-1-日常修改"><a href="#5-3-1-日常修改" class="headerlink" title="5.3.1 日常修改"></a>5.3.1 日常修改</h5><p>　　1. 在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理：</p><pre><code>2. 依次执行git add .git;  commit -m &quot;…&quot;;   git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；3. 然后才执行hexo generate -d发布网站到master分支上。</code></pre><h5 id="5-3-２本地资料丢失"><a href="#5-3-２本地资料丢失" class="headerlink" title="5.3.２本地资料丢失"></a>5.3.２本地资料丢失</h5><p>当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</p><pre><code>1. 使用git clone git@github.com:username/username.github.io.git拷贝仓库（默认分支为hexo）；2. 在本地新拷贝的username.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;　　备忘通过Hexo实现从md文件生成静态页面，然后发布到GitHub Pages的过程。&lt;/p&gt;
&lt;h2 id=&quot;主要流程&quot;&gt;&lt;a href=&quot;#主要流程&quot; class=&quot;headerlink&quot; title=&quot;主要流程&quot;&gt;&lt;/a&gt;主要流程&lt;/h2&gt;&lt;h3 id=&quot;1、安装必须的软件&quot;&gt;&lt;a href=&quot;#1、安装必须的软件&quot; class=&quot;headerlink&quot; title=&quot;1、安装必须的软件&quot;&gt;&lt;/a&gt;1、安装必须的软件&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;安装Git&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://git-scm.com/download/win&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Git官方版本的安装&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安装Node.js&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Node.js官方版本的安装&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装Hexo&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;常规安装命令&lt;br&gt;&lt;br&gt;$ npm install -g hexo-cli&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;常规命令有可能被“墙”，安装hexo为了避免出现类似情况，我使用&lt;a href=&quot;https://npm.taobao.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;淘宝NPM镜像&lt;/a&gt;,输入以下命令等待安装完成。&lt;br&gt;&lt;br&gt;$ npm install -g cnpm –registry=&lt;a href=&quot;https://registry.npm.taobao.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://registry.npm.taobao.org&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用淘宝NPM安装Hexo。&lt;br&gt;&lt;br&gt;$ cnpm install -g hexo-cli   （与原先的npm完全一样，只是命令改为cnpm,一样等待hexo安装完成），出现的WARN可以不用理会，继续输入以下命令：&lt;br&gt;$ cnpm install hexo –save&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Work Begin</title>
    <link href="http://yoursite.com/2018/04/07/WorkBegin/"/>
    <id>http://yoursite.com/2018/04/07/WorkBegin/</id>
    <published>2018-04-07T15:09:00.000Z</published>
    <updated>2018-09-02T08:50:18.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Work-Begin"><a href="#Work-Begin" class="headerlink" title="Work Begin"></a>Work Begin</h1><h2 id="Work-hard-and-start-recording-your-knowledge-every-day-Don’t-forget-to-improve-your-professional-knowledge-in-your-work"><a href="#Work-hard-and-start-recording-your-knowledge-every-day-Don’t-forget-to-improve-your-professional-knowledge-in-your-work" class="headerlink" title="Work hard and start recording your knowledge every day. Don’t forget to improve your professional knowledge in your work."></a>Work hard and start recording your knowledge every day. Don’t forget to improve your professional knowledge in your work.</h2><h2 id="Need-Work…"><a href="#Need-Work…" class="headerlink" title="Need Work…"></a>Need Work…</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Work-Begin&quot;&gt;&lt;a href=&quot;#Work-Begin&quot; class=&quot;headerlink&quot; title=&quot;Work Begin&quot;&gt;&lt;/a&gt;Work Begin&lt;/h1&gt;&lt;h2 id=&quot;Work-hard-and-start-recording-you
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>225. Implement Stack using Queues</title>
    <link href="http://yoursite.com/2017/08/31/225-Implement-Stack-using-Queues/"/>
    <id>http://yoursite.com/2017/08/31/225-Implement-Stack-using-Queues/</id>
    <published>2017-08-31T15:17:29.000Z</published>
    <updated>2018-04-07T14:44:08.725Z</updated>
    
    <content type="html"><![CDATA[<p>Implement the following operations of a stack using queues.</p><p>push(x) –Push element x onto stack.<br>pop() –Removes the element on top of the stack.<br>top() –Get the top element.<br>empty() –Return whether the stack is empty.</p><p>Notes:<br>You must use only standard operations of a queue – which means only push to back, peek / pop from front, size, and is empty operations are valid.<br>Depending on your language, queue may not be supported natively.You may simulate a queue by using a list or deque(double - ended queue), as long as you use only standard operations of a queue.<br>You may assume that all operations are valid(for example, no pop or top operations will be called on an empty stack).</p><a id="more"></a><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　使用队列实现堆栈的push(x) ，pop()，top()，empty()操作。<br>　　只能使用一个队列的标准操作 - 这意味着只能从前面，后面，peek / pop从前面，大小，并且是空的操作是有效的。<br>根据您的语言，队列可能不被本机支持。您可以使用列表或deque（双端队列）来模拟队列，只要您仅使用队列的标准操作即可。可以假设所有操作都有效（例如，在空堆栈上不会调用pop或top操作）。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="　方法一："></a>　方法一：</h3><p>　　用两个队列模拟一个堆栈：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">队列a和b</span><br><span class="line"> （<span class="number">1</span>）取栈顶元素： 返回有元素的队列的首元素</span><br><span class="line"> （<span class="number">2</span>）判栈空：若队列a和b均为空则栈空</span><br><span class="line"> （<span class="number">3</span>）入栈：a队列当前有元素，b为空（倒过来也一样）则将需要入栈的元素先放b中，然后将a中的元素依次出队列并入列倒b中。（保证有一个队列是空的）</span><br><span class="line"> （<span class="number">4</span>）出栈：将有元素的队列出列即可。</span><br><span class="line">比如先将<span class="number">1</span>插入队a中 ，现在要将<span class="number">2</span>入栈，则将<span class="number">2</span>插入b中然后将a中的<span class="number">1</span>出列入到b中，b中的元素变为 <span class="number">2</span> ，<span class="number">1</span></span><br><span class="line">a为空，现在要压入<span class="number">3</span> 则将<span class="number">3</span>插入a中 ，依次将b中的<span class="number">2</span> ，<span class="number">1</span> 出列并加入倒a中 ，a中的元素变为 <span class="number">3</span>，<span class="number">2</span>，<span class="number">1</span> b为空</span><br><span class="line">注意：算法保证在任何时候都有一队列为空</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Push element x onto stack.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (q1.empty())</span><br><span class="line">&#123;</span><br><span class="line">q1.push(x);</span><br><span class="line"><span class="keyword">while</span> (!q2.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = q2.front();</span><br><span class="line">q2.pop();</span><br><span class="line">q1.push(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">q2.push(x);</span><br><span class="line"><span class="keyword">while</span> (!q1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = q1.front();</span><br><span class="line">q1.pop();</span><br><span class="line">q2.push(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Removes the element on top of the stack.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!q1.empty())</span><br><span class="line">q1.pop();</span><br><span class="line"><span class="keyword">if</span> (!q2.empty())</span><br><span class="line">q2.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the top element.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!q1.empty())</span><br><span class="line"><span class="keyword">return</span> q1.front();</span><br><span class="line"><span class="keyword">if</span> (!q2.empty())</span><br><span class="line"><span class="keyword">return</span>q2.front();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return whether the stack is empty.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span>q1.empty()&amp;&amp;q2.empty();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="　方法二："></a>　方法二：</h3><p>　　 利用双端队列，实现代码简单，但是不懂原理，效率低，真正要学习的是两个队列实现栈，以及两个栈实现队列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Push element x onto stack.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">res.push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Removes the element on top of the stack.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">res.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the top element.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> res.back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return whether the stack is empty.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span>res.empty();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Implement the following operations of a stack using queues.&lt;/p&gt;
&lt;p&gt;push(x) –Push element x onto stack.&lt;br&gt;pop() –Removes the element on top of the stack.&lt;br&gt;top() –Get the top element.&lt;br&gt;empty() –Return whether the stack is empty.&lt;/p&gt;
&lt;p&gt;Notes:&lt;br&gt;You must use only standard operations of a queue – which means only push to back, peek / pop from front, size, and is empty operations are valid.&lt;br&gt;Depending on your language, queue may not be supported natively.You may simulate a queue by using a list or deque(double - ended queue), as long as you use only standard operations of a queue.&lt;br&gt;You may assume that all operations are valid(for example, no pop or top operations will be called on an empty stack).&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>224. Basic Calculator</title>
    <link href="http://yoursite.com/2017/08/31/224-Basic-Calculator/"/>
    <id>http://yoursite.com/2017/08/31/224-Basic-Calculator/</id>
    <published>2017-08-31T14:30:03.000Z</published>
    <updated>2018-04-07T14:44:08.725Z</updated>
    
    <content type="html"><![CDATA[<p>Implement a basic calculator to evaluate a simple expression string.<br>he expression string may contain open(and closing parentheses), the plus + or minus sign - , non - negative integers and empty spaces .</p><p>You may assume that the given expression is always valid.<br>Some examples :<br>“1 + 1” = 2<br>“ 2-1 + 2 “ = 3<br>“(1+(4+5+2)-3)+(6+8)” = 23</p><a id="more"></a><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　实现基本的计算器来计算一个简单的表达式字符串，表达式字符串可能包含打开“（”和闭括号“）”，加号或减号，非负整数和空格。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="　方法一："></a>　方法一：</h3><p>　　两个要点：<br>　　　　1、无括号时，顺序执行<br>　　　　2、有括号时，先执行括号中的<br>　　两个栈：<br>　　　　一个存放操作数，每次进栈要注意，如果操作符栈顶元素为’+’/‘-‘，则需要立即计算。<br>　　　　一个存放操作符（包括括号），每次出现’)’时，不断进行出栈计算再进栈，直到弹出’(‘，说明当前括号内计算完毕。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; num;<span class="comment">//存放操作数</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; op;<span class="comment">//存放操作符</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; s.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; s.size() &amp;&amp; s[i] == <span class="string">' '</span>)<span class="comment">//跳过字符串中的空格字符</span></span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (i == s.size())</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">'+'</span> || s[i] == <span class="string">'-'</span> || s[i] == <span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line">op.push(s[i]);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">')'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (op.top() != <span class="string">'('</span>)</span><br><span class="line">&#123;<span class="comment">// calculation within parentheses </span></span><br><span class="line"><span class="keyword">int</span> n2 = num.top();</span><br><span class="line">num.pop();</span><br><span class="line"><span class="keyword">int</span> n1 = num.top();</span><br><span class="line">num.pop();</span><br><span class="line"><span class="keyword">if</span> (op.top() == <span class="string">'+'</span>)</span><br><span class="line">num.push(n1 + n2);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">num.push(n1 - n2);</span><br><span class="line">op.pop();</span><br><span class="line">&#125;</span><br><span class="line">op.pop();</span><br><span class="line"><span class="keyword">while</span> (!op.empty() &amp;&amp; op.top() != <span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n2 = num.top();</span><br><span class="line">num.pop();</span><br><span class="line"><span class="keyword">int</span> n1 = num.top();</span><br><span class="line">num.pop();</span><br><span class="line"><span class="keyword">if</span> (op.top() == <span class="string">'+'</span>)</span><br><span class="line">num.push(n1 + n2);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">num.push(n1 - n2);</span><br><span class="line">op.pop();</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; s.size() &amp;&amp; s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">n = n * <span class="number">10</span> + (s[i] - <span class="string">'0'</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">num.push(n);</span><br><span class="line"><span class="keyword">while</span> (!op.empty() &amp;&amp; op.top() != <span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n2 = num.top();</span><br><span class="line">num.pop();</span><br><span class="line"><span class="keyword">int</span> n1 = num.top();</span><br><span class="line">num.pop();</span><br><span class="line"><span class="keyword">if</span> (op.top() == <span class="string">'+'</span>)</span><br><span class="line">num.push(n1 + n2);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">num.push(n1 - n2);</span><br><span class="line">op.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num.top();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="　方法二："></a>　方法二：</h3><p>　　由于表达式中只含有括号和加减法运算，我们可以通过加减法的规律对表达式进行化简，，因为只有加减，去括号的话只会影响括号内部的符号变换，表达式都是从左到右依次执行的，然后求值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">num.push(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">char</span> op = <span class="string">'+'</span>;</span><br><span class="line"><span class="keyword">long</span> re = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">switch</span> (s[i]) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">op = s[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">num.push(num.top() * (op == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>));</span><br><span class="line">op = <span class="string">'+'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">num.pop();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">tmp = tmp * <span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">i--;</span><br><span class="line">re += (op == <span class="string">'-'</span> ? <span class="number">-1</span> : <span class="number">1</span>)*num.top()*tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法三："><a href="#方法三：" class="headerlink" title="　方法三："></a>　方法三：</h3><p>　　通用性代码，可以包含乘除，加括号等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculates5</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1、把表达式去掉空格存到队列中</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; que;<span class="comment">//存放表达式序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>str = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">switch</span> (s[i])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                str = s[i];</span><br><span class="line">                que.push(str);</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">while</span> (i&lt;s.size()&amp;&amp;s[i]&gt;=<span class="string">'0'</span>&amp;&amp;s[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    str += s[i];</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                que.push(str);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、把中缀表达式转换为后缀表达式</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; stackA;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; stackB;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> temp = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">char</span> op = temp.at(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (op==<span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stackB.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (op==<span class="string">')'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stackB.empty() &amp;&amp; stackB.top() != <span class="string">"("</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    stackA.push(stackB.top());</span><br><span class="line">                    stackB.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!stackB.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    stackB.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (op==<span class="string">'+'</span> || op ==<span class="string">'-'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (stackB.empty() || stackB.top()==<span class="string">"("</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    stackB.push(temp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!stackB.empty()&amp;&amp;stackB.top()!=<span class="string">"("</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        stackA.push(stackB.top());</span><br><span class="line">                        stackB.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    stackB.push(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                stackA.push(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stackB.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            stackA.push(stackB.top());</span><br><span class="line">            stackB.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stackA.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            stackB.push(stackA.top());</span><br><span class="line">            stackA.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、通过后缀表达式进行计算</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!stackB.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">string</span> temp = stackB.top();</span><br><span class="line">            stackB.pop();</span><br><span class="line">            <span class="keyword">char</span> op = temp.at(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">switch</span> (op)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                res = result.top();</span><br><span class="line">                result.pop();</span><br><span class="line">                res += result.top();</span><br><span class="line">                result.pop();</span><br><span class="line">                result.push(res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                res = result.top();</span><br><span class="line">                result.pop();</span><br><span class="line">                res = result.top() - res;</span><br><span class="line">                result.pop();</span><br><span class="line">                result.push(res);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                result.push(atoi(temp.c_str()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Implement a basic calculator to evaluate a simple expression string.&lt;br&gt;he expression string may contain open(and closing parentheses), the plus + or minus sign - , non - negative integers and empty spaces .&lt;/p&gt;
&lt;p&gt;You may assume that the given expression is always valid.&lt;br&gt;Some examples :&lt;br&gt;“1 + 1” = 2&lt;br&gt;“ 2-1 + 2 “ = 3&lt;br&gt;“(1+(4+5+2)-3)+(6+8)” = 23&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>222. Count Complete Tree Nodes</title>
    <link href="http://yoursite.com/2017/08/31/222-Count-Complete-Tree-Nodes/"/>
    <id>http://yoursite.com/2017/08/31/222-Count-Complete-Tree-Nodes/</id>
    <published>2017-08-31T13:59:31.000Z</published>
    <updated>2018-04-07T14:44:08.725Z</updated>
    
    <content type="html"><![CDATA[<p>Given a complete binary tree, count the number of nodes.</p><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　给定一棵完全二叉树，求树种节点的个数。</p><a id="more"></a><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>　　如果用常规的解法一个个遍历，就是O(n)时间复杂度 ，不通过。因为是完全二叉树，满二叉树有一个性质是节点数等于2^h-1，h为高度，所以可以这样判断节点的左右高度是不是一样，如果是一样说明是满二叉树，就可以用刚才的公式，如果左右不相等就递归计算左右节点。</p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="　方法一："></a>　方法一：</h3><p>　　若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。根据完全二叉树的这个性质，可以这样来求解完全二叉树中节点的个数。对于一个节点node，计算它最左端的节点到node的深度为leftDepth，计算它最右端的节点到node的深度是rightDepth；如果leftDepth和rightDepth相等，那么以node为根节点的树是一棵满二叉树，此时以node为根节点的树的节点个数是pow(2,leftDepth)-1；如果leftDepth和rightDepth不相等，递归求解node的左子树的节点数和右子树的节点数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depthLeft</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (root)</span><br><span class="line">&#123;</span><br><span class="line">root = root-&gt;left;</span><br><span class="line">height++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depthRight</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (root)</span><br><span class="line">&#123;</span><br><span class="line">root = root-&gt;right;</span><br><span class="line">height++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ld = depthLeft(root);</span><br><span class="line"><span class="keyword">int</span> rd = depthRight(root);</span><br><span class="line"><span class="keyword">if</span> (ld == rd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> lnum = <span class="built_in">pow</span>(<span class="number">2</span>,ld) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> lnum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> countNodes(root-&gt;left) + countNodes(root-&gt;right) + <span class="number">1</span>;<span class="comment">//最后加一加的是根节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="　方法二："></a>　方法二：</h3><p>　　也是比较左右子树的高度是否相等，如果左子树等于右子树的高度（都按左子树计算高度，因为完全二叉树的高度由左子树的高度确定的）则左子树肯定是完全二叉树，右子树再递归判读，如果左子树不等于右子树高度，右子树肯定是完全二叉树，左子树再递归判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (root)</span><br><span class="line">&#123;</span><br><span class="line">root = root-&gt;left;</span><br><span class="line">height++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ld = depth(root-&gt;left);</span><br><span class="line"><span class="keyword">int</span> rd = depth(root-&gt;right);</span><br><span class="line"><span class="keyword">if</span> (ld==rd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, ld) + countNodes(root-&gt;right);</span><br><span class="line">   <span class="comment">/* int lnum = (2 &lt;&lt; (ld - 1)) + countNodes(root-&gt;left);//当层数是0的时候左移公式出现问题</span></span><br><span class="line"><span class="comment">return lnum;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, rd) + countNodes(root-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a complete binary tree, count the number of nodes.&lt;/p&gt;
&lt;h2 id=&quot;题意：&quot;&gt;&lt;a href=&quot;#题意：&quot; class=&quot;headerlink&quot; title=&quot;题意：&quot;&gt;&lt;/a&gt;题意：&lt;/h2&gt;&lt;p&gt;　　给定一棵完全二叉树，求树种节点的个数。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>219. Contains Duplicate II</title>
    <link href="http://yoursite.com/2017/08/30/219-Contains-Duplicate-II/"/>
    <id>http://yoursite.com/2017/08/30/219-Contains-Duplicate-II/</id>
    <published>2017-08-30T15:18:27.000Z</published>
    <updated>2018-04-07T14:44:08.725Z</updated>
    
    <content type="html"><![CDATA[<p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array<br>such that nums[i] = nums[j] and the difference between i and j is at most k.</p><a id="more"></a><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　给定整数数组和整数k，找出数组中是否有两个不同的索引i和j，使得nums [i] = nums [j]，i和j之间的差最多为k。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>　　利用hash表，key为元素值，value为此元素所对应的索引的集合，遍历元素组，把相同元素的索引都放入到对应hash表的value集合中，然后遍历hash表，找出集合大小大于1的value集合，遍历此集合，求出相同元素索引间最小距离。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; hash;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">hash[nums[i]].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> itr = hash.begin();itr!=hash.end();itr++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (itr-&gt;second.size()&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> minIndex = INT_MAX;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; itr-&gt;second.size(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> m = j - <span class="number">1</span>;</span><br><span class="line">minIndex = min(minIndex, itr-&gt;second[j] - itr-&gt;second[m]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (minIndex&lt;=k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="　方法二："></a>　方法二：</h3><p>　　思路同方法一，利用hash表，不同点是一边遍历数组，一边在hash表对应的索引值进行相减比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> itr = hash.find(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (itr != hash.end())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - itr-&gt;second &lt;= k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    hash.erase(itr);</span><br><span class="line">            &#125;</span><br><span class="line">            hash[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array&lt;br&gt;such that nums[i] = nums[j] and the difference between i and j is at most k.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>216. Combination Sum III</title>
    <link href="http://yoursite.com/2017/08/30/216-Combination-Sum-III/"/>
    <id>http://yoursite.com/2017/08/30/216-Combination-Sum-III/</id>
    <published>2017-08-30T15:03:47.000Z</published>
    <updated>2018-04-07T14:44:08.710Z</updated>
    
    <content type="html"><![CDATA[<p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p><p>Example 1:<br>Input: k = 3, n = 7<br>Output:<br>[[1,2,4]]</p><p>Example 2:<br>Input: k = 3, n = 9<br>Output:<br>[[1,2,6], [1,3,5], [2,3,4]]</p><a id="more"></a><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　找到所有可能的k个数字的组合，其总和为n，因为只能使用从1到9的数字，并且每个组合应该是唯一的数字集合。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>　　典型的递归回溯题，需要找出所有的k个数的和等于n的组合，所以要求出所有情况，并且组合中没有重复元素，结果集中k个数的集合也是唯一的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;<span class="comment">//存放k个数的所有组合</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sumNum;</span><br><span class="line">    backtracking(n, k, <span class="number">1</span>,sumNum);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> counts, <span class="keyword">int</span> index, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sumNum)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (target==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (counts==<span class="number">0</span>)<span class="comment">//满足这两个if条件才能放入结果集</span></span><br><span class="line">&#123;</span><br><span class="line">res.push_back(sumNum);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; <span class="number">10</span>; i++)<span class="comment">//i是1到9，所以直接设定上界为10</span></span><br><span class="line">&#123;</span><br><span class="line">sumNum.push_back(i);</span><br><span class="line">backtracking(target-i, counts<span class="number">-1</span>,i + <span class="number">1</span>, sumNum);<span class="comment">//因为子数组不存在重复元素，所以index递增1</span></span><br><span class="line">sumNum.pop_back();<span class="comment">//递归回溯把之前进入子数组集的元素弹出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;Input: k = 3, n = 7&lt;br&gt;Output:&lt;br&gt;[[1,2,4]]&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;Input: k = 3, n = 9&lt;br&gt;Output:&lt;br&gt;[[1,2,6], [1,3,5], [2,3,4]]&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>215. Kth Largest Element in an Array</title>
    <link href="http://yoursite.com/2017/08/30/215-Kth-Largest-Element-in-an-Array/"/>
    <id>http://yoursite.com/2017/08/30/215-Kth-Largest-Element-in-an-Array/</id>
    <published>2017-08-30T14:40:46.000Z</published>
    <updated>2018-04-07T14:44:08.710Z</updated>
    
    <content type="html"><![CDATA[<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>For example,<br>Given [3,2,1,5,6,4] and k = 2, return 5.</p><p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><a id="more"></a><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　查找未排序数组中的第k个最大元素。 请注意，它是排序顺序中的第k个最大元素，而不是第k个不同的元素。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>　　题意要理解：第k大的元素时从最大边开始数起，最大的为第一大，次大的为第二大。。。。<br>　　　　　　　　378题的第k小的元素时从最小边开始数起，最小的为第一小，次小的为第二小。。。</p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="　方法一："></a>　方法一：</h3><p>　　利用优先队列做，也就是建立最小堆（或者最大堆）来求第k大的元素。<a href="http://www.cplusplus.com/reference/queue/priority_queue/?kw=priority_queue" target="_blank" rel="noopener">priority_queue容器详解</a> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//最小堆的实现</span></span><br><span class="line"><span class="comment">//priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; queMin;//functional</span></span><br><span class="line"><span class="comment">//for (auto n : nums)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//queMin.push(n);</span></span><br><span class="line"><span class="comment">//if (queMin.size()&gt;k)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//queMin.pop();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//return queMin.top();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最大堆的实现</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; queMax;<span class="comment">//== priority_queue&lt;int&gt; queMax   默认构建最大堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> n : nums)</span><br><span class="line">&#123;</span><br><span class="line">queMax.push(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (k&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">queMax.pop();</span><br><span class="line">k--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> queMax.top();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="　方法二："></a>　方法二：</h3><p>　　直接利用c++的STL库nth_element。<a href="http://www.cplusplus.com/reference/algorithm/nth_element/?kw=nth_element" target="_blank" rel="noopener">nth_element函数详解</a> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">nth_element(nums.begin(), nums.begin() + k, nums.end());</span><br><span class="line"><span class="keyword">return</span> *(nums.begin() + k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法三："><a href="#方法三：" class="headerlink" title="　方法三："></a>　方法三：</h3><p>　　利用QuickSelect的方法实现方法二的查找第k个元素的方法，快速查找的思想和快排相同，快排具体详解见<a href="http://blog.taoaili999.cn/2017/06/20/QuickSort-implement-with-C++/" target="_blank" rel="noopener">快排实现</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">quickSelect(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>, nums.size()-k);<span class="comment">//因为下面排序是从小到大，所以找nums.size()-k处元素</span></span><br><span class="line"><span class="keyword">return</span> nums[nums.size()-k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> keyVal = nums[height];</span><br><span class="line"><span class="keyword">int</span> i = low - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (low&lt;height)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[low]&lt;keyVal)</span><br><span class="line">&#123;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line">swap(nums[i], nums[low]);</span><br><span class="line">&#125;</span><br><span class="line">low++;</span><br><span class="line">&#125;</span><br><span class="line">swap(nums[i + <span class="number">1</span>], nums[height]);</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">quickSelect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> low,<span class="keyword">int</span> height, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k&lt;low||k&gt;height)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//三元区中项的思想优化快选中项</span></span><br><span class="line"><span class="keyword">int</span> mid = (low + height) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[low]&gt;nums[height])</span><br><span class="line">&#123;</span><br><span class="line">swap(nums[low], nums[height]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nums[mid]&gt;nums[height])</span><br><span class="line">&#123;</span><br><span class="line">swap(nums[mid], nums[height]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nums[low] &gt; nums[mid])</span><br><span class="line">&#123;</span><br><span class="line">swap(nums[mid], nums[low]);</span><br><span class="line">&#125;</span><br><span class="line">swap(nums[mid], nums[height]);</span><br><span class="line"><span class="keyword">int</span> par = getPartition(nums, low, height);</span><br><span class="line"><span class="keyword">if</span> (k==par)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k &lt; par)</span><br><span class="line">&#123;</span><br><span class="line">quickSelect(nums, low, par<span class="number">-1</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">quickSelect(nums, par+<span class="number">1</span>, height, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given [3,2,1,5,6,4] and k = 2, return 5.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You may assume k is always valid, 1 ≤ k ≤ array’s length.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>214. Shortest Palindrome</title>
    <link href="http://yoursite.com/2017/08/29/214-Shortest-Palindrome/"/>
    <id>http://yoursite.com/2017/08/29/214-Shortest-Palindrome/</id>
    <published>2017-08-29T14:45:54.000Z</published>
    <updated>2018-04-07T14:44:08.710Z</updated>
    
    <content type="html"><![CDATA[<p>Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.</p><p>For example:<br>Given “aacecaaa”, return “aaacecaaa”.<br>Given “abcd”, return “dcbabcd”.</p><a id="more"></a><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　 给定一个字符串，在字符串的前面添加字符将它转换成一个回文串。找到并返回可以通过执行这个变化后转换的最短回文串。 </p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="　方法一："></a>　方法一：</h3><p>　　在s前面添加字符串出现最短的回文串，就是找到距离第一个元素最近的对称点，左侧形成对称的话，如果右侧还有元素存在，只需反转加到s的前面即可。   其中更加注意的一点就是：对称的对称轴元素可能为一个，也可能为两个。<br>　　从某个char开始向两边扩展(左右两边的字符相等), 如果能一直扩展到字符串的头部, 则将末尾余下的reverse,再加到原字符串的头部。</p><ol><li>中轴字符选从中间开始,这样找到的即为最短的. </li><li>中轴字符可能为一个, 也可能为两个.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此法效率不是很高</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sLen = s.size();</span><br><span class="line"><span class="keyword">if</span> (sLen &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line"><span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">int</span> center = sLen / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = center; i &gt;= <span class="number">0</span>; i--)<span class="comment">//从中间往左边查找对称点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s[i]==s[i+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">res = isPalindrome(s, i, i+<span class="number">1</span>);<span class="comment">//偶数的情况</span></span><br><span class="line"><span class="keyword">if</span> (res!=<span class="string">"#"</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//else//切记此处不是else，也就是说，可能即使s[i]==s[i+1]的情况也会出现奇数个的情况,例如：aaaaa</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line">res = isPalindrome(s, i, i);<span class="comment">//奇数的情况</span></span><br><span class="line"><span class="keyword">if</span> (res != <span class="string">"#"</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//i表示从中间元素向两边扩展的距离</span></span><br><span class="line"><span class="keyword">for</span> (; l - i &gt;= <span class="number">0</span> &amp;&amp; r + i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[l - i] != s[r + i]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l - i &gt;= <span class="number">0</span>)<span class="comment">//说明不是最靠近左侧的对称点，返回#标识 </span></span><br><span class="line">          <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line"><span class="built_in">string</span> tempStr = s.substr(r + i);</span><br><span class="line">reverse(tempStr.begin(), tempStr.end());</span><br><span class="line">s = tempStr + s;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="　方法二："></a>　方法二：</h3><p>　　下面的算法主要依据KMP算法，实现主串和模式串的匹配，其中主串是s的反转串，模式串是s。用kmp字符串匹配算法就可以完美地完成O(n)复杂度的算法。只需对kmp做一点点调整：<br>　　　判断匹配结束的时机：是reverse_s串匹配到了尾部，且匹配成功。<br>　　　用mark记录匹配到结尾时s串的下标位置：为了从s串尾部截取子串接到reverse_s后形成回文字符串。<br>　　　如何保证最短：由于第一次成功匹配到reverse_s尾部后就结束循环，此时的mark标记的位置所形成的回文段（字符串s从0到mark下标所形成的子串）应该是最长的。<br>　　使用c++自带stl函数：reverse操作，substr操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sLen = s.size();</span><br><span class="line"><span class="keyword">if</span> (sLen &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line"><span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">reverse_s</span><span class="params">(s)</span></span>;</span><br><span class="line">reverse(reverse_s.begin(), reverse_s.end());</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(sLen, <span class="number">0</span>);</span><br><span class="line">getNext(s, next);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>,mark = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i&lt;sLen&amp;&amp;j&lt;sLen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span>|| reverse_s[i] == s[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">if</span> (i == sLen)</span><br><span class="line">&#123;</span><br><span class="line">mark = j;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res = mark == sLen ? s : reverse_s + s.substr(mark);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求模式串的next数组的方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;next)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sLen = s.size();</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (j&lt;sLen<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">-1</span> || s[k] == s[j])</span><br><span class="line">&#123;</span><br><span class="line">k++;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">if</span> (s[k] == s[j])</span><br><span class="line">&#123;</span><br><span class="line">next[j] = next[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">next[j] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">k = next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法三："><a href="#方法三：" class="headerlink" title="　方法三："></a>　方法三：</h3><p>　　思路：让在前面补一些字符使得给定的字符串变成回文，观察可以发现我们需要添加多少个字符与给定字符串的前缀子串回文的长度有关．也就是说去掉其前缀的回文子串，我们只需要补充剩下的子串的逆序就行了。</p><p>　　举个例子：<br>　　　aacecaaa，其前缀的最大回文子串是aacecaa，剩下了一个a，因此我们只需要在前面加上一个a的逆序a就行了．再例如abcd，其前缀的最大回文是a，因此剩下的子串就为bcd，所以需要在前面加上bcd的逆序，就变成了dcbabcd．所以这样问题就转化为求字符串的前缀最大回文长度．</p><p>　　一个naive的方法是先判断整个字符串是否回文，否的话再判断前n-1个子串是否回文，这样依次缩减长度，直到找到一个回文子串就是最大的前缀回文子串．这种方法简单粗暴，容易理解和实现，如果在面试中要求不是很严格的情况下说不定可以过关, 反正总比不会好点^.^．其时间复杂度是O(n!)．</p><p>　　KMP，这是一个非常高效的字符串比较算法．其原理是给定一个字符串S和P，要在S中寻找是否存在P，一般的方法是逐位比较，如果不能完全匹配，则S再回到开始位置向右移动一位，P回到0位置再开始比较．在KMP中不需要回到首部重新开始比较，借助与记录从P的开头到当前位置P中的前缀和后缀有多少位是相等的，这样当P和S比较的时候如果P[i] != S[j]了，不需要回到P[0]的位置重新比较，我们可以查看P中已经匹配过的子串中（也就是P[0, i-1]子串）前缀和后缀有多少位是相等的，然后将P的前缀和已经S[j]之前的后缀是匹配的，就可以不用回溯S了．所以借助与KMP记录最长前缀和后缀的方法，我们可以将原字符串翻转以后加在原字符串的后面，其最大的前缀和后缀就是前缀的最大回文长度．我们还需要在这两个字符串之间加一个冗余字符，因为形如aaaaa这种字符串如果不加一个冗余字符最大前缀和后缀会变大．</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//效率高，但是不太理解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">shortestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sLen = s.size();</span><br><span class="line"><span class="keyword">if</span> (sLen &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line"><span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">reverse_s</span><span class="params">(s)</span></span>;</span><br><span class="line">reverse(reverse_s.begin(), reverse_s.end());</span><br><span class="line"><span class="built_in">string</span> str = s + <span class="string">"#"</span> + reverse_s;</span><br><span class="line"><span class="keyword">int</span> strLen = str.size();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxPalindromeVec(strLen, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;strLen;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> k = maxPalindromeVec[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (k&gt;<span class="number">0</span>&amp;&amp;str[k]!=str[i])</span><br><span class="line">&#123;</span><br><span class="line">k = maxPalindromeVec[k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">maxPalindromeVec[i] = (k += str[k] == str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str.substr(sLen + <span class="number">1</span>, sLen - maxPalindromeVec[strLen - <span class="number">1</span>]) + s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given “aacecaaa”, return “aaacecaaa”.&lt;br&gt;Given “abcd”, return “dcbabcd”.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>209. Minimum Size Subarray Sum</title>
    <link href="http://yoursite.com/2017/08/28/209-Minimum-Size-Subarray-Sum/"/>
    <id>http://yoursite.com/2017/08/28/209-Minimum-Size-Subarray-Sum/</id>
    <published>2017-08-28T15:03:24.000Z</published>
    <updated>2018-04-07T14:44:08.710Z</updated>
    
    <content type="html"><![CDATA[<p>Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p><p>For example, given the array [2,3,1,2,4,3] and s = 7,<br>the subarray [4,3] has the minimal length under the problem constraint.<br><a id="more"></a></p><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　给定含有n个正整数的数组和一个正整数，求最小长度的子数组，使子数组的和sum ≥ s，如果不存在这样的子数组，返回0。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="　方法一："></a>　方法一：</h3><p>　　利用滑动窗口机制，用两个指针来维持和的最大值，然后求最小子数组长度。pre和last指针之间维持着大于s的和的子数组，通过减小和扩大滑动窗口大小，来实现查找对小的和大于s的子数组，时间复杂度是O(n)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = nums.size();</span><br><span class="line"><span class="keyword">if</span> (len==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">0</span>, last = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> minLen = INT_MAX;</span><br><span class="line"><span class="keyword">int</span> sum = nums[pre];</span><br><span class="line"><span class="keyword">while</span> (pre&lt;len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sum&lt;s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pre == len<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pre++;<span class="comment">//移动滑动窗口前指针</span></span><br><span class="line">sum += nums[pre];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> dis = pre - last + <span class="number">1</span>;</span><br><span class="line">minLen = min(minLen, dis);</span><br><span class="line">sum -= nums[last];</span><br><span class="line">last++;<span class="comment">//移动滑动窗口后指针</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> minLen==INT_MAX?res:minLen;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="　方法二："></a>　方法二：</h3><p>　　时间复杂度是O(nlogn)的算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Now let&apos;s move on to the O(nlogn) solution. Well, this less efficient solution is far more difficult to come up with. The idea is to first maintain an array of accumulated summations of elements in nums. Specifically, for nums = [2, 3, 1, 2, 4, 3] in the problem statement, sums = [0, 2, 5, 6, 8, 12, 15]. Then for each element in sums, if it is not less than s, we search for the first element that is greater than sums[i] - s (in fact, this is just what the upper_bound function does) in sums using binary search.</span><br><span class="line"></span><br><span class="line">Let&apos;s do an example. Suppose we reach 12 in sums, which is greater than s = 7. We then search for the first element in sums that is greater than sums[i] - s = 12 - 7 = 5 and we find 6. Then we know that the elements in nums that correspond to 6, 8, 12 sum to a number 12 - 5 = 7 which is not less than s = 7. Let&apos;s check for that: 6 in sums corresponds to 1 in nums, 8 in sums corresponds to 2 in nums, 12 in sums corresponds to 4 in nums. 1, 2, 4 sum to 7, which is 12 in sums minus 5 in sums.</span><br><span class="line"></span><br><span class="line">We add a 0 in the first position of sums to account for cases like nums = [3], s = 3.</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = nums.size();</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> minLen = INT_MAX;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sumNum(len + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">sumNum[i + <span class="number">1</span>] = sumNum[i] + nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> r = len;</span><br><span class="line"><span class="keyword">int</span> target = sumNum[i] + s;</span><br><span class="line"><span class="keyword">if</span> (target &gt; sumNum[r])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (target &lt; sumNum[l])</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (sumNum[mid] &lt; target)</span><br><span class="line">l = mid + <span class="number">1</span>;<span class="comment">//特别注意此处，当sumNum[mid] == target的时候坚决不能让mid+1，否则会造成元素多1个，只要大于等于target的时候一定躺r=mid,不要移动l</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">r = mid;</span><br><span class="line">&#125;</span><br><span class="line">minLen = min(minLen, l - i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> minLen == INT_MAX ? res : minLen;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead.&lt;/p&gt;
&lt;p&gt;For example, given the array [2,3,1,2,4,3] and s = 7,&lt;br&gt;the subarray [4,3] has the minimal length under the problem constraint.&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>206. Reverse Linked List</title>
    <link href="http://yoursite.com/2017/08/28/206-Reverse-Linked-List/"/>
    <id>http://yoursite.com/2017/08/28/206-Reverse-Linked-List/</id>
    <published>2017-08-28T14:47:11.000Z</published>
    <updated>2018-04-07T14:44:08.710Z</updated>
    
    <content type="html"><![CDATA[<p>Reverse a singly linked list.</p><p>Hint:<br>A linked list can be reversed either iteratively(迭代) or recursively(递归).Could you implement both ?</p><a id="more"></a><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　反向单向链表：把整个链表反转，，最后一个节点是头结点，其实就是完成单链表的反转。<br>　　同时用迭代和递归实现。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="　方法一："></a>　方法一：</h3><p>　　利用迭代，非递归实现，利用三个指针，分别记录当前节点，当前节点的下一个节点，以及下一个节点的下一个节点，用于反转断开链表后从新获取后面未反转单链的头结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">ListNode *p = head;</span><br><span class="line">ListNode *tempfirst = head-&gt;next;</span><br><span class="line">ListNode *tempsecond = tempfirst-&gt;next;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (tempfirst != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tempfirst-&gt;next = p;</span><br><span class="line"><span class="comment">//p-&gt;next = tempfirst;</span></span><br><span class="line">p = tempfirst;</span><br><span class="line">tempfirst = tempsecond;</span><br><span class="line"><span class="keyword">if</span> (tempsecond != <span class="literal">NULL</span>)</span><br><span class="line">tempsecond = tempsecond-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="　方法二："></a>　方法二：</h3><p>　　递归实现，递归前指针p指向头结点的下一个节点，head指向头结点，一直向下递归，直到链表尾部，就像入栈操作一样，先入栈的后出栈，当递归返回上一层时，p在head后面，直接修改next指向，完成节点反转，然后继续返回上一层，直到递归栈为空，从而实现所有节点的反转。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">NULL</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) </span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">ListNode *p = head-&gt;next;</span><br><span class="line">ListNode *n = reverseList(p);<span class="comment">//n指针一直指向反转后的头结点</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;next = head;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Reverse a singly linked list.&lt;/p&gt;
&lt;p&gt;Hint:&lt;br&gt;A linked list can be reversed either iteratively(迭代) or recursively(递归).Could you implement both ?&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>205. Isomorphic Strings</title>
    <link href="http://yoursite.com/2017/08/28/205-Isomorphic-Strings/"/>
    <id>http://yoursite.com/2017/08/28/205-Isomorphic-Strings/</id>
    <published>2017-08-28T14:31:53.000Z</published>
    <updated>2018-04-07T14:44:08.694Z</updated>
    
    <content type="html"><![CDATA[<p>Given two strings s and t, determine if they are isomorphic.<br>Two strings are isomorphic if the characters in s can be replaced to get t.</p><p>All occurrences of a character must be replaced with another character while preserving the order of characters.No two characters may map to the same character but a character may map to itself.</p><p>For example,<br>Given “egg”, “add”, return true.<br>Given “foo”, “bar”, return false.<br>Given “paper”, “title”, return true.<br>Note:<br>You may assume both s and t have the same length.</p><a id="more"></a><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　给定两个字符串S和T，确定两个字符串是否是同构的。<br>　　两个字符串是同构的，如果s中的字符可以通过替换转换为t。<br>　　所有字符的出现都必须用另一个字符替换，同时保留字符的顺序。没有两个字符可以映射到同一个字符，但一个字符可以映射其本身。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>　　核心就是建立映射表，把两个字符串中的字符相映射，判断两个字符串不是同构的根据是s中同一个字符映射t中两个不同的字符，或者t中同一个字符映射s中两个不同的字符，这样就会违反题目中定义的规则。如果遍历完两个字符串所有字符，没有出现上述情况，则两个字符串是同构字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Isomorphic(s,t)&amp;&amp;Isomorphic(t,s))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Isomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; hashmap;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (hashmap[s[i]])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (hashmap[s[i]] != t[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">hashmap[s[i]] = t[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given two strings s and t, determine if they are isomorphic.&lt;br&gt;Two strings are isomorphic if the characters in s can be replaced to get t.&lt;/p&gt;
&lt;p&gt;All occurrences of a character must be replaced with another character while preserving the order of characters.No two characters may map to the same character but a character may map to itself.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given “egg”, “add”, return true.&lt;br&gt;Given “foo”, “bar”, return false.&lt;br&gt;Given “paper”, “title”, return true.&lt;br&gt;Note:&lt;br&gt;You may assume both s and t have the same length.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>204. Count Primes</title>
    <link href="http://yoursite.com/2017/08/28/204-Count-Primes/"/>
    <id>http://yoursite.com/2017/08/28/204-Count-Primes/</id>
    <published>2017-08-28T13:53:09.000Z</published>
    <updated>2018-04-07T14:44:08.694Z</updated>
    
    <content type="html"><![CDATA[<p>Count the number of prime numbers less than a non - negative number, n.</p><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　计算小于n的非负数的质数的个数。</p><a id="more"></a><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><pre><code>1、  Let&apos;s start with a isPrime function. To determine if a number is prime, we need to check if it is not divisible by any number less than n. The runtime complexity of isPrime function would be O(n) and hence counting the total prime numbers up to n would be O(n2). Could we do better?2、  As we know the number must not be divisible by any number &gt; n / 2, we can immediately cut the total iterations half by dividing only up to n / 2. Could we still do better?3、  Let&apos;s write down all of 12&apos;s factors:    2 × 6 = 12    3 × 4 = 12    4 × 3 = 12    6 × 2 = 12As you can see, calculations of 4 × 3 and 6 × 2 are not necessary. Therefore, we only need to consider factors up to √n because, if n is divisible by some number p, then n = p × q and since p ≤ q, we could derive that p ≤ √n.Our total runtime has now improved to O(n1.5), which is slightly better. Is there a faster approach?public int countPrimes(int n) {   int count = 0;   for (int i = 1; i &lt; n; i++) {      if (isPrime(i)) count++;   }   return count;}private boolean isPrime(int num) {   if (num &lt;= 1) return false;   // Loop&apos;s ending condition is i * i &lt;= num instead of i &lt;= sqrt(num)   // to avoid repeatedly calling an expensive function sqrt().   for (int i = 2; i * i &lt;= num; i++) {      if (num % i == 0) return false;   }   return true;}4、  The Sieve of Eratosthenes is one of the most efficient ways to find all prime numbers up to n. But don&apos;t let that name scare you, I promise that the concept is surprisingly simple.Sieve of Eratosthenes: algorithm steps for primes below 121. &quot;Sieve of Eratosthenes Animation&quot; by SKopp is licensed under CC BY 2.0.We start off with a table of n numbers. Let&apos;s look at the first number, 2. We know all multiples of 2 must not be primes, so we mark them off as non-primes. Then we look at the next number, 3. Similarly, all multiples of 3 such as 3 × 2 = 6, 3 × 3 = 9, ... must not be primes, so we mark them off as well. Now we look at the next number, 4, which was already marked off. What does this tell you? Should you mark off all multiples of 4 as well?5、  4 is not a prime because it is divisible by 2, which means all multiples of 4 must also be divisible by 2 and were already marked off. So we can skip 4 immediately and go to the next number, 5. Now, all multiples of 5 such as 5 × 2 = 10, 5 × 3 = 15, 5 × 4 = 20, 5 × 5 = 25, ... can be marked off. There is a slight optimization here, we do not need to start from 5 × 2 = 10. Where should we start marking off?6、  In fact, we can mark off multiples of 5 starting at 5 × 5 = 25, because 5 × 2 = 10 was already marked off by multiple of 2, similarly 5 × 3 = 15 was already marked off by multiple of 3. Therefore, if the current number is p, we can always mark off multiples of p starting at p2, then in increments of p: p2 + p, p2 + 2p, ... Now what should be the terminating loop condition?7、  It is easy to say that the terminating loop condition is p &lt; n, which is certainly correct but not efficient. Do you still remember Hint #3?8、  Yes, the terminating loop condition can be p &lt; √n, as all non-primes ≥ √n must have already been marked off. When the loop terminates, all the numbers in the table that are non-marked are prime.The Sieve of Eratosthenes uses an extra O(n) memory and its runtime complexity is O(n log log n). For the more mathematically inclined readers, you can read more about its algorithm complexity on Wikipedia.</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> counts = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; isPrimes(n, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">2</span>;i*i&lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!isPrimes[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i*i;j&lt; n;j+=i)</span><br><span class="line">&#123;</span><br><span class="line">isPrimes[j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (isPrimes[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">counts++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> counts;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Count the number of prime numbers less than a non - negative number, n.&lt;/p&gt;
&lt;h2 id=&quot;题意：&quot;&gt;&lt;a href=&quot;#题意：&quot; class=&quot;headerlink&quot; title=&quot;题意：&quot;&gt;&lt;/a&gt;题意：&lt;/h2&gt;&lt;p&gt;　　计算小于n的非负数的质数的个数。&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>203. Remove Linked List Elements</title>
    <link href="http://yoursite.com/2017/08/28/203-Remove-Linked-List-Elements/"/>
    <id>http://yoursite.com/2017/08/28/203-Remove-Linked-List-Elements/</id>
    <published>2017-08-28T13:46:57.000Z</published>
    <updated>2018-04-07T14:44:08.694Z</updated>
    
    <content type="html"><![CDATA[<p>Remove all elements from a linked list of integers that have value val.</p><p>Example<br>Given : 1 – &gt; 2 – &gt; 6 – &gt; 3 – &gt; 4 – &gt; 5 – &gt; 6, val = 6<br>Return: 1 – &gt; 2 – &gt; 3 – &gt; 4 – &gt; 5</p><a id="more"></a><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　删除链表中所有与给定值相等的元素节点。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>　　思路很简单，一边遍历一边删除链表比较链表中元素值，如果等于目标值直接删除节点。<strong>注意：</strong>1、删除的节点在头结点的情况；2、删除节点后记得释放内存空间；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode <span class="title">removeHead</span><span class="params">(<span class="number">-1</span>)</span></span>;<span class="comment">//建立临时头结点、便于删除链表第一个节点</span></span><br><span class="line">ListNode *tempHead = &amp;removeHead;</span><br><span class="line">tempHead-&gt;next = head;</span><br><span class="line">ListNode *pre = head;</span><br><span class="line"><span class="keyword">while</span> (pre != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pre-&gt;val == val)</span><br><span class="line">&#123;</span><br><span class="line">tempHead-&gt;next = pre-&gt;next;</span><br><span class="line">pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/*new     &lt;--&gt;  delete</span></span><br><span class="line"><span class="comment">  new[]   &lt;--&gt;  delete[]</span></span><br><span class="line"><span class="comment">  malloc  &lt;--&gt;  free</span></span><br><span class="line"><span class="comment">              C++中的new / delete是新实现的内存分配器，而malloc和free是C标准库实现的另一套内存分配器，他们走的是不同的算法，所以不能混用了.*/</span></span><br><span class="line"><span class="keyword">delete</span>(pre);</span><br><span class="line"><span class="comment">//free(pre);</span></span><br><span class="line">pre = tempHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">pre = pre-&gt;next;</span><br><span class="line">tempHead = tempHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> removeHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Remove all elements from a linked list of integers that have value val.&lt;/p&gt;
&lt;p&gt;Example&lt;br&gt;Given : 1 – &amp;gt; 2 – &amp;gt; 6 – &amp;gt; 3 – &amp;gt; 4 – &amp;gt; 5 – &amp;gt; 6, val = 6&lt;br&gt;Return: 1 – &amp;gt; 2 – &amp;gt; 3 – &amp;gt; 4 – &amp;gt; 5&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>202. Happy Number</title>
    <link href="http://yoursite.com/2017/08/28/202-Happy-Number/"/>
    <id>http://yoursite.com/2017/08/28/202-Happy-Number/</id>
    <published>2017-08-28T13:35:49.000Z</published>
    <updated>2018-04-07T14:44:08.694Z</updated>
    
    <content type="html"><![CDATA[<p>Write an algorithm to determine if a number is “happy”.</p><p>A happy number is a number defined by the following process : Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p><p>Example : 19 is a happy number<br>​    1^2 + 9^2 = 82<br>​    8^2 + 2^2 = 68<br>​    6^2 + 8^2 = 100<br>​    1^2 + 0^2 + 0^2 = 1</p><a id="more"></a><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　写一个算法来判断一个数字是否“happy”。<br>　　一个“happy”的数字是由下面的过程定义的一个数字：从任何正整数开始，用它的数字的平方代替数字，重复这个过程直到数字等于1，或者在一个不包括1的循环中循环。这个过程以1结尾的数字是“happy”数字。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>　　递归循环求得数字的每一位，对每一位求平方再求和，求出来的和判断是否为1，如果为1循环结束，数字是happy数字，如果不为1，判断此和是否出现过，如果出现过说明求和出现循环，数字不是happy数字，如果没有重复出现过此和，则继续对此数字逐位求平方和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; digital;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; placeDig;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt;"循环第"&lt;&lt; ++count &lt;&lt; "次"&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">while</span> (n) &#123;</span><br><span class="line"><span class="keyword">int</span> dig = n % <span class="number">10</span>;</span><br><span class="line">n /= <span class="number">10</span>;</span><br><span class="line">digital.push_back(dig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num : digital) &#123;</span><br><span class="line">sum += <span class="built_in">pow</span>(num, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "sum:::" &lt;&lt; sum &lt;&lt; endl;</span></span><br><span class="line">digital.clear();</span><br><span class="line"><span class="keyword">if</span> (sum == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">auto</span> res = placeDig.insert(sum);<span class="comment">//判断此和是否循环出现过，set如果元素存在，insert()方法返回值的pair第二个元素为false</span></span><br><span class="line"><span class="keyword">if</span> (res.second == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">n = sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Write an algorithm to determine if a number is “happy”.&lt;/p&gt;
&lt;p&gt;A happy number is a number defined by the following process : Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.&lt;/p&gt;
&lt;p&gt;Example : 19 is a happy number&lt;br&gt;​    1^2 + 9^2 = 82&lt;br&gt;​    8^2 + 2^2 = 68&lt;br&gt;​    6^2 + 8^2 = 100&lt;br&gt;​    1^2 + 0^2 + 0^2 = 1&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>199. Binary Tree Right Side View</title>
    <link href="http://yoursite.com/2017/08/26/199-Binary-Tree-Right-Side-View/"/>
    <id>http://yoursite.com/2017/08/26/199-Binary-Tree-Right-Side-View/</id>
    <published>2017-08-26T09:57:24.000Z</published>
    <updated>2018-04-07T14:44:08.694Z</updated>
    
    <content type="html"><![CDATA[<p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">For example:</span><br><span class="line">Given the following binary tree,</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>            &lt;---</span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span>         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  <span class="number">5</span>     <span class="number">4</span>       &lt;---</span><br><span class="line">You should <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>].</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　给定一棵二叉树，返回从右边看这棵二叉树所看到的节点序列（从上到下）。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>　　层次遍历法，遍历到每层最后一个节点时，把其放到结果集中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">if</span> (!root)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"><span class="built_in">queue</span>&lt;TreeNode*&gt; que1;</span><br><span class="line">que1.push(root);</span><br><span class="line"><span class="keyword">while</span> (!que1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;TreeNode*&gt; que2;</span><br><span class="line"><span class="keyword">while</span> (!que1.empty()) &#123;</span><br><span class="line">TreeNode* temp = que1.front();</span><br><span class="line">que1.pop();</span><br><span class="line"><span class="keyword">if</span> (temp-&gt;left)</span><br><span class="line">&#123;</span><br><span class="line">que2.push(temp-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp-&gt;right)</span><br><span class="line">&#123;</span><br><span class="line">que2.push(temp-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (que1.empty())</span><br><span class="line">&#123;</span><br><span class="line">res.push_back(temp-&gt;val);<span class="comment">//取最右边元素放入结果集</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">que1 = que2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;For example:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Given the following binary tree,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;            &amp;lt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; /   \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;     &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;         &amp;lt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; \     \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;     &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;       &amp;lt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;You should &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;].&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>188. Best Time to Buy and Sell Stock IV</title>
    <link href="http://yoursite.com/2017/08/26/188-Best-Time-to-Buy-and-Sell-Stock-IV/"/>
    <id>http://yoursite.com/2017/08/26/188-Best-Time-to-Buy-and-Sell-Stock-IV/</id>
    <published>2017-08-26T09:17:29.000Z</published>
    <updated>2018-04-07T14:44:08.678Z</updated>
    
    <content type="html"><![CDATA[<p>Say you have an array for which the ith element is the price of a given stock on day i.<br>Design an algorithm to find the maximum profit. You may complete at most k transactions.</p><p>Note:<br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><a id="more"></a><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　一个数组第i个元素是表示股票在第i天的价格，只允许<strong>最多完成k次交易</strong>，设计一个找到最大收益的算法。<br>　　<strong>注意：</strong>不能从事多个交易在同一时间（即，你必须卖出股票后，才能再次购买股票）。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>　　典型的动态规划股票问题，这应该是股票问题中最难的，完成k次交易，获得最大收益。思路同<a href="http://blog.taoaili999.cn/2017/08/21/121-Best-Time-to-Buy-and-Sell-Stock/" target="_blank" rel="noopener">121. Best Time to Buy and Sell Stock</a>，<a href="http://blog.taoaili999.cn/2017/08/21/122-Best-Time-to-Buy-and-Sell-Stock-II/" target="_blank" rel="noopener">122. Best Time to Buy and Sell Stock II</a>，<a href="http://blog.taoaili999.cn/2017/08/21/123-Best-Time-to-Buy-and-Sell-Stock-III/" target="_blank" rel="noopener">123. Best Time to Buy and Sell Stock III</a>，利用动态规划的局部最优构造全局最优的思想解决问题。</p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">题目的关键是下面的动态转移方程:</span><br><span class="line">local[i][j]=max(global[i<span class="number">-1</span>][j<span class="number">-1</span>]+max(diff,<span class="number">0</span>),local[i<span class="number">-1</span>][j]+diff)，</span><br><span class="line">global[i][j]=max(local[i][j],global[i<span class="number">-1</span>][j])，</span><br><span class="line"></span><br><span class="line">而这个方程的具体理解如下：</span><br><span class="line"></span><br><span class="line">首先global比较简单，不过是不断地和已经计算出的local进行比较，把大的保存在global中。</span><br><span class="line"></span><br><span class="line">然后看local,关键是要理解local的定义，local[i][j]表示，前i天进行了j次交易，并且第i天进行了第j次交易的最大利润，所以local[i][j]中必然有一次交易，也就是当近一次交易，发生在第i天。 local由两个部分的比较完成。</span><br><span class="line"></span><br><span class="line">第一部分是，global[i<span class="number">-1</span>][j<span class="number">-1</span>]+max(diff,<span class="number">0</span>), 表示的就是，前面把之前的j - <span class="number">1</span>次交易，放在之前的i - <span class="number">1</span>天，然后让第i天来进行第j次交易，那么加入此时diff(price[i] - price[i - <span class="number">1</span>])大于零，那么正好可以可借助这次交易的机会增长里利润(利润= diff)，否则的话，如果diff小于零，那就在第i天当天进行一次买卖，凑一次交易的次数，但是产生利润为<span class="number">0.</span></span><br><span class="line"></span><br><span class="line">第二部分是, local[i<span class="number">-1</span>][j]+diff， 这里的 local[i<span class="number">-1</span>][j]表示的是，前面j次交易在第i <span class="number">-1</span>天就已经完成了，可是因为说了local[a][b]一定要表达在第a天完成了b次交易的最大利润，所以就需要强制使得交易在第i天发生，为了实现这一点，只需要在local[i - <span class="number">1</span>][j]的基础上，加上diff(price[i] - price[i - <span class="number">1</span>])就可以了。如果diff &lt; <span class="number">0</span> 那也没有办法，因为必须满足local的定义。接下来算global的时候，总会保证取得一个更大的值。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">这一题的难度要远高于前面几题，需要用到动态规划，但是需要额外的辅助。</span><br><span class="line">先按照之前的方法对数组进行统计，计算出无限制条件下的最少交易次数tradeCount和最大获益profitCount。如果这个最少交易次数已经小于k了，那么直接返回最大获益即可。同时也因为在k &lt; tradeCount的情况下，进行动态规划的效率很低，所以要先进行处理来避免。</span><br><span class="line"></span><br><span class="line">在动态规划的部分，维护两个数组：local和global。其中local[i][j]表示总交易次数为i截止到第j天并且在最后一天要做交易的情况下的最大获益，global[i][j]表示总交易次数为i截止到第j天的最大获益。</span><br><span class="line"></span><br><span class="line">之所以在global之外还要维护一个local数组，是因为在计算global[i][j]时，面临两种情况：</span><br><span class="line"></span><br><span class="line">    最后一天不做交易，那么直接等于global[i][j - <span class="number">1</span>]</span><br><span class="line">    最后一天要做交易，那么又需要分别考虑罪有一天是否有收益的问题，所以要增加一个local数组进行辅助</span><br><span class="line"></span><br><span class="line">递推公式：</span><br><span class="line"><span class="keyword">int</span> diff = prices[j] - prices[j - <span class="number">1</span>];</span><br><span class="line">local[i][j] = Math.max(global[i - <span class="number">1</span>][j - <span class="number">1</span>], local[i][j - <span class="number">1</span>] + diff);</span><br><span class="line">global[i][j] = Math.max(global[i][j - <span class="number">1</span>], local[i][j]);</span><br><span class="line"></span><br><span class="line">解释一下local[i][j] = Math.max(global[i - <span class="number">1</span>][j - <span class="number">1</span>], local[i][j - <span class="number">1</span>] + diff);这一条，当diff &lt; <span class="number">0</span>时，在最后一条做交易必然是亏的，所以其实此时local[i][j]直接等于global[i - <span class="number">1</span>][j - <span class="number">1</span>]；当diff &gt; <span class="number">0</span>时，本来应该比较两种情况的，global[i - <span class="number">1</span>][j - <span class="number">1</span>] + diff和local[i][j - <span class="number">1</span>] + diff，但是通过以下推断我们可以知道local[i][j - <span class="number">1</span>] &gt; global[i - <span class="number">1</span>][j - <span class="number">1</span>]，所以无须比较。</span><br><span class="line"></span><br><span class="line">推断：</span><br><span class="line"></span><br><span class="line">因为global[i - <span class="number">1</span>][j - <span class="number">1</span>] = Math.max(global[i - <span class="number">1</span>][j - <span class="number">2</span>], local[i - <span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line">所以global[i - <span class="number">1</span>][j - <span class="number">1</span>] = global[i - <span class="number">1</span>][j - <span class="number">2</span>]或者global[i - <span class="number">1</span>][j - <span class="number">1</span>] = local[i - <span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">由题意可知：local[i][j - <span class="number">1</span>] &gt; local[i - <span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">又因为local[i][j - <span class="number">1</span>] = Math.max(global[i - <span class="number">1</span>][j - <span class="number">2</span>], local[i][j - <span class="number">2</span>] + diff)</span><br><span class="line">所以local[i][j - <span class="number">1</span>] &gt;= global[i - <span class="number">1</span>][j - <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">综上local[i][j - <span class="number">1</span>] &gt; local[i - <span class="number">1</span>][j - <span class="number">1</span>])并且local[i][j - <span class="number">1</span>] &gt;= global[i - <span class="number">1</span>][j - <span class="number">2</span>]，即local[i][j - <span class="number">1</span>] &gt; global[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">这里还有一个性质，就是当i大于最大收益所需的交易次数时，其实local[i][j] == global[i][j]，多出来的交易都是当天买卖，不会产生收益。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//“局部最优和全局最优解法”</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = prices.size();</span><br><span class="line"><span class="keyword">if</span> (k==<span class="number">0</span>||len&lt;<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k&gt;=len/<span class="number">2</span>)<span class="comment">//k大于最多交易次数就变为122. Best Time to Buy and Sell Stock II</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">res += max(<span class="number">0</span>, prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; local(len, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; global(len, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;len;i++)<span class="comment">//注意动态方程中天数和交易次数在二维数组中行列顺序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*int diff = prices[j] - prices[j - 1];</span></span><br><span class="line"><span class="comment">local[i][j] = Math.max(global[i - 1][j - 1], local[i][j - 1] + diff);</span></span><br><span class="line"><span class="comment">global[i][j] = Math.max(global[i][j - 1], local[i][j]);*/</span></span><br><span class="line"><span class="keyword">int</span> diff = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line"><span class="comment">//local[i][j] = max(global[i - 1][j - 1] + max(diff, 0), local[i-1][j] + diff);</span></span><br><span class="line">local[i][j] = max(global[i - <span class="number">1</span>][j - <span class="number">1</span>], local[i<span class="number">-1</span>][j] + diff);<span class="comment">//此处local[i][j]表示总交易次数为i截止到第j天并且在最后一天要做交易的情况下的最大获益，global[i][j]表示总交易次数为i截止到第j天的最大获益。i表示交易次数，j表示第几天。</span></span><br><span class="line">global[i][j] = max(global[i<span class="number">-1</span>][j], local[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> global[len - <span class="number">1</span>][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>　　不太懂的一个方法,思路同<a href="http://blog.taoaili999.cn/2017/08/21/123-Best-Time-to-Buy-and-Sell-Stock-III/" target="_blank" rel="noopener">123. Best Time to Buy and Sell Stock III</a>方法二，代码简洁，但是不太理解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = prices.size();</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">0</span> || len&lt;<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k &gt;= len / <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;len; i++)</span><br><span class="line">&#123;</span><br><span class="line">res += max(<span class="number">0</span>, prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buy(k+<span class="number">1</span>,INT_MIN),sale(k+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">&#123;</span><br><span class="line">buy[j] = max(buy[j], sale[j - <span class="number">1</span>] - prices[i]);</span><br><span class="line">sale[j] = max(sale[j], buy[j] + prices[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sale[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;br&gt;Design an algorithm to find the maximum profit. You may complete at most k transactions.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>187. Repeated DNA Sequences</title>
    <link href="http://yoursite.com/2017/08/26/187-Repeated-DNA-Sequences/"/>
    <id>http://yoursite.com/2017/08/26/187-Repeated-DNA-Sequences/</id>
    <published>2017-08-26T08:49:25.000Z</published>
    <updated>2018-04-07T14:44:08.678Z</updated>
    
    <content type="html"><![CDATA[<p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”.When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.</p><p>Write a function to find all the 10 - letter - long sequences(substrings) that occur more than once in a DNA molecule.</p><p>For example<br>Given s = “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”,<br>Return:<br>[“AAAAACCCCC”, “CCCCCAAAAA”].</p><a id="more"></a><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　所有的DNA都是由简写为A，C，G，T的核苷酸构成的，例如ACGAATTCCG。在研究DNA时，辨别DNA中重复的序列在有些时候是很有用的。<br>　　编写一个程序来找到一个DNA分子中出现次数超过一次的长度为10的子序列（子串）。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>　　如果时间上没有要求的话，用find和substr搞定是没问题的，然而在测试数据较大的时候这种方法必然会超时。这个题的标签是Hash Table和Bit Manipulation，参考<a href="https://leetcode.com/discuss/24478/i-did-it-in-10-lines-of-c中的方案，需要利用hash表，以及按位运算来解决此题。" target="_blank" rel="noopener">https://leetcode.com/discuss/24478/i-did-it-in-10-lines-of-c中的方案，需要利用hash表，以及按位运算来解决此题。</a><br>　　测试数据中只会出现4种字符’A’,’C’,’G’,’T’，其ASC值分别为65,67,71,84,对应的二进制位如下所示，这里仅列取32位情况下的低8位，前24位全部为0。<br>　　　　　　A — 65 — 0100 0001<br>　　　　　　C — 67 — 0100 0011<br>　　　　　　G — 71 — 0100 0111<br>　　　　　　T — 84 — 0101 0100<br>　　可以发现，仅通过低3位就能把4种字符区分开来，题目又要求了是长度为10的子串（10-letter-long），试想为什么不是11或者更大呢，因为10个字符每个用3位表示一个字符的话刚好是30位，而一个int是32位，刚好能放下，如果是11+就放不下了。因此，我们可以把一个长度为10的字符串映射成一个int数，用其低30位表示这个串，作为这个串的key，然后把key存在Hash Table中，当key重复出现时就代表子串重复出现了。</p><p>　　除了上述方法外，受其启发，其实只用2个二进制位就可以唯一区分4中字符，比如A-00,C-01,G-10,T-11，这样，我们只用int的低20位就可以表示一个字符串的key，这种方法甚至可以最多用于处理长度为16的子串。比上面一种方法略显复杂的是，需要手动将ACGT映射成2位二进制数，方法也是多种多样的。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转换2位二进制数方法一：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">char</span> c)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'A'</span>: <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'G'</span>: ret = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'C'</span>: ret = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'T'</span>: ret = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换2位二进制数方法二：</span></span><br><span class="line"><span class="comment">// 数组映射，调用时使用nums[c - 65]即可得到字符c的映射码</span></span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">20</span>]; </span><br><span class="line">nums[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">nums[<span class="number">2</span>] = <span class="number">1</span>; </span><br><span class="line">nums[<span class="number">6</span>] = <span class="number">2</span>; </span><br><span class="line">nums[<span class="number">19</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换2位二进制数方法三：</span></span><br><span class="line"><span class="comment">//(s[i] - 64) % 5完成映射</span></span><br><span class="line"> A : (<span class="string">'A'</span> - <span class="number">64</span>) % <span class="number">5</span> = <span class="number">1</span>  (mod <span class="number">5</span>) = <span class="number">1</span> = <span class="number">01</span></span><br><span class="line"> B : (<span class="string">'C'</span> - <span class="number">64</span>) % <span class="number">5</span> = <span class="number">3</span>  (mod <span class="number">5</span>) = <span class="number">3</span> = <span class="number">11</span></span><br><span class="line"> C : (<span class="string">'G'</span> - <span class="number">64</span>) % <span class="number">5</span> = <span class="number">7</span>  (mod <span class="number">5</span>) = <span class="number">2</span> = <span class="number">10</span></span><br><span class="line"> D : (<span class="string">'T'</span> - <span class="number">64</span>) % <span class="number">5</span> = <span class="number">20</span> (mod <span class="number">5</span>) = <span class="number">0</span> = <span class="number">00</span></span><br><span class="line">key = key &lt;&lt; <span class="number">2</span> &amp; <span class="number">0xfffff</span> | (s[i] - <span class="number">64</span>) % <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>　　用ACGT的ASC码的后2位来映射的解法，然后做移位操作，相与操作后，下面代码中&amp;0xfffff应该保证后20位相等，即加入一个字符构成的序列的key值，只要重复前面出现，经过key = ((key &lt;&lt; 2) | ((s[i] - 64) % 5))&0xfffff;计算的key值就会相等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRepeatedDnaSequences(<span class="built_in">string</span> s) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line"><span class="keyword">if</span> (s.size()&lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line"><span class="keyword">int</span> key = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;i&lt;<span class="number">9</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line">key = ((key &lt;&lt; <span class="number">2</span>) | ((s[i] - <span class="number">64</span>) % <span class="number">5</span>))&amp;<span class="number">0xfffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (;i&lt;s.size();++i)</span><br><span class="line">&#123;</span><br><span class="line">key = ((key &lt;&lt; <span class="number">2</span>) | ((s[i] - <span class="number">64</span>) % <span class="number">5</span>))&amp;<span class="number">0xfffff</span>;</span><br><span class="line"><span class="keyword">int</span> val = hash[key];</span><br><span class="line">hash[key]++;</span><br><span class="line"><span class="keyword">if</span> (val == <span class="number">1</span>)</span><br><span class="line">res.push_back(s.substr(i - <span class="number">9</span>, <span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>　　用ACGT的ASC码的后3位来映射的解法。在代码编写中，对于最开始的9个字符是为了构造第一个key而做功，一般说来从第10个字符开始才开始判定key的重复出现情况。然而由于AGCT的映射码均为三位且没有任何一个码是000，因此在前面9个字符也是可以与其他字符一致处理的，不会出现误判。一致处理的代码大致如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRepeatedDnaSequences(<span class="built_in">string</span> s) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, end = s.size(); i &lt; end; ++i) &#123;</span><br><span class="line">key = ((key &lt;&lt; <span class="number">3</span>) | (s[i] &amp; <span class="number">0x7</span>)) &amp; <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> val = <span class="built_in">map</span>[key]++;</span><br><span class="line"><span class="keyword">if</span> (val == <span class="number">1</span>)</span><br><span class="line">strs.push_back(s.substr(i - <span class="number">9</span>, <span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> strs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不一致处理的代码大概如下，先处理前9个字符，然后处理后面的：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRepeatedDnaSequences(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line">        <span class="keyword">if</span> (s.size() &lt;= <span class="number">10</span>) <span class="keyword">return</span> strs;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">int</span> key = <span class="number">0</span>, i = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">            key = ((key &lt;&lt; <span class="number">3</span>) | (s[i] &amp; <span class="number">0x7</span>)) &amp; <span class="number">0x3fffffff</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = s.size(); i &lt; end; ++i) &#123;</span><br><span class="line">            key = ((key &lt;&lt; <span class="number">3</span>) | (s[i] &amp; <span class="number">0x7</span>)) &amp; <span class="number">0x3fffffff</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[key]++ == <span class="number">1</span>)</span><br><span class="line">                strs.push_back(s.substr(i - <span class="number">9</span>, <span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>### </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”.When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.&lt;/p&gt;
&lt;p&gt;Write a function to find all the 10 - letter - long sequences(substrings) that occur more than once in a DNA molecule.&lt;/p&gt;
&lt;p&gt;For example&lt;br&gt;Given s = “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”,&lt;br&gt;Return:&lt;br&gt;[“AAAAACCCCC”, “CCCCCAAAAA”].&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>179. Largest Number</title>
    <link href="http://yoursite.com/2017/08/26/179-Largest-Number/"/>
    <id>http://yoursite.com/2017/08/26/179-Largest-Number/</id>
    <published>2017-08-26T08:41:40.000Z</published>
    <updated>2018-04-07T14:44:08.678Z</updated>
    
    <content type="html"><![CDATA[<p>Given a list of non negative integers, arrange them such that they form the largest number.<br>For example, given[3, 30, 34, 5, 9], the largest formed number is 9534330.<br>Note : The result may be very large, so you need to return a string instead of an integer.</p><a id="more"></a><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>　　给定一组非负整数数组，排列组合这些整数，使其构成所有组合中最大的数。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>　　分析如下：<br>　　　　eg1. [0, 0, 0 , 0] -&gt;  0<br>　　　　eg2. [1211, 12] -&gt; 121211而不是121112。<br>　　　　所以可以考虑排序，而排序的根据(也就是比较函数的比较原理)不是这些数的值的相对大小，而是它们构成新的数的大小比较。<br>　　　　所以，虽然1211 &gt; 12， 但是<br>　　　　“1211” + “12” = “121112”,<br>　　　　“12” + “1211” = “121211”,<br>　　　　“121112” &lt; “121211”<br>　　所以从构成新的数的角度来看, “1211” &lt; “12” 。</p><p>　　对所有数进行排序，规则如下：<br>　　　　给定两个非负整数：a, b<br>　　　　将它们转换成字符串形式，然后进行连接。可得两种结果：<br>　　　　a在前，b在后，记为：strAB<br>　　　　b在前，a在后，记为：strBA<br>　　　　如果strAB &gt; strBA，那么排序时a在b的前面。</p><p>　　其他的就是要注意全是0的情况和前导0的情况.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(nums.begin(), nums.end(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;<span class="keyword">return</span> to_string(a) + to_string(b) &gt; to_string(b) + to_string(a); &#125;);</span><br><span class="line"><span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> rr : nums)</span><br><span class="line">&#123;</span><br><span class="line">res += to_string(rr);</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">/* Input: [0, 0]</span></span><br><span class="line"><span class="comment">Output : "00"</span></span><br><span class="line"><span class="comment">Expected : "0"</span></span><br><span class="line"><span class="comment">其他的就是要注意全是0的情况和前导0的情况</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">/*if (res[0]=='0')</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">return "0";</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">return res;*/</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">auto</span> pos = res.find_first_not_of(<span class="string">'0'</span>);</span><br><span class="line"><span class="keyword">return</span> pos == <span class="built_in">string</span>::npos ? <span class="string">"0"</span> : res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a list of non negative integers, arrange them such that they form the largest number.&lt;br&gt;For example, given[3, 30, 34, 5, 9], the largest formed number is 9534330.&lt;br&gt;Note : The result may be very large, so you need to return a string instead of an integer.&lt;/p&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
</feed>
